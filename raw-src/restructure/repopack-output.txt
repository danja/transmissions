This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-06T19:25:10.735Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
input/
  input_01.json
  mapping_01.json
output/
  output_01.json
  required_01.json
compare.js
restructure.js
run.js

================================================================
Repository Files
================================================================

================
File: input/input_01.json
================
{
    "A": "zero",
    "B": {
        "a1": "one",
        "a2": "two",
        "a3": [
            {
                "a31": "three",
                "a32": "four"
            },
            {
                "a33": "five",
                "a34": "six"
            }
        ]
    },
    "C": {
        "c1": "seven"
    }
}

================
File: input/mapping_01.json
================
{
    "mappings": [
        {
            "pre": "A",
            "post": "U"
        },
        {
            "pre": "B.a1",
            "post": "V"
        },
        {
            "pre": "B.a3",
            "post": "W"
        },
        {
            "pre": "C.c1",
            "post": "X.d"
        }
    ]
}

================
File: output/output_01.json
================
{
  "U": "zero",
  "V": "one",
  "W": [
    {
      "a31": "three",
      "a32": "four"
    },
    {
      "a33": "five",
      "a34": "six"
    }
  ],
  "X": {
    "d": "seven"
  }
}

================
File: output/required_01.json
================
{
    "U": "zero",
    "V": "one",
    "W": [
        {
            "a31": "three",
            "a32": "four"
        },
        {
            "a33": "five",
            "a34": "six"
        }
    ],
    "X": {
        "d": "sevenn"
    }
}

================
File: compare.js
================
// verify.js
import fs from 'fs/promises';
import path from 'path';

const findDifferences = (obj1, obj2, path = '') => {
    const differences = [];
    
    // Handle different types or null/undefined
    if (typeof obj1 !== typeof obj2) {
        return [`${path}: Type mismatch - ${typeof obj1} vs ${typeof obj2}`];
    }
    if (obj1 === null || obj2 === null) {
        if (obj1 !== obj2) {
            return [`${path}: Null mismatch`];
        }
        return [];
    }
    
    // Handle arrays
    if (Array.isArray(obj1) && Array.isArray(obj2)) {
        if (obj1.length !== obj2.length) {
            return [`${path}: Array length mismatch - ${obj1.length} vs ${obj2.length}`];
        }
        obj1.forEach((item, idx) => {
            differences.push(...findDifferences(item, obj2[idx], `${path}[${idx}]`));
        });
        return differences;
    }
    
    // Handle objects
    if (typeof obj1 === 'object') {
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        
        // Check for missing keys
        keys1.forEach(key => {
            if (!keys2.includes(key)) {
                differences.push(`${path ? path + '.' : ''}${key}: Missing in required`);
            }
        });
        
        keys2.forEach(key => {
            if (!keys1.includes(key)) {
                differences.push(`${path ? path + '.' : ''}${key}: Missing in output`);
            }
        });
        
        // Check values for common keys
        keys1.filter(key => keys2.includes(key)).forEach(key => {
            differences.push(...findDifferences(
                obj1[key], 
                obj2[key], 
                path ? `${path}.${key}` : key
            ));
        });
        
        return differences;
    }
    
    // Handle primitives
    if (obj1 !== obj2) {
        return [`${path}: Value mismatch - ${obj1} vs ${obj2}`];
    }
    
    return [];
};

export async function verifyOutputs(dir = './output') {
    const results = {};
    try {
        const files = await fs.readdir(dir);
        const outputFiles = files.filter(f => f.startsWith('output_'));
        
        for (const outputFile of outputFiles) {
            const index = outputFile.match(/\d+/)[0];
            const requiredFile = `required_${index}.json`;
            
            if (!files.includes(requiredFile)) {
                console.warn(`No required file found for ${outputFile}`);
                continue;
            }
            
            const output = JSON.parse(
                await fs.readFile(path.join(dir, outputFile), 'utf8')
            );
            const required = JSON.parse(
                await fs.readFile(path.join(dir, requiredFile), 'utf8')
            );
            
            const differences = findDifferences(output, required);
            results[index] = {
                matches: differences.length === 0,
                differences
            };
        }
        
        return results;
    } catch (error) {
        console.error('Error verifying outputs:', error);
        throw error;
    }
}

// Example usage:
const results = await verifyOutputs();
console.log(JSON.stringify(results, null, 2));

================
File: restructure.js
================
// restructure.js
import fs from 'fs/promises';
import path from 'path';

const getValueByPath = (obj, path) => {
    try {
        return path.split('.').reduce((acc, part) => acc[part], obj);
    } catch (e) {
        console.warn(`Warning: Path ${path} not found`);
        return undefined;
    }
};

const setValueByPath = (obj, path, value) => {
    const parts = path.split('.');
    const last = parts.pop();
    const target = parts.reduce((acc, part) => {
        acc[part] = acc[part] || {};
        return acc[part];
    }, obj);
    target[last] = value;
};

export async function restructureJson(inputDir = './input', outputDir = './output') {
    try {
        await fs.mkdir(outputDir, { recursive: true });
        const files = await fs.readdir(inputDir);
        
        const inputFiles = files.filter(f => f.startsWith('input_'));
        const mappingFiles = files.filter(f => f.startsWith('mapping_'));

        for (const inputFile of inputFiles) {
            const index = inputFile.match(/\d+/)[0];
            const mappingFile = mappingFiles.find(f => f.includes(index));
            
            if (!mappingFile) {
                console.warn(`No mapping file found for ${inputFile}`);
                continue;
            }

            const inputData = JSON.parse(
                await fs.readFile(path.join(inputDir, inputFile), 'utf8')
            );
            const mappingData = JSON.parse(
                await fs.readFile(path.join(inputDir, mappingFile), 'utf8')
            );

            if (!mappingData.mappings || !Array.isArray(mappingData.mappings)) {
                throw new Error(`Invalid mapping structure in ${mappingFile}`);
            }

            const result = {};
            mappingData.mappings.forEach(({ pre, post }) => {
                const value = getValueByPath(inputData, pre);
                if (value !== undefined) {
                    setValueByPath(result, post, value);
                }
            });

            await fs.writeFile(
                path.join(outputDir, `output_${index}.json`),
                JSON.stringify(result, null, 2)
            );
        }
    } catch (error) {
        console.error('Error processing files:', error);
        throw error;
    }
}

================
File: run.js
================
import { restructureJson } from './restructure.js';
await restructureJson();
