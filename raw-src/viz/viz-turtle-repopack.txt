================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-19T17:12:51.236Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
viz-turtle current

================================================================
Repository Files
================================================================

================
File: jsonld-turtle.js
================

(function() {
function getProperties(obj) {
  var rval = [];
  for(var key in obj) {
    if(key !== '@id') {
      rval.push(key);
    }
  }
  return rval;
};
function isBnode(iri) {
  return iri.indexOf('_:') === 0;
};
function iriToTurtle(iri) {
  return isBnode(iri) ? iri : ('<' + iri + '>');
};
function objectToString(obj) {
  var rval = '';
  if(obj instanceof Array) {
    // if the object is an array, convert each object in the list
    var firstItem = true;
    for(i in obj) {
      if(firstItem) {
        firstItem = false;
        rval = '\n      ';
      }
      else {
        rval += ',\n      ';
      }
      rval += objectToString(obj[i]);
    }
  }
  else if(obj instanceof Object) {
    if('@value' in obj) {
      rval = '"' + obj['@value'] + '"';
      if('@type' in obj) {
        rval += '^^<' + obj['@type'] + '>';
      }
      else if('@language' in obj) {
        rval += '@' + obj['@language'];
      }
    }
    else if('@id' in obj) {
      rval = iriToTurtle(obj['@id']);
    }
  }
  else {
    rval = '"' + obj + '"';
  }
  return rval;
};
jsonld.turtle = function(input, options, callback) {
  jsonld.normalize(input, options, function(err, normalized) {
    var output = '';
    for(s in normalized) {
      // print out each key in the normalized array (the subjects)
      var subject = normalized[s];
      var iri = subject['@id'];
      if(Object.keys(subject).length === 1) {
        continue;
      }
      output += iriToTurtle(iri) + '\n';
      var properties = getProperties(subject);
      var numProperties = properties.length;
      var count = numProperties;
      for(p in properties) {
        property = properties[p];
        if(property === '@type') {
          output += '   <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> ';
        }
        else {
          output += '   <' + property + '> ';
        }
        output += objectToString(subject[property]);
        if(count === 1) {
          output += '.\n';
        }
        else {
          output += ';\n';
        }
        count -= 1;
      }
    }
    callback(null, output);
  });
};
})();

================
File: jsonld-vis.css
================
@import url("https://fonts.googleapis.com/css?family=Open+Sans:300,400,600");
svg {
  border: none;
}
.node {
  cursor: pointer;
}
.node text {
  font-size: 12px;
  font-family: 'Open Sans', 'Helvetica Neue', Helvetica, sans-serif;
  fill: #333333;
}
.d3-tip {
  font-size: 14px;
  font-family: 'Open Sans', 'Helvetica Neue', Helvetica, sans-serif;
  color: #333333;
  border: 1px solid #CCCCCC;
  border-radius: 5px;
  padding: 10px 20px;
  max-width: 250px;
  word-wrap: break-word;
  background-color: rgba(255, 255, 255, 0.9);
  text-align: left;
}
.link {
  fill: none;
  stroke: #DADFE1;
  stroke-width: 1px;
}

================
File: jsonld-vis.js
================
(function() {
  'use strict';
  function jsonldVis(jsonld, selector, config) {
    if (!arguments.length) return jsonldVis;
    config = config || {};
    var h = config.h || 600
      , w = config.w || 800
      , maxLabelWidth = config.maxLabelWidth || 250
      , transitionDuration = config.transitionDuration || 750
      , transitionEase = config.transitionEase || 'cubic-in-out'
      , minRadius = config.minRadius || 5
      , scalingFactor = config.scalingFactor || 2;
    var i = 0;
    var tree = d3.layout.tree()
      .size([h, w]);
    var diagonal = d3.svg.diagonal()
      .projection(function(d) { return [d.y, d.x]; });
    var svg = d3.select(selector).append('svg')
      .attr('width', w)
      .attr('height', h)
      .append('g')
      .attr('transform', 'translate(' + maxLabelWidth + ',0)');
    var tip = d3.tip()
      .direction(function(d) {
        return d.children || d._children ? 'w' : 'e';
      })
      .offset(function(d) {
        return d.children || d._children ? [0, -3] : [0, 3];
      })
      .attr('class', 'd3-tip')
      .html(function(d) {
        return '<span>' + d.valueExtended + '</span>';
      });
    svg.call(tip);
    var root = jsonldTree(jsonld);
    root.x0 = h / 2;
    root.y0 = 0;
    root.children.forEach(collapse);
    function changeSVGWidth(newWidth) {
      if (w !== newWidth) {
        d3.select(selector + ' > svg').attr('width', newWidth);
      }
    }
    function jsonldTree(source) {
      var tree = {};
      if ('@id' in source) {
        tree.isIdNode = true;
        tree.name = source['@id'];
        if (tree.name.length > maxLabelWidth / 9) {
          tree.valueExtended = tree.name;
          tree.name = '...' + tree.valueExtended.slice(-Math.floor(maxLabelWidth / 9));
        }
      } else {
        tree.isIdNode = true;
        tree.isBlankNode = true;
        tree.name = '_' + Math.random().toString(10).slice(-7);
      }
      var children = [];
      Object.keys(source).forEach(function(key) {
        if (key === '@id' || key === '@context' || source[key] === null) return;
        var valueExtended, value;
        if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
          children.push({
            name: key,
            children: [jsonldTree(source[key])]
          });
        } else if (Array.isArray(source[key])) {
          children.push({
            name: key,
            children: source[key].map(function(item) {
              if (typeof item === 'object') {
                return jsonldTree(item);
              } else {
                return { name: item };
              }
            })
          });
        } else {
          valueExtended = source[key];
          value = valueExtended;
          if (value.length > maxLabelWidth / 9) {
            value = value.slice(0, Math.floor(maxLabelWidth / 9)) + '...';
            children.push({
              name: key,
              value: value,
              valueExtended: valueExtended
            });
          } else {
            children.push({
              name: key,
              value: value
            });
          }
        }
      });
      if (children.length) {
        tree.children = children;
      }
      return tree;
    }
    function update(source) {
      var nodes = tree.nodes(root).reverse();
      var links = tree.links(nodes);
      nodes.forEach(function(d) { d.y = d.depth * maxLabelWidth; });
      var node = svg.selectAll('g.node')
        .data(nodes, function(d) { return d.id || (d.id = ++i); });
      var nodeEnter = node.enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', function(d) { return 'translate(' + source.y0 + ',' + source.x0 + ')'; })
        .on('click', click);
      nodeEnter.append('circle')
        .attr('r', 0)
        .style('stroke-width', function(d) {
          return d.isIdNode ? '2px' : '1px';
        })
        .style('stroke', function(d) {
          return d.isIdNode ? '#F7CA18' : '#4ECDC4';
        })
        .style('fill', function(d) {
          if (d.isIdNode) {
            return d._children ? '#F5D76E' : 'white';
          } else {
            return d._children ? '#86E2D5' : 'white';
          }
        })
        .on('mouseover', function(d) { if (d.valueExtended) tip.show(d); })
        .on('mouseout', tip.hide);
      nodeEnter.append('text')
        .attr('x', function(d) {
          var spacing = computeRadius(d) + 5;
          return d.children || d._children ? -spacing : spacing;
        })
        .attr('dy', '4')
        .attr('text-anchor', function(d) { return d.children || d._children ? 'end' : 'start'; })
        .text(function(d) { return d.name + (d.value ? ': ' + d.value : ''); })
        .style('fill-opacity', 0);
      var maxSpan = Math.max.apply(Math, nodes.map(function(d) { return d.y + maxLabelWidth; }));
      if (maxSpan + maxLabelWidth + 20 > w) {
        changeSVGWidth(maxSpan + maxLabelWidth);
        d3.select(selector).node().scrollLeft = source.y0;
      }
      var nodeUpdate = node.transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('transform', function(d) { return 'translate(' + d.y + ',' + d.x + ')'; });
      nodeUpdate.select('circle')
        .attr('r', function(d) { return computeRadius(d); })
        .style('stroke-width', function(d) {
          return d.isIdNode ? '2px' : '1px';
        })
        .style('stroke', function(d) {
          return d.isIdNode ? '#F7CA18' : '#4ECDC4';
        })
        .style('fill', function(d) {
          if (d.isIdNode) {
            return d._children ? '#F5D76E' : 'white';
          } else {
            return d._children ? '#86E2D5' : 'white';
          }
        });
      nodeUpdate.select('text').style('fill-opacity', 1);
      var nodeExit = node.exit().transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('transform', function(d) { return 'translate(' + source.y + ',' + source.x + ')'; })
        .remove();
      nodeExit.select('circle').attr('r', 0);
      nodeExit.select('text').style('fill-opacity', 0);
      var link = svg.selectAll('path.link')
        .data(links, function(d) { return d.target.id; });
      link.enter().insert('path', 'g')
        .attr('class', 'link')
        .attr('d', function(d) {
          var o = { x: source.x0, y: source.y0 };
          return diagonal({ source: o, target: o });
        });
      link.transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('d', diagonal);
      link.exit().transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('d', function(d) {
          var o = { x: source.x, y: source.y };
          return diagonal({ source: o, target: o });
        })
        .remove();
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }
    function computeRadius(d) {
      if (d.children || d._children) {
        return minRadius + (numEndNodes(d) / scalingFactor);
      } else {
        return minRadius;
      }
    }
    function numEndNodes(n) {
      var num = 0;
      if (n.children) {
        n.children.forEach(function(c) {
          num += numEndNodes(c);
        });
      } else if (n._children) {
        n._children.forEach(function(c) {
          num += numEndNodes(c);
        });
      } else {
        num++;
      }
      return num;
    }
    function click(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update(d);
      if (d.children) {
        d.children.forEach(function(child) {
          if (child.isBlankNode && child._children) {
            click(child);
          }
        });
      }
    }
    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }
    update(root);
  }
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = jsonldVis;
  } else {
    d3.jsonldVis = jsonldVis;
  }
})();

================
File: playground-examples.js
================

(function($) {
  window.playground = window.playground || {};
  var playground = window.playground;
  playground.examples = {};
  playground.frames = {};
  playground.contexts = {};
  playground.examples["Person"] = {
    "@context": "http://schema.org/",
    "@type": "Person",
    "name": "Jane Doe",
    "jobTitle": "Professor",
    "telephone": "(425) 123-4567",
    "url": "http://www.janedoe.com"
  };
  playground.examples["Place"] = {
    "@context": {
      "name": "http://schema.org/name",
      "description": "http://schema.org/description",
      "image": {
        "@id": "http://schema.org/image",
        "@type": "@id"
      },
      "geo": "http://schema.org/geo",
      "latitude": {
        "@id": "http://schema.org/latitude",
        "@type": "xsd:float"
      },
      "longitude": {
        "@id": "http://schema.org/longitude",
        "@type": "xsd:float"
      },
      "xsd": "http://www.w3.org/2001/XMLSchema#"
    },
    "name": "The Empire State Building",
    "description": "The Empire State Building is a 102-story landmark in New York City.",
    "image": "http://www.civil.usherbrooke.ca/cours/gci215a/empire-state-building.jpg",
    "geo": {
       "latitude": "40.75",
       "longitude": "73.98"
    }
  };
  playground.examples["Event"] = {
    "@context": {
      "ical": "http://www.w3.org/2002/12/cal/ical#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "ical:dtstart": {
        "@type": "xsd:dateTime"
      }
    },
    "ical:summary": "Lady Gaga Concert",
    "ical:location": "New Orleans Arena, New Orleans, Louisiana, USA",
    "ical:dtstart": "2011-04-09T20:00:00Z"
  };
  playground.examples["Product"] = {
    "@context": {
      "gr": "http://purl.org/goodrelations/v1#",
      "pto": "http://www.productontology.org/id/",
      "foaf": "http://xmlns.com/foaf/0.1/",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "foaf:page": {"@type": "@id"},
      "gr:acceptedPaymentMethods": {"@type": "@id"},
      "gr:hasBusinessFunction": {"@type": "@id"},
       "gr:hasCurrencyValue": {"@type": "xsd:float"}
    },
    "@id": "http://example.org/cars/for-sale#tesla",
    "@type": "gr:Offering",
    "gr:name": "Used Tesla Roadster",
    "gr:description": "Need to sell fast and furiously",
    "gr:hasBusinessFunction": "gr:Sell",
    "gr:acceptedPaymentMethods": "gr:Cash",
    "gr:hasPriceSpecification": {
      "gr:hasCurrencyValue": "85000",
      "gr:hasCurrency": "USD"
    },
    "gr:includes": {
      "@type": ["gr:Individual", "pto:Vehicle"],
      "gr:name": "Tesla Roadster",
      "foaf:page": "http://www.teslamotors.com/roadster"
    }
  };
  playground.examples["Recipe"] = {
    "@context": {
      "name": "http://rdf.data-vocabulary.org/#name",
      "ingredient": "http://rdf.data-vocabulary.org/#ingredients",
      "yield": "http://rdf.data-vocabulary.org/#yield",
      "instructions": "http://rdf.data-vocabulary.org/#instructions",
      "step": {
        "@id": "http://rdf.data-vocabulary.org/#step",
        "@type": "xsd:integer"
      },
      "description": "http://rdf.data-vocabulary.org/#description",
      "xsd": "http://www.w3.org/2001/XMLSchema#"
    },
    "name": "Mojito",
    "ingredient": ["12 fresh mint leaves", "1/2 lime, juiced with pulp",
      "1 tablespoons white sugar", "1 cup ice cubes",
      "2 fluid ounces white rum", "1/2 cup club soda"],
    "yield": "1 cocktail",
    "instructions" : [{
      "step": 1,
      "description": "Crush lime juice, mint and sugar together in glass."
    }, {
      "step": 2,
      "description": "Fill glass to top with ice cubes."
    }, {
      "step": 3,
      "description": "Pour white rum over ice."
    }, {
      "step": 4,
      "description": "Fill the rest of glass with club soda, stir."
    }, {
      "step": 5,
      "description": "Garnish with a lime wedge."
    }]
  };
  playground.examples["Library"] = {
    "@context": {
      "dc": "http://purl.org/dc/elements/1.1/",
      "ex": "http://example.org/vocab#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "ex:contains": {"@type": "@id"}
    },
    "@graph": [{
      "@id": "http://example.org/library",
      "@type": "ex:Library",
      "ex:contains": "http://example.org/library/the-republic"
    }, {
      "@id": "http://example.org/library/the-republic",
      "@type": "ex:Book",
      "dc:creator": "Plato",
      "dc:title": "The Republic",
      "ex:contains": "http://example.org/library/the-republic#introduction"
    }, {
      "@id": "http://example.org/library/the-republic#introduction",
      "@type": "ex:Chapter",
      "dc:description": "An introductory chapter on The Republic.",
      "dc:title": "The Introduction"
    }]
  };
  playground.frames["Library"] = {
    "@context": {
      "dc": "http://purl.org/dc/elements/1.1/",
      "ex": "http://example.org/vocab#"
    },
    "@type": "ex:Library",
    "ex:contains": {
      "@type": "ex:Book",
      "ex:contains": {"@type": "ex:Chapter"}
    }
  };
  playground.examples["Activity"] = {
    "@context": "https://www.w3.org/ns/activitystreams",
    "@type": "Create",
    "actor": {
      "@type": "Person",
      "@id": "acct:sally@example.org",
      "name": "Sally"
    },
    "object": {
      "@type": "Note",
      "content": "This is a simple note"
    },
    "published": "2015-01-25T12:34:56Z"
  }
})(jQuery);

================
File: test-data/foaf-template.ttl
================
# foaf-template.ttl sample for form-a-matic

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<#ROOT>
    a foaf:Person ;
    foaf:name "LITERAL" ;
    foaf:mbox <#URI> ;
    foaf:homepage <#URI> ;
    foaf:nick "LITERAL" ;
    foaf:depiction <#URI> ;
    foaf:interest <#URI> ;
    foaf:knows [
        a foaf:Person ;
        foaf:name "LITERAL"
    ] .

================
File: viz-turtle.js
================

import rdf from 'rdf-ext';
import { fromFile } from 'rdf-utils-fs';
import * as d3 from 'd3';
import { JSDOM } from 'jsdom';
import fs from 'fs/promises';
const dom = new JSDOM('<!DOCTYPE html><body></body>');
global.document = dom.window.document;
global.window = dom.window;
function datasetToJsonld(dataset) {
    const jsonld = {};
    for (const quad of dataset) {
        const subject = quad.subject.value;
        const predicate = quad.predicate.value;
        const object = quad.object.termType === 'Literal' ? quad.object.value : { '@id': quad.object.value };
        if (!jsonld[subject]) {
            jsonld[subject] = { '@id': subject };
        }
        if (!jsonld[subject][predicate]) {
            jsonld[subject][predicate] = [];
        }
        jsonld[subject][predicate].push(object);
    }
    return Object.values(jsonld);
}
function jsonldVis(jsonldData, config) {
    config = config || {};
    const h = config.h || 600;
    const w = config.w || 800;
    const maxLabelWidth = config.maxLabelWidth || 250;
    const transitionDuration = config.transitionDuration || 750;
    const minRadius = config.minRadius || 5;
    const scalingFactor = config.scalingFactor || 2;
    const body = d3.select(document.body);
    const svg = body.append('svg')
        .attr('width', w)
        .attr('height', h)
        .append('g')
        .attr('transform', `translate(${maxLabelWidth},0)`);
    const tree = d3.tree().size([h, w]);
    const diagonal = d3.linkHorizontal()
        .x(d => d.y)
        .y(d => d.x);
    const root = d3.hierarchy({
        name: 'RDF Graph',
        children: jsonldData.map(item => ({
            name: item['@id'],
            children: Object.entries(item)
                .filter(([key]) => key !== '@id')
                .map(([key, value]) => ({
                    name: key,
                    children: value.map(v => ({ name: v['@id'] || v }))
                }))
        }))
    });
    root.x0 = h / 2;
    root.y0 = 0;
    update(root);
    function update(source) {
        const treeData = tree(root);
        const nodes = treeData.descendants();
        const links = treeData.links();
        nodes.forEach(d => { d.y = d.depth * maxLabelWidth; });
        const node = svg.selectAll('g.node')
            .data(nodes, d => d.id || (d.id = ++i));
        const nodeEnter = node.enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${source.y0},${source.x0})`)
            .on('click', (event, d) => {
                d.children = d.children ? null : d._children;
                update(d);
            });
        nodeEnter.append('circle')
            .attr('r', 1e-6)
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff');
        nodeEnter.append('text')
            .attr('x', d => d.children || d._children ? -13 : 13)
            .attr('dy', '.35em')
            .attr('text-anchor', d => d.children || d._children ? 'end' : 'start')
            .text(d => d.data.name)
            .style('fill-opacity', 1e-6);
        const nodeUpdate = node.merge(nodeEnter).transition()
            .duration(transitionDuration)
            .attr('transform', d => `translate(${d.y},${d.x})`);
        nodeUpdate.select('circle')
            .attr('r', 10)
            .style('fill', d => d._children ? 'lightsteelblue' : '#fff');
        nodeUpdate.select('text')
            .style('fill-opacity', 1);
        const nodeExit = node.exit().transition()
            .duration(transitionDuration)
            .attr('transform', d => `translate(${source.y},${source.x})`)
            .remove();
        nodeExit.select('circle')
            .attr('r', 1e-6);
        nodeExit.select('text')
            .style('fill-opacity', 1e-6);
        const link = svg.selectAll('path.link')
            .data(links, d => d.target.id);
        link.enter().insert('path', 'g')
            .attr('class', 'link')
            .attr('d', d => {
                const o = { x: source.x0, y: source.y0 };
                return diagonal({ source: o, target: o });
            });
        link.merge(link).transition()
            .duration(transitionDuration)
            .attr('d', diagonal);
        link.exit().transition()
            .duration(transitionDuration)
            .attr('d', d => {
                const o = { x: source.x, y: source.y };
                return diagonal({ source: o, target: o });
            })
            .remove();
        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }
    update(root);
    return body.html();
}
var root = {
    name: 'RDF Graph',
    children: jsonld.map(item => ({
        name: item['@id'],
        children: Object.entries(item)
            .filter(([key]) => key !== '@id')
            .map(([key, value]) => ({
                name: key,
                children: value.map(v => ({ name: v['@id'] || v }))
            }))
    }))
};
root.x0 = h / 2;
root.y0 = 0;
root.children.forEach(collapse);
function changeSVGWidth(newWidth) {
    if (w !== newWidth) {
        d3.select(selector + ' > svg').attr('width', newWidth);
    }
}
function jsonldTree(source) {
    var tree = {};
    if ('@id' in source) {
        tree.isIdNode = true;
        tree.name = source['@id'];
        if (tree.name.length > maxLabelWidth / 9) {
            tree.valueExtended = tree.name;
            tree.name = '...' + tree.valueExtended.slice(-Math.floor(maxLabelWidth / 9));
        }
    } else {
        tree.isIdNode = true;
        tree.isBlankNode = true;
        tree.name = '_' + Math.random().toString(10).slice(-7);
    }
    var children = [];
    Object.keys(source).forEach(function (key) {
        if (key === '@id' || key === '@context' || source[key] === null) return;
        var valueExtended, value;
        if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
            children.push({
                name: key,
                children: [jsonldTree(source[key])]
            });
        } else if (Array.isArray(source[key])) {
            children.push({
                name: key,
                children: source[key].map(function (item) {
                    if (typeof item === 'object') {
                        return jsonldTree(item);
                    } else {
                        return { name: item };
                    }
                })
            });
        } else {
            valueExtended = source[key];
            value = valueExtended;
            if (value.length > maxLabelWidth / 9) {
                value = value.slice(0, Math.floor(maxLabelWidth / 9)) + '...';
                children.push({
                    name: key,
                    value: value,
                    valueExtended: valueExtended
                });
            } else {
                children.push({
                    name: key,
                    value: value
                });
            }
        }
    });
    if (children.length) {
        tree.children = children;
    }
    return tree;
}
function update(source) {
    var nodes = tree.nodes(root).reverse();
    var links = tree.links(nodes);
    nodes.forEach(function (d) { d.y = d.depth * maxLabelWidth; });
    var node = svg.selectAll('g.node')
        .data(nodes, function (d) { return d.id || (d.id = ++i); });
    var nodeEnter = node.enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', function (d) { return 'translate(' + source.y0 + ',' + source.x0 + ')'; })
        .on('click', click);
    nodeEnter.append('circle')
        .attr('r', 0)
        .style('stroke-width', function (d) {
            return d.isIdNode ? '2px' : '1px';
        })
        .style('stroke', function (d) {
            return d.isIdNode ? '#F7CA18' : '#4ECDC4';
        })
        .style('fill', function (d) {
            if (d.isIdNode) {
                return d._children ? '#F5D76E' : 'white';
            } else {
                return d._children ? '#86E2D5' : 'white';
            }
        })
        .on('mouseover', function (d) { if (d.valueExtended) tip.show(d); })
        .on('mouseout', tip.hide);
    nodeEnter.append('text')
        .attr('x', function (d) {
            var spacing = computeRadius(d) + 5;
            return d.children || d._children ? -spacing : spacing;
        })
        .attr('dy', '4')
        .attr('text-anchor', function (d) { return d.children || d._children ? 'end' : 'start'; })
        .text(function (d) { return d.name + (d.value ? ': ' + d.value : ''); })
        .style('fill-opacity', 0);
    var maxSpan = Math.max.apply(Math, nodes.map(function (d) { return d.y + maxLabelWidth; }));
    if (maxSpan + maxLabelWidth + 20 > w) {
        changeSVGWidth(maxSpan + maxLabelWidth);
        d3.select(selector).node().scrollLeft = source.y0;
    }
    var nodeUpdate = node.transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('transform', function (d) { return 'translate(' + d.y + ',' + d.x + ')'; });
    nodeUpdate.select('circle')
        .attr('r', function (d) { return computeRadius(d); })
        .style('stroke-width', function (d) {
            return d.isIdNode ? '2px' : '1px';
        })
        .style('stroke', function (d) {
            return d.isIdNode ? '#F7CA18' : '#4ECDC4';
        })
        .style('fill', function (d) {
            if (d.isIdNode) {
                return d._children ? '#F5D76E' : 'white';
            } else {
                return d._children ? '#86E2D5' : 'white';
            }
        });
    nodeUpdate.select('text').style('fill-opacity', 1);
    var nodeExit = node.exit().transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('transform', function (d) { return 'translate(' + source.y + ',' + source.x + ')'; })
        .remove();
    nodeExit.select('circle').attr('r', 0);
    nodeExit.select('text').style('fill-opacity', 0);
    var link = svg.selectAll('path.link')
        .data(links, function (d) { return d.target.id; });
    link.enter().insert('path', 'g')
        .attr('class', 'link')
        .attr('d', function (d) {
            var o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
        });
    link.transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('d', diagonal);
    link.exit().transition()
        .duration(transitionDuration)
        .ease(transitionEase)
        .attr('d', function (d) {
            var o = { x: source.x, y: source.y };
            return diagonal({ source: o, target: o });
        })
        .remove();
    nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
    });
}
function computeRadius(d) {
    if (d.children || d._children) {
        return minRadius + (numEndNodes(d) / scalingFactor);
    } else {
        return minRadius;
    }
}
function numEndNodes(n) {
    var num = 0;
    if (n.children) {
        n.children.forEach(function (c) {
            num += numEndNodes(c);
        });
    } else if (n._children) {
        n._children.forEach(function (c) {
            num += numEndNodes(c);
        });
    } else {
        num++;
    }
    return num;
}
function click(d) {
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
    update(d);
    if (d.children) {
        d.children.forEach(function (child) {
            if (child.isBlankNode && child._children) {
                click(child);
            }
        });
    }
}
function collapse(d) {
    if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}
export async function visualizeTurtle(turtleFile, outputFile) {
    try {
        const stream = fromFile(turtleFile);
        const dataset = await rdf.dataset().import(stream);
        const jsonldData = datasetToJsonld(dataset);
        const svgContent = jsonldVis(jsonldData);
        await fs.writeFile(outputFile, svgContent);
        console.log(`Visualization saved to ${outputFile}`);
    } catch (error) {
        console.error('Error generating visualization:', error);
    }
}
visualizeTurtle('test-data/foaf-template.ttl', 'output.svg');
