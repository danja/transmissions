This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document.
Generated by Repomix on: 2025-02-09T15:03:30.532Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/_*/**, **/.env, **/old, docs, **/*repopack*, **/*repomix*, .git, node_modules, *.log, **/data/*, **/*copy.js, **/conversations.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------
User Provided Header:
-----------------------
Transmissions source code

================================================================
Directory Structure
================================================================
config/
  jasmine.json
  jsdoc.json
  terrapack.config.json
  webpack.config.js
src/
  api/
    cli/
      about.md
      run.js
    common/
      CommandUtils.js
    http/
      client/
        css/
          client.css
        js/
          client.js
          TransmissionsClient.js
        test-client.html
      server/
        WebRunner.js
      about.md
      openapi-spec.yaml
    about.md
  applications/
    example-application/
      about.md
      config.ttl
      transmissions.ttl
    about.md
  engine/
    ApplicationManager.js
    ModuleLoader.js
    ModuleLoaderFactory.js
    TransmissionBuilder.js
    WorkerPool.js
  model/
    Application.js
    Connector.js
    Transmission.js
  processors/
    base/
      AbstractProcessorFactory.js
      Processor.js
      ProcessorSettings.js
    example-group/
      ExampleProcessor.js
      ExampleProcessorsFactory.js
    flow/
      DeadEnd.js
      FlowProcessorsFactory.js
      ForEach.js
      Fork.js
      Halt.js
      NOP.js
      Ping.js
      Unfork.js
    fs/
      DirWalker.js
      FileCopy.js
      FilenameMapper.js
      FileReader.js
      FileRemove.js
      FileWriter.js
      FsProcessorsFactory.js
    github/
      GitHubList_no-pag.js
      GitHubList.js
      GitHubProcessorsFactory.js
    http/
      services/
        MetricsService.js
        ShutdownService.js
      HttpClient.js
      HttpProcessorsFactory.js
      HttpProxy.js
      HttpServer.js
      HttpServerWorker.js
    json/
      Blanker.js
      JSONProcessorsFactory.js
      JsonRestructurer.js
      JSONWalker.js
      Restructure.js
      ValueConcat.js
    markup/
      LinkFinder.js
      MarkdownToHTML.js
      MarkupProcessorsFactory.js
      MetadataExtractor.js
    mcp/
      McpClient.js
      McpProcessorsFactory.js
      McpServer.js
    postcraft/
      AtomFeedPrep.js
      EntryContentToPagePrep.js
      FrontPagePrep.js
      PostcraftDispatcher.js
      PostcraftPrep.js
      PostcraftProcessorsFactory.js
    protocols/
      HttpGet.js
      ProtocolsProcessorsFactory.js
    rdf/
      __ConfigMap.js
      ConfigMap.js
      DatasetReader.js
      RDFConfig.js
      RDFProcessorsFactory.js
    sparql/
      component-interaction.mermaid
      config.js
      custom-predicates.js
      handover-doc (1).md
      handover-doc.md
      handover-metadata.txt
      language-processing.mermaid
      message-processing-flow.mermaid
      SessionEnvironment.js
      SPARQLProcessorsFactory.js
      SPARQLSelect.js
      SPARQLUpdate.js
      system-architecture.mermaid
      validator.js
    staging/
      MarkdownFormatter.js
      StagingProcessorsFactory.js
      TurtleFormatter.js
    system/
      EnvLoader.js
      SystemProcessorsFactory.js
    terrapack/
      comment-stripper.js
      CommentStripper.js
      file-container.js
      FileContainer.js
      terrapack-factory.js
      TerrapackProcessorsFactory.js
    test/
      TestProcessorsFactory.js
      TestSettings.js
    text/
      LineReader.js
      StringFilter.js
      StringMerger.js
      StringReplace.js
      Templater.js
      TextProcessorsFactory.js
    unsafe/
      _RunCommand.spec.js
      ExampleProcessor.js
      RunCommand.js
      UnsafeProcessorsFactory.js
    util/
      CaptureAll.js
      SetMessage.js
      ShowConfig.js
      ShowMessage.js
      ShowSettings.js
      ShowTransmission.js
      Stash.js
      UtilProcessorsFactory.js
      WhiteboardToMessage.js
    xmpp/
      XmppClient.js
      XmppProcessorsFactory.js
    about.md
  simples/
    env-loader/
      about.md
      env-loader.js
    nop/
      nop.js
      simple-runner.js
    set-message/
      set-message.js
  utils/
    cache.js
    footpath.js
    GrapoiHelpers.js
    Logger.js
    MockApplicationManager.js
    ns.js
    RDFUtils.js
    StringUtils.js
    t2j.js
    test_runner.js
    text-utils.js
staging/
  schema-documentation.md
  template-cli.js
  template-generator.js
  template-tool-docs.md
  transmissions-prompt-template.md
  transmissions-template-schema.json
  transmissions-template-turtle.txt
  transmissions-testing-template.md
tests/
  examples/
    test-data-usage.js
  tests-support/
    helpers/
      file-test-helper.js
      reporter.js
      test-data-generator.js
    jasmine-browser.json
  about.md
types/
  grapoi.d.ts
  processor.d.ts
_README.md
_transmissions.config.json
.babelrc
.gitignore
jsconfig.json
LICENSE
package.json
README.md
trans

================================================================
Files
================================================================

================
File: config/jasmine.json
================
{
    "spec_dir": "tests",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [
        "helpers/reporter.js"
    ],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: config/jsdoc.json
================
{
    "source": {
        "include": [
            "../src"
        ],
        "exclude": [
            "../src/node_modules"
        ],
        "includePattern": ".+\\.js(doc|x)?$",
        "excludePattern": "(^|\\/|\\\\)_"
    },
    "opts": {
        "verbose": true,
        "recurse": true,
        "destination": "../docs/jsdoc"
    },
    "plugins": [
        "plugins/markdown"
    ]
}

================
File: config/terrapack.config.json
================
{
  "output": {
    "filePath": "./docs/terrapacks/terrapack-transmissions.json",
    "format": "text/plain",
    "removeComments": true,
    "summary": true
  },
  "filters": {
    "include": [
      "*.js",
      "*.jsx",
      "*.ts",
      "*.tsx",
      "*.md",
      "*.ttl",
      "*.json"
    ],
    "exclude": [
      "node_modules",
      ".git",
      "dist",
      "build",
      "coverage",
      "**/test/*",
      "**/*.test.*",
      "**/*.spec.*",
      "**/*copy*",
      "**/_*"
    ]
  }
}

================
File: config/webpack.config.js
================
// Generated using webpack-cli https://github.com/webpack/webpack-cli

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const WorkboxWebpackPlugin = require('workbox-webpack-plugin');

const isProduction = process.env.NODE_ENV == 'production';


const stylesHandler = MiniCssExtractPlugin.loader;



const config = {
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
    },
    devServer: {
        open: true,
        host: 'localhost',
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: 'index.html',
        }),

        new MiniCssExtractPlugin(),

        // Add your plugins here
        // Learn more about plugins from https://webpack.js.org/configuration/plugins/
    ],
    module: {
        rules: [
            {
                test: /\.(js|jsx)$/i,
                loader: 'babel-loader',
            },
            {
                test: /\.css$/i,
                use: [stylesHandler, 'css-loader', 'postcss-loader'],
            },
            {
                test: /\.(eot|svg|ttf|woff|woff2|png|jpg|gif)$/i,
                type: 'asset',
            },

            // Add your rules for custom modules here
            // Learn more about loaders from https://webpack.js.org/loaders/
        ],
    },
};

module.exports = () => {
    if (isProduction) {
        config.mode = 'production';
        
        
        config.plugins.push(new WorkboxWebpackPlugin.GenerateSW());
        
    } else {
        config.mode = 'development';
    }
    return config;
};

================
File: src/api/cli/about.md
================
# About : CLI

`src/api/cli/*`

The CLI entry point `./trans` calls `src/api/cli/run.js` which uses [yargs](https://yargs.js.org/) - _tee hee_, they say it best :

> Yargs be a node.js library fer hearties tryin' ter parse optstrings.

`src/api/cli/run.js` then calls `src/api/common/CommandUtils.js`. That does a little bit of path-splitting and simple logic, calling on `src/core/ApplicationManager.js` to get things going.

================
File: src/api/cli/run.js
================
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import CommandUtils from '../common/CommandUtils.js'
import WebRunner from '../http/server/WebRunner.js'
import chalk from 'chalk'
import { readFileSync } from 'fs'
import { dirname, join } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const packageJson = JSON.parse(readFileSync(join(__dirname, '../../../package.json')))
const buildInfo = process.env.BUILD_INFO || 'dev'
const version = `${packageJson.version} (${buildInfo})`

const banner = `
  _____
 |_   _| __ __ _ _ __  ___
   | || '__/ _\` | '_ \\/ __|
   | || | | (_| | | | \\__ \\
   |_||_|  \\__,_|_| |_|___/
             ${version.padStart(10).padEnd(20)}
         ${new Date().toISOString().split('T')[0]}
`

async function main() {
    console.log(chalk.cyan(banner))
    const commandUtils = new CommandUtils()

    const yargsInstance = yargs(hideBin(process.argv))
        .usage(chalk.cyan('Usage: ./trans [application][.subtask] [options] [target]\n  Run without arguments to list available applications.'))
        .option('verbose', {
            alias: 'v',
            describe: chalk.yellow('Enable verbose output'),
            type: 'boolean'
        })
        .option('silent', {
            alias: 's',
            describe: chalk.yellow('Suppress all output'),
            type: 'boolean'
        })
        .option('message', {
            alias: 'm',
            describe: chalk.yellow('Input message as JSON'),
            type: 'string',
            coerce: JSON.parse
        })
        .option('test', {
            alias: 't',
            describe: chalk.yellow('Run in test mode'),
            type: 'boolean',
            default: false
        })
        .option('web', {
            alias: 'w',
            describe: chalk.yellow('Start web interface'),
            type: 'boolean'
        })
        .option('port', {
            alias: 'p',
            describe: chalk.yellow('Port for web interface'),
            type: 'number',
            default: 4200
        })

    yargsInstance.command('$0 [application] [target]', chalk.green('runs the specified application\n'), (yargs) => {
        return yargs
            .positional('application', {
                describe: chalk.yellow('the application to run')
            })
            .positional('target', {
                describe: chalk.yellow('the target of the application')
            })
    }, async (argv) => {


        if (!argv.application) {
            console.log(chalk.cyan('Available applications:'))
            const apps = await commandUtils.listApplications()
            console.log(chalk.green(`\t${apps.join('\n\t')}\n`))

            yargsInstance.showHelp()
            return
        }
        const flags = { "web": argv.web, "port": argv.port, "verbose": argv.verbose, "silent": argv.silent, "test": argv.test }
        await commandUtils.begin(argv.application, argv.target, argv.message, flags)
    })

    await yargsInstance.argv
}

main().catch(console.error)

================
File: src/api/common/CommandUtils.js
================
// src/api/CommandUtils.js

import path from 'path'
import fs from 'fs/promises'
import logger from '../../utils/Logger.js'

import ApplicationManager from '../../engine/ApplicationManager.js'
import WebRunner from '../http/server/WebRunner.js'

class CommandUtils {

    #appManager

    constructor() {
        this.#appManager = new ApplicationManager()
    }

    async begin(application, target, message = {}, flags = {}) {

        var debugLevel = (flags.verbose || flags.test) ? "debug" : "info"
        if (!flags.verbose) logger.silent = flags.silent
        logger.setLogLevel(debugLevel)

        logger.debug('\nCommandUtils.begin')
        logger.debug('CommandUtils.begin, process.cwd() = ' + process.cwd())
        logger.debug('CommandUtils.begin, flags = ' + flags)
        logger.reveal(flags)
        logger.debug('CommandUtils.begin, application = ' + application)
        logger.debug('CommandUtils.begin, target = ' + target)
        logger.debug(`CommandUtils.begin, message = ${message}`)

        // dir containing manifest
        if (target && !target.startsWith('/')) {
            target = path.join(process.cwd(), target)
        }

        var { appName, appPath, subtask } = CommandUtils.splitName(application)
        // short name or path (TODO or URL)

        logger.debug(`\n
    after split :
    appName = ${appName}
    appPath = ${appPath}
    subtask = ${subtask}
    target = ${target}`)

        this.#appManager = await this.#appManager.initialize(appName, appPath, subtask, target, flags)

        if (flags.web) {
            const webRunner = new WebRunner(this.#appManager, flags.port)
            await webRunner.start()
            return
        }

        return await this.#appManager.start(message)
    }

    static splitName(fullPath) {
        logger.debug(`\nCommandUtils.splitName, fullPath  = ${fullPath}`)
        const parts = fullPath.split(path.sep)
        logger.debug(`\nCommandUtils.splitName, parts  = ${parts}`)
        var lastPart = parts[parts.length - 1]

        var task = false
        if (lastPart.includes('.')) {
            const split = lastPart.split('.')
            task = split[1]
            lastPart = split[0]
        }
        var appPath = parts.slice(0, parts.length - 1).join(path.sep)
        appPath = path.join(appPath, lastPart)
        //  logger.debug(`\nCommandUtils.splitName, parts.slice(0, parts.length - 1) = ${parts.slice(0, parts.length - 1)}`)

        // const appPath = parts.join(path.sep)
        logger.debug(`CommandUtils.splitName, appName:${lastPart}, appPath:${appPath}, task:${task},`)

        return { appName: lastPart, appPath: appPath, task: task }
    }

    async listApplications() {
        return await this.#appManager.listApplications()
    }

    // TODO appears to be unused
    static async parseOrLoadContext(contextArg) { // TODO rename context -> message
        logger.debug(`CommandUtils.parseOrLoadContext(), contextArg = ${contextArg}`)
        let message = {}
        try {
            message.payload = JSON.parse(contextArg)
        } catch (err) {
            logger.debug('*** Loading JSON from file...')
            const filePath = path.resolve(contextArg)
            const fileContent = await fs.readFile(filePath, 'utf8')
            message.payload = JSON.parse(fileContent)
        }
        return message
    }
}

export default CommandUtils

================
File: src/api/http/client/css/client.css
================
body {
    font-family: system-ui, -apple-system, sans-serif;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
    line-height: 1.5;
}

.container {
    display: grid;
    gap: 1rem;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

label {
    font-weight: 500;
}

input,
textarea {
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: monospace;
}

textarea {
    min-height: 120px;
    resize: vertical;
}

button {
    padding: 0.75rem 1rem;
    background: #0066cc;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

button:hover:not(:disabled) {
    background: #0052a3;
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

pre {
    background: #f5f5f5;
    padding: 1rem;
    overflow-x: auto;
    border-radius: 4px;
    margin: 0;
    font-size: 14px;
}

.status {
    padding: 1rem;
    margin: 0;
    border-radius: 4px;
    font-size: 14px;
}

.status.error {
    background: #fff5f5;
    color: #c53030;
    border: 1px solid #feb2b2;
}

.status.success {
    background: #f0fff4;
    color: #276749;
    border: 1px solid #9ae6b4;
}

.status.info {
    background: #ebf8ff;
    color: #2c5282;
    border: 1px solid #90cdf4;
}

.metrics {
    display: grid;
    grid-template-columns

================
File: src/api/http/client/js/client.js
================
import TransmissionsClient from './TransmissionsClient.js'

class TestClientUI {
    constructor() {
        this.elements = {
            baseUrl: document.getElementById('baseUrl'),
            application: document.getElementById('application'),
            message: document.getElementById('message'),
            sendButton: document.getElementById('sendButton'),
            status: document.getElementById('status'),
            response: document.getElementById('response'),
            metrics: document.getElementById('metrics')
        }

        // Ensure baseUrl has a value
        if (!this.elements.baseUrl.value) {
            this.elements.baseUrl.value = 'http://localhost:4200/api'
        }

        this.initialize()
        this.bindEvents()
    }

    initialize() {
        try {
            this.client = new TransmissionsClient(this.elements.baseUrl.value)
            this.updateStatus(true)
            this.startMetricsUpdate()
        } catch (err) {
            console.error('Initialization error:', err)
            this.handleError(err)
        }
    }

    bindEvents() {
        this.elements.sendButton.addEventListener('click', () => this.sendRequest())
        this.elements.baseUrl.addEventListener('change', () => {
            try {
                this.client.setBaseUrl(this.elements.baseUrl.value)
                this.updateStatus(true)
            } catch (err) {
                this.handleError(err)
            }
        })
    }

    updateStatus(isOnline) {
        const { status: statusEl, sendButton } = this.elements
        if (isOnline) {
            statusEl.className = 'status success'
            statusEl.textContent = 'Server online'
            sendButton.disabled = false
        } else {
            statusEl.className = 'status error'
            statusEl.textContent = 'Server offline'
            sendButton.disabled = true
        }
    }

    handleError(error) {
        const { status: statusEl } = this.elements
        statusEl.className = 'status error'
        statusEl.textContent = `Error: ${error.message}`
        console.error('Client error:', error)
    }

    startMetricsUpdate() {
        setInterval(() => {
            if (this.client) {
                const metrics = this.client.getMetrics()
                this.updateMetricsDisplay(metrics)
            }
        }, 1000)
    }

    updateMetricsDisplay(metrics) {
        if (!metrics) return

        this.elements.metrics.innerHTML = `
            <div class="metric-card">
                <div>Requests</div>
                <div class="metric-value">${metrics.requests}</div>
            </div>
            <div class="metric-card">
                <div>Errors</div>
                <div class="metric-value">${metrics.errors}</div>
            </div>
            <div class="metric-card">
                <div>Uptime</div>
                <div class="metric-value">${metrics.uptime}s</div>
            </div>
        `
    }

    async sendRequest() {
        const { application, message, response: responseEl, status: statusEl, sendButton } = this.elements

        try {
            let messageData
            try {
                messageData = JSON.parse(message.value)
            } catch (err) {
                throw new Error('Invalid JSON in message field')
            }

            statusEl.className = 'status info'
            statusEl.textContent = 'Sending request...'
            sendButton.disabled = true

            const result = await this.client.runApplication(application.value, messageData)

            if (result.success) {
                statusEl.className = 'status success'
                statusEl.textContent = 'Request successful'
                responseEl.textContent = JSON.stringify(result.data, null, 2)
            } else {
                throw new Error(result.error || 'Request failed')
            }
        } catch (err) {
            statusEl.className = 'status error'
            statusEl.textContent = `Error: ${err.message}`
            responseEl.textContent = ''
            console.error('Request error:', err)
        } finally {
            sendButton.disabled = false
        }
    }
}

// Initialize the UI when the page loads
const ui = new TestClientUI()

// Handle global errors
window.addEventListener('unhandledrejection', event => {
    console.error('Unhandled promise rejection:', event.reason)
    if (ui) {
        ui.handleError({
            message: 'Unhandled error: ' + event.reason.message
        })
    }
})

================
File: src/api/http/client/js/TransmissionsClient.js
================
class TransmissionsClient {
    constructor(baseUrl) {
        if (!baseUrl) {
            throw new Error('Base URL is required')
        }
        this.baseUrl = baseUrl
        this.metrics = {
            requests: 0,
            errors: 0,
            startTime: Date.now()
        }
    }

    async runApplication(application, message = {}) {
        if (!application) {
            throw new Error('Application name is required')
        }

        try {
            this.metrics.requests++
            console.log('Sending request:', {
                url: `${this.baseUrl}/${application}`,
                body: message
            })

            const response = await fetch(`${this.baseUrl}/${application}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(message)
            })

            if (!response.ok) {
                this.metrics.errors++
                const error = await response.json()
                throw new Error(error.message || 'Request failed')
            }

            return await response.json()
        } catch (err) {
            this.metrics.errors++
            throw err
        }
    }

    getMetrics() {
        return {
            requests: this.metrics.requests,
            errors: this.metrics.errors,
            uptime: Math.floor((Date.now() - this.metrics.startTime) / 1000)
        }
    }

    setBaseUrl(url) {
        if (!url) {
            throw new Error('Base URL is required')
        }
        this.baseUrl = url
    }
}

export default TransmissionsClient

================
File: src/api/http/client/test-client.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Transmissions API Test Client</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="css/client.css">
</head>

<body>
    <h1>Transmissions API Test Client</h1>

    <div class="container">
        <div class="form-group">
            <label for="baseUrl">Base URL:</label>
            <input type="url" id="baseUrl" />
        </div>

        <div class="form-group">
            <label for="application">Application:</label>
            <input type="text" id="application" value="echo" />
        </div>

        <div class="form-group">
            <label for="message">Message (JSON):</label>
            <textarea id="message">{
    "message": "Hello from test client"
}</textarea>
        </div>

        <button id="sendButton">Send Request</button>

        <div id="status" class="status info">Initializing client...</div>

        <div class="metrics" id="metrics">
        </div>

        <div class="form-group">
            <label>Response:</label>
            <pre id="response"></pre>
        </div>
    </div>

    <script type="module" src="js/client.js"></script>
</body>

</html>

================
File: src/api/http/server/WebRunner.js
================
import express from 'express'
import cors from 'cors'
import path from 'path'
import ApplicationManager from '../../../engine/ApplicationManager.js'
import logger from '../../../utils/Logger.js'

class WebRunner {
    constructor(appManager, port = 4000, basePath = '/api') {
        this.appManager = appManager
        this.app = express()
        this.port = port
        this.basePath = basePath
        this.setupMiddleware()
        this.setupRoutes()
        this.requestCount = 0
    }

    setupMiddleware() {
        // CORS setup
        const corsOptions = {
            origin: (origin, callback) => {
                if (!origin || origin.startsWith('http://localhost')) {
                    callback(null, true)
                } else {
                    callback(new Error('Not allowed by CORS'))
                }
            },
            methods: ['GET', 'POST', 'OPTIONS'],
            allowedHeaders: ['Content-Type'],
            credentials: true
        }
        this.app.use(cors(corsOptions))

        // JSON body parsing
        this.app.use(express.json({
            limit: '10mb',
            strict: false,
            verify: (req, res, buf) => {
                try {
                    JSON.parse(buf)
                } catch (e) {
                    logger.error('Invalid JSON:', e)
                }
            }
        }))
    }

    setupRoutes() {
        const router = express.Router()

        router.post('/:application', async (req, res) => {
            const requestId = Math.random().toString(36).substring(7)
            const { application } = req.params
            const message = req.body || {}

            logger.info(`[${requestId}] Running application: ${application}`)
            logger.debug(`[${requestId}] Message payload:`, message)

            try {
                if (!this.appManager) {
                    throw new Error('Application manager not initialized')
                }
                logger.debug(`[${requestId}] Initializing application ${application}`)
                await this.appManager.initialize(application)
                message.requestId = requestId
                logger.debug(`[${requestId}] Starting application with message:`, message)
                const result = await this.appManager.start(message)
                if (!result) {
                    throw new Error('Application returned no result')
                }
                logger.debug(`[${requestId}] Application result:`, result)
                const response = {
                    success: true,
                    requestId: requestId,

                    data: result
                    /*result.whiteboard ?
                        result.whiteboard[result.whiteboard.length - 1] :
                        { message: "Echo response" }
                */
                }
                logger.info(`[${requestId}] Application ${application} completed successfully`)
                res.json(response)

            } catch (error) {
                const errorResponse = {
                    success: false,
                    requestId: requestId,
                    error: error.message,
                    details: error.stack,
                    application: application
                }
                logger.log(`error = `)
                logger.reveal(error)
                logger.log(`errorResponse = `)
                logger.reveal(errorResponse)
                logger.error(`[${requestId}] Error running application ${application}:`, error)
                logger.error(`[${requestId}] Stack:`, error.stack)
                logger.debug(`[${requestId}] Context:`, {
                    application,
                    message,
                    headers: req.headers
                })

                res.status(500).json(errorResponse)
            }
        })

        this.app.use(this.basePath, router)
    }

    async start() {
        return new Promise((resolve, reject) => {
            try {
                this.server = this.app.listen(this.port, () => {
                    const endpoint = `http://localhost:${this.port}${this.basePath}`
                    const msg = `Transmissions API server running at ${endpoint}`
                    logger.info('\n' + '='.repeat(msg.length))
                    logger.info(msg)
                    logger.info('='.repeat(msg.length) + '\n')
                    resolve()
                })

                this.server.on('error', (error) => {
                    logger.error('Server error:', error)
                    reject(error)
                })
            } catch (error) {
                logger.error('Failed to start server:', error)
                reject(error)
            }
        })
    }

    async stop() {
        return new Promise((resolve, reject) => {
            if (this.server) {
                logger.info('Shutting down server...')
                this.server.close((err) => {
                    if (err) {
                        logger.error('Error shutting down server:', err)
                        reject(err)
                    } else {
                        logger.info('Server shutdown complete')
                        resolve()
                    }
                })
            } else {
                resolve()
            }
        })
    }
}

export default WebRunner

================
File: src/api/http/about.md
================
```sh
cd ~/github-danny/transmissions/
./trans --verbose --web --port 4200 echo

./trans -v -w -p 4200 echo

./trans -v -w -t -p 4200 echo
```

compare with :

```sh
./trans  -v echo
```

#:todo move echo and all the test\_ to applications/system

================
File: src/api/http/openapi-spec.yaml
================
openapi: 3.0.0
info:
  title: Transmissions API
  version: '1.0.0'
  description: API for running Transmissions applications

servers:
  - url: http://localhost:4200/api
    description: Local development server

paths:
  /:
    get:
      summary: Get server status
      responses:
        '200':
          description: Server status information
          content:
            application/json:
              schema:
                type: object
                properties:
                  service:
                    type: string
                    example: 'Transmissions API'
                  version:
                    type: string
                    example: '1.0.0'
                  status:
                    type: string
                    example: 'running'

  /applications:
    get:
      summary: List available applications
      responses:
        '200':
          description: List of available applications
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  applications:
                    type: array
                    items:
                      type: string
                example:
                  success: true
                  applications: ['system/echo', 'test/example']
        '500':
          $ref: '#/components/responses/Error'

  /{application}:
    post:
      summary: Run a Transmissions application
      parameters:
        - name: application
          in: path
          required: true
          schema:
            type: string
          description: Application identifier
          example: 'system/echo'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              description: Application-specific message payload
      responses:
        '200':
          description: Successful application execution
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    type: object
                    description: Application-specific response data
                example:
                  success: true
                  data:
                    message: "Echo response"
        '400':
          description: Invalid request
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: false
                  error:
                    type: string
                    example: 'Invalid JSON payload'
        '500':
          $ref: '#/components/responses/Error'

components:
  responses:
    Error:
      description: Server error
      content:
        application/json:
          schema:
            type: object
            properties:
              success:
                type: boolean
                example: false
              error:
                type: string
                example: 'Internal server error'

================
File: src/api/about.md
================
# transmissions/src/api/

Interfaces for running transmissions.

================
File: src/applications/example-application/about.md
================
`src/applications/example-application/about.md`

# Example Application `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans example-application
```

## Description

---

================
File: src/applications/example-application/config.ttl
================
# src/applications/example-application/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:exampleSettings1 a :ConfigSet ;
    :me "exampleSettings1" ;
    :common "common from 1"  ;
    :something1 "something1 from config" .

:exampleSettings2 a :ConfigSet ;
    :me "exampleSettings2" ;
    :common "common from 2" ;
    :something2 "something2 from config" ;
    :added " added from exampleSettings2" .

================
File: src/applications/example-application/transmissions.ttl
================
# src/applications/example-application/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:example a :Transmission ;
    :pipe (:p10 :N :p20 :p30) .

:p10 a :ExampleProcessor ;
     :settings :exampleSettings1 .

:p20 a :ExampleProcessor ;
     :settings :exampleSettings2 .

:p30 a :ShowMessage .

================
File: src/applications/about.md
================
# About src/applications

- example-application
- pending : hold here until test criteria fulfilled

================
File: src/engine/ApplicationManager.js
================
// ApplicationManager.js
import rdf from 'rdf-ext'
import ns from '../utils/ns.js'
import path from 'path'
import fs from 'fs/promises'
import _ from 'lodash'
import logger from '../utils/Logger.js'
import MockApplicationManager from '../utils/MockApplicationManager.js'
import TransmissionBuilder from './TransmissionBuilder.js'
import ModuleLoaderFactory from './ModuleLoaderFactory.js'
import Application from '../model/Application.js'

class ApplicationManager {
    constructor() {
        this.app = new Application()
        this.moduleLoader = null
        this.dataset = rdf.dataset()
    }

    async initialize(appName, appPath, subtask, target, flags) {
        logger.debug(`ApplicationManager.initialize, appName=${appName}, appPath=${appPath}, subtask=${subtask}, target=${target}`)

        if (flags && flags.test) {
            const mock = new MockApplicationManager()
            await mock.initialize(appName, appPath, subtask, target, flags)
            return mock
        }

        await this.app.initialize(appName, appPath, subtask, target)
        this.moduleLoader = ModuleLoaderFactory.createApplicationLoader(this.app.getModulePath())

        const appNode = rdf.namedNode(`http://purl.org/stuff/transmissions/${appName}`)
        const sessionNode = rdf.blankNode()

        this.dataset.add(rdf.quad(
            appNode,
            ns.rdf.type,
            ns.trn.Application
        ))

        this.dataset.add(rdf.quad(
            sessionNode,
            ns.rdf.type,
            ns.trn.ApplicationSession
        ))

        this.dataset.add(rdf.quad(
            sessionNode,
            ns.trn.application,
            appNode
        ))

        // Add to config before building transmissions
        this.app.dataset = this.dataset
        this.app.sessionNode = sessionNode

        return this
    }

    async buildTransmissions(transmissionConfigFile, processorsConfigFile, moduleLoader, app) {
        logger.debug(`\nApplicationManager.build ****************************************`)

        const builder = new TransmissionBuilder(this.moduleLoader, this.app)
        const transmissionConfig = await TransmissionBuilder.readDataset(this.app.getTransmissionsPath())
        const processorsConfig = await TransmissionBuilder.readDataset(this.app.getConfigPath())

        // Merge with app dataset
        /*
            for (const quad of app.dataset) {
              transmissionConfig.add(quad)
              processorsConfig.add(quad)
            }
        */
        return await builder.buildTransmissions(transmissionConfig, processorsConfig)
    }

    async start(message = {}) {
        logger.debug(`\n||| ApplicationManager.start`)
        logger.debug(`
            transmissionsFile=${this.app.getTransmissionsPath()}
            configFile=${this.app.getConfigPath()}
            subtask=${this.app.subtask}`)

        const transmissions = await this.buildTransmissions()

        logger.debug(`Transmissions has length ${transmissions.length}`)
        // Get application context
        const contextMessage = this.app.toMessage()

        // Modify the input message in place
        _.merge(message, contextMessage)

        logger.trace('Message with merged context:', message)

        /*
        for (const transmission of transmissions) {
            if (!this.app.subtask || this.app.subtask === transmission.label) {
                await transmission.process(message)
            }
        }
*/
        //       message.app = this.app
        message.sessionNode = this.app.sessionNode

        for (const transmission of transmissions) {
            logger.debug(`transmission = \n${transmission}`)
            if (!this.app.subtask || this.app.subtask === transmission.label) {
                //     await transmission.process(message)
                message = await transmission.process(message)
            }
        }
        message.success = true
        logger.reveal(message)
        return message //{ success: true }
    }

    async listApplications() {
        try {
            const entries = await fs.readdir(this.app.appsDir, { withFileTypes: true })
            const subdirChecks = entries
                .filter(dirent => dirent.isDirectory())
                .map(async (dirent) => {
                    const subdirPath = path.join(this.app.appsDir, dirent.name)
                    const files = await fs.readdir(subdirPath)
                    return files.includes('about.md') ? dirent.name : null
                })

            const validApps = (await Promise.all(subdirChecks)).filter(Boolean)
            return validApps
        } catch (err) {
            logger.error('Error listing applications:', err)
            return []
        }
    }
}

export default ApplicationManager

================
File: src/engine/ModuleLoader.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import logger from '../utils/Logger.js'

class ModuleLoader {
    constructor(classpath) {
        if (!Array.isArray(classpath)) {
            throw new Error('Classpath must be an array of paths')
        }
        this.classpath = classpath.map(p => path.normalize(p))
        this.moduleCache = new Map()
        logger.debug(`ModuleLoader initialized with paths:\n${this.classpath.join('\n')}`)
    }

    async loadModule(moduleName) {
        logger.debug(`ModuleLoader.loadModule attempting to load: ${moduleName}`)

        if (this.moduleCache.has(moduleName)) {
            logger.debug(`Retrieved ${moduleName} from cache`)
            return this.moduleCache.get(moduleName)
        }

        const errors = []
        for (const basePath of this.classpath) {
            try {
                const fullPath = path.join(basePath, `${moduleName}.js`)
                logger.debug(`Trying path: ${fullPath}`)
                const module = await import(fullPath)
                this.moduleCache.set(moduleName, module)
                logger.debug(`Successfully loaded ${moduleName} from ${fullPath}`)
                return module
            } catch (error) {
                errors.push(`${basePath}: ${error.message}`)
                continue
            }
        }

        const errorMsg = `Failed to load module '${moduleName}' from paths:\n${errors.join('\n')}`
        throw new Error(errorMsg)
    }

    clearCache() {
        this.moduleCache.clear()
    }

    addPath(newPath) {
        if (typeof newPath !== 'string') {
            throw new TypeError('Path must be a string')
        }
        const normalizedPath = path.normalize(newPath)
        if (!this.classpath.includes(normalizedPath)) {
            this.classpath.push(normalizedPath)
            logger.debug(`Added path to classpath: ${normalizedPath}`)
        }
    }
}

export default ModuleLoader

================
File: src/engine/ModuleLoaderFactory.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import logger from '../utils/Logger.js'
import ModuleLoader from './ModuleLoader.js'

class ModuleLoaderFactory {
    static instance = null;

    static createModuleLoader(classpath) {
        logger.debug(`\nModuleLoaderFactory.createModuleLoader, classpath =\n ${classpath}`)
        const __filename = fileURLToPath(import.meta.url)
        const __dirname = path.dirname(__filename)

        if (!ModuleLoaderFactory.instance) {
            ModuleLoaderFactory.instance = new ModuleLoader(classpath)
        }

        return ModuleLoaderFactory.instance
    }

    static createApplicationLoader(appPath) {
        logger.debug(`\nModuleLoaderFactory.createApplicationLoader called with ${appPath}`)
        if (!appPath) {
            throw new Error('Application path is required')
        }

        // TODO revisit
        const appProcessorsPath = appPath
        // const appProcessorsPath = path.join(appPath, 'processors')

        const corePath = path.resolve(process.cwd(), 'src/processors')

        logger.debug(`ModuleLoaderFactory creating loader with paths:
      App: ${appProcessorsPath}
      Core: ${corePath}`)

        return this.createModuleLoader([appProcessorsPath, corePath])
    }

    static clearInstance() {
        ModuleLoaderFactory.instance = null
    }
}
export default ModuleLoaderFactory

================
File: src/engine/TransmissionBuilder.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import { fromFile, toFile } from 'rdf-utils-fs'

import ns from '../utils/ns.js'
import GrapoiHelpers from '../utils/GrapoiHelpers.js'
import logger from '../utils/Logger.js'

import AbstractProcessorFactory from "../processors/base/AbstractProcessorFactory.js"
import Transmission from '../model/Transmission.js'


class TransmissionBuilder {
  constructor(moduleLoader, app) { // Add app param
    this.moduleLoader = moduleLoader
    this.app = app
    this.transmissionCache = new Map()
    this.MAX_NESTING_DEPTH = 10
    this.currentDepth = 0
  }

  async buildTransmissions(transmissionConfig, processorsConfig) {
    logger.debug(`\nTransmissionBuilder.buildTransmissions`)
    logger.trace(`transmissionConfig = \n${transmissionConfig}`)
    const poi = grapoi({ dataset: transmissionConfig })
    const transmissions = []

    for (const q of poi.out(ns.rdf.type).quads()) {

      // logger.reveal(q)
      if (q.object.equals(ns.trn.Transmission)) {
        const transmissionID = q.subject
        logger.debug(`\ntransmissionID = ${transmissionID}`)

        const transmission = await this.constructTransmission(
          transmissionConfig,
          transmissionID,
          processorsConfig
        )
        transmissions.push(transmission)

        //        transmissions.push(await this.constructTransmission(transmissionConfig, transmissionID, processorsConfig)) // was await
      }
    }
    return transmissions
  }

  async constructTransmission(transmissionConfig, transmissionID, processorsConfig) {
    logger.debug(`\nTransmissionBuilder.constructTransmission`)

    if (++this.currentDepth > this.MAX_NESTING_DEPTH) {
      throw new Error(`Maximum transmission nesting depth of ${this.MAX_NESTING_DEPTH} exceeded`)
    }

    if (this.transmissionCache.has(transmissionID.value)) {
      return this.transmissionCache.get(transmissionID.value)
    }

    const transmission = new Transmission()
    transmission.id = transmissionID.value
    transmission.app = this.app

    processorsConfig.whiteboard = {}

    transmission.label = ''

    const transPoi = grapoi({ dataset: transmissionConfig, term: transmissionID })
    // grapoi probably has a built-in for all this
    const pipenodes = GrapoiHelpers.listToArray(transmissionConfig, transmissionID, ns.trn.pipe)

    // TODO has grapoi got a first/single property method?
    for (const quad of transPoi.out(ns.rdfs.label).quads()) {
      transmission.label = quad.object.value
    }
    logger.log('\n+ ***** Construct Transmission : ' + transmission.label + ' <' + transmission.id + '>')

    let previousName = "nothing"

    await this.createNodes(transmission, pipenodes, transmissionConfig, processorsConfig)
    this.connectNodes(transmission, pipenodes)

    this.currentDepth-- // ??
    return transmission
  }

  async createNodes(transmission, pipenodes, transmissionConfig, processorsConfig) {
    //  for (let i = 0; i < pipenodes.length; i++) {
    //   let node = pipenodes[i]

    for (const node of pipenodes) {

      let processorName = node.value

      if (!transmission.get(processorName)) {

        const np = rdf.grapoi({ dataset: transmissionConfig, term: node })

        const processorType = np.out(ns.rdf.type).term

        // Check if node is a nested transmission
        if (processorType && this.isTransmissionReference(processorType)) {
          const nestedTransmission = await this.constructTransmission(
            transmissionConfig,
            processorType,
            processorsConfig
          )
          transmission.register(node.value, nestedTransmission)
        } else {
          // Regular processor handling
          const processor = await this.createProcessor(processorType, processorsConfig)
          processor.id = node.value
          processor.type = processorType
          processor.transmission = transmission
          transmission.register(node.value, processor)
        }


        /*
      let processorConfig = np.out(ns.trn.settings).term

      try {
        let name = ns.getShortname(processorName)
        let type = ns.getShortname(processorType.value)

        logger.log("| Create processor :" + name + " of type :" + type)
        let processor = await this.createProcessor(processorType, processorsConfig)

        processor.id = processorName
        processor.type = processorType
        processor.transmissionNode = node
        processor.transmission = transmission
        processor.settingsNode = processorConfig

        transmission.register(processorName, processor)

      } catch (err) {
        logger.error('-> Can\'t resolve ' + processorName + ' (check transmission.ttl for typos!)\n')
        logger.error(err)
      }
        */
      }
    }
  }

  isTransmissionReference(processorType) {
    const processorPoi = grapoi({ dataset: this.app.dataset, term: processorType })
    return processorPoi.out(ns.rdf.type).terms.some(t => t.equals(ns.trn.Transmission))
  }

  getPipeNodes(transmissionConfig, transmissionID) {
    const transPoi = grapoi({ dataset: transmissionConfig, term: transmissionID })
    return transPoi.out(ns.trn.pipe).terms
  }



  async connectNodes(transmission, pipenodes) {
    for (let i = 0; i < pipenodes.length - 1; i++) {
      let leftNode = pipenodes[i]
      let leftProcessorName = leftNode.value
      let rightNode = pipenodes[i + 1]
      let rightProcessorName = rightNode.value
      logger.log("  > Connect #" + i + " [" + ns.getShortname(leftProcessorName) + "] => [" + ns.getShortname(rightProcessorName) + "]")
      transmission.connect(leftProcessorName, rightProcessorName)
    }
  }

  async createProcessor(type, config) {
    logger.trace(`\n\nTransmissionBuilder.createProcessor, config = ${config}`)

    const coreProcessor = AbstractProcessorFactory.createProcessor(type, config)
    if (coreProcessor) {
      return coreProcessor
    }

    logger.debug(`TransmissionBuilder, core processor not found for ${type.value}. Trying remote module loader...`)

    try {
      const shortName = type.value.split('/').pop()
      logger.debug(`TransmissionBuilder, loading module: ${shortName}`)
      logger.log(this.moduleLoader)
      const ProcessorClass = await this.moduleLoader.loadModule(shortName)

      logger.debug(`Module loaded successfully: ${shortName}`)
      return new ProcessorClass.default(config)
    } catch (error) {
      logger.error(`TransmissionBuilder.createProcessor, failed to load ${type.value} : ${error.message}`)
      // logger.debug(`TransmissionBuilder.createProcessor, failed to load ${type.value} : ${error.message}`)
      process.exit(1)
    }
  }

  // file utils
  static async readDataset(filename) {
    const stream = fromFile(filename)
    const dataset = await rdf.dataset().import(stream)
    return dataset
  }

  static async writeDataset(dataset, filename) {
    await toFile(dataset.toStream(), filename)
  }


}
export default TransmissionBuilder

================
File: src/engine/WorkerPool.js
================
import { Worker } from 'worker_threads'

class WorkerPool {
    constructor(module, size) {
        this.workers = [];
        this.queue = [];
        for (let i = 0; i < size; i++) {
            const worker = new Worker(module);
            worker.on('message', () => {
                // Handle completion, possibly dispatching next message
                this.markWorkerIdle(worker);
            });
            this.workers.push({ worker, busy: false });
        }
    }

    enqueueMessage(message) {
        this.queue.push(message);
        this.dispatch();
    }

    dispatch() {
        const idleWorkerWrapper = this.workers.find(wrapper => !wrapper.busy);
        if (idleWorkerWrapper && this.queue.length) {
            const message = this.queue.shift();
            idleWorkerWrapper.busy = true;
            idleWorkerWrapper.worker.postMessage(message);
        }
    }

    markWorkerIdle(workerWrapper) {
        workerWrapper.busy = false;
        this.dispatch(); // Check if there's more work to do
    }
}

================
File: src/model/Application.js
================
import path from 'path'
import { fromFile } from 'rdf-utils-fs'
import rdf from 'rdf-ext'
import logger from '../utils/Logger.js'

class Application {
    constructor(options = {}) {
        // Core paths
        this.appsDir = 'src/applications'
        this.transmissionFilename = 'transmissions.ttl'
        this.configFilename = 'config.ttl'
        this.moduleSubDir = 'processors'
        this.dataSubDir = 'data'
        this.manifestFilename = 'manifest.ttl'

        // Application identity
        this.appName = options.appName || null
        this.appPath = options.appPath || null
        this.subtask = options.subtask || null

        // Runtime paths
        this.rootDir = options.rootDir || null
        this.dataDir = options.dataDir || null
        this.targetPath = options.targetPath || null

        // RDF dataset from manifest
        this.dataset = options.dataset || null
    }

    async initialize(appName, appPath, subtask, target, flags = {}) {
        logger.debug(`Application.initialize,
            appName : ${appName}
            appPath : ${appPath}
            subtask : ${subtask}
            target : ${target}`)
        this.appName = appName
        this.appPath = this.resolveApplicationPath(appName)
        // this.appPath = appPath
        //this.resolveApplicationPath(appName)
        this.subtask = subtask
        this.targetPath = target

        if (target) {
            this.manifestFilename = path.join(target, this.manifestFilename)
            await this.loadManifest()
        }

        return this
    }

    //////////////////// ?
    resolveApplicationPath(appName) {
        if (!appName) {
            throw new Error('Application name is required')
        }

        if (appName.startsWith('/')) {
            return appName
        }

        if (appName.startsWith('..')) {
            return path.resolve(process.cwd(), appName)
        }

        return path.join(process.cwd(), this.appsDir, appName)
    }

    async loadManifest() {
        try {
            logger.debug(`Application.loadManifest, loading: ${this.manifestFilename}`)
            const stream = fromFile(this.manifestFilename)
            this.dataset = await rdf.dataset().import(stream)
            return this.dataset
        } catch (err) {
            logger.debug(`Application.loadManifest, ${this.manifestFilename} not found, creating empty dataset`)
            this.dataset = rdf.dataset()
            return this.dataset
        }
    }

    getTransmissionsPath() {
        return path.join(this.appPath, this.transmissionFilename)
    }

    getConfigPath() {
        return path.join(this.appPath, this.configFilename)
    }

    getModulePath() {
        logger.debug(`Application.getModulePath,\nthis.appPath : ${this.appPath}\nthis.moduleSubDir : ${this.moduleSubDir}`)
        return path.join(this.appPath, this.moduleSubDir)
    }

    resolveDataDir() {
        if (!this.dataDir) {
            this.dataDir = path.join(this.appPath, this.dataSubDir)
        }
        return this.dataDir
    }

    toMessage() {
        return {
            appName: this.appName,
            appPath: this.appPath,
            subtask: this.subtask,
            rootDir: this.rootDir || this.appPath,
            dataDir: this.resolveDataDir(),
            targetPath: this.targetPath,
            dataset: this.dataset
        }
    }
}

export default Application

================
File: src/model/Connector.js
================
import ns from '../utils/ns.js'
import { EventEmitter } from 'events'
import logger from '../utils/Logger.js'
import Transmission from './Transmission.js'

class Connector extends EventEmitter {

    constructor(fromName, toName) {
        super()
        this.fromName = fromName
        this.toName = toName
    }

    connect(processors) {
        logger.trace(`Connector.connect this.fromName = ${this.fromName} this.toName =  ${this.toName}`)
        const fromProcessor = processors[this.fromName]
        const toProcessor = processors[this.toName]
        if (fromProcessor instanceof Transmission) {
            // Connect last node of nested transmission
            const lastNode = fromProcessor.getLastNode()
            lastNode.on('message', async (message) => {
                await toProcessor.receive(message)
            })
        } else if (toProcessor instanceof Transmission) {
            // Connect to first node of nested transmission
            fromProcessor.on('message', async (message) => {
                const firstNode = toProcessor.getFirstNode()
                await firstNode.receive(message)
            })
        } else {
            if (!fromProcessor) {
                throw new Error(`\nMissing processor : ${this.fromName}, going to ${this.toName} \n(check for typos in transmissions.ttl)\n`)
            }

            fromProcessor.on('message', async (message) => {
                var tags = fromProcessor.message?.tags ? ` [${fromProcessor.message.tags}] ` : ''
                toProcessor.tags = tags
                logger.log(`|-> ${tags}-> ${ns.shortName(toProcessor.id)} a ${toProcessor.constructor.name}`)
                await toProcessor.receive(message)
            })
        }

    }


}

export default Connector

================
File: src/model/Transmission.js
================
import logger from '../utils/Logger.js'
import Connector from './Connector.js'
import ns from '../utils/ns.js'

class Transmission {
  constructor() {
    this.processors = {}
    this.connectors = []
    this.parent = null
    this.children = new Set()
    this.path = []
  }

  async process(message) {
    logger.debug(`\nTransmission.process`)
    logger.log(`\n+ Run Transmission : ${this.label} <${this.id}>`)

    try {
      const processorName = this.connectors[0]?.fromName || Object.keys(this.processors)[0]
      let processor = this.get(processorName)
      if (processor) {
        logger.log(`|-> ${ns.shortName(processorName)} a ${processor.constructor.name}`)
        await processor.receive(message)
      } else {
        throw new Error("No valid processor found to execute")
      }
    } catch (error) {
      error.transmissionStack = error.transmissionStack || []
      error.transmissionStack.push(this.id)
      throw error
    }
    return message
  }

  register(processorName, instance) {
    let processor = this.get(processorName)
    if (processor instanceof Transmission) {
      processor.parent = this
      processor.path = [...this.path, processorName]
      this.children.add(processor)
    }
    this.processors[processorName] = instance
  }

  get(processorName) {
    return this.processors[processorName]
  }

  connect(fromProcessorName, toProcessorName) {
    logger.trace(`Transmission.connect from ${fromProcessorName} to ${fromProcessorName}`)
    let connector = new Connector(fromProcessorName, toProcessorName)
    this.connectors.push(connector)
    connector.connect(this.processors)
  }

  // is used?
  handleError(error) {
    logger.error(`Error in transmission ${this.id}:`, error)
    logger.error('Transmission stack:', error.transmissionStack)
    // Optionally attempt recovery
    if (this.parent) {
      this.parent.handleError(error)
    }
  }

  getTransmissionInfo() {
    return {
      id: this.id,
      path: this.path,
      depth: this.path.length,
      children: Array.from(this.children).map(c => c.id)
    }
  }

  toString() {
    const info = this.getTransmissionInfo()
    let description = `Transmission : ${info.id}
      path: ${info.path},
      depth: ${info.path.length},
      children: ${info.children}`
    // Describe processors
    description += 'Processors:\n'
    Object.keys(this.processors).forEach((processorName) => {
      description += `  - ${ns.shortName(processorName)} a ${this.processors[processorName]} \n`
    })

    // Describe connectors
    description += 'Connectors:\n'
    this.connectors.forEach((connector, index) => {
      description += `  - Connector ${index + 1}: ${ns.shortName(connector.fromName)} -> ${ns.shortName(connector.toName)} \n`
    })

    return description
  }
}

export default Transmission

================
File: src/processors/base/AbstractProcessorFactory.js
================
import logger from '../../utils/Logger.js'

// Import processor groups
import SystemProcessorsFactory from '../system/SystemProcessorsFactory.js'
import TestProcessorsFactory from '../test/TestProcessorsFactory.js'
import FsProcessorsFactory from '../fs/FsProcessorsFactory.js'
import MarkupProcessorsFactory from '../markup/MarkupProcessorsFactory.js'
import UtilProcessorsFactory from '../util/UtilProcessorsFactory.js'
import TextProcessorsFactory from '../text/TextProcessorsFactory.js'
import ProtocolsProcessorsFactory from '../protocols/ProtocolsProcessorsFactory.js'
import RDFProcessorsFactory from '../rdf/RDFProcessorsFactory.js'
import PostcraftProcessorsFactory from '../postcraft/PostcraftProcessorsFactory.js'
import FlowProcessorsFactory from '../flow/FlowProcessorsFactory.js'
import StagingProcessorsFactory from '../staging/StagingProcessorsFactory.js'
import GitHubProcessorsFactory from '../github/GitHubProcessorsFactory.js'
import JSONProcessorsFactory from '../json/JSONProcessorsFactory.js'
import TerrapackProcessorsFactory from '../terrapack/TerrapackProcessorsFactory.js' // 2025-01-01

// added 2024-11-28
import UnsafeProcessorsFactory from '../unsafe/UnsafeProcessorsFactory.js'
import HttpProcessorsFactory from '../http/HttpProcessorsFactory.js'
import McpProcessorsFactory from '../mcp/McpProcessorsFactory.js'
import XmppProcessorsFactory from '../xmpp/XmppProcessorsFactory.js'

// added 2025-01-14 : Happy Birthday to me!
import ExampleProcessorsFactory from '../example-group/ExampleProcessorsFactory.js'

// 2025-01-16 : finally getting around to it
import SPARQLProcessorsFactory from '../sparql/SPARQLProcessorsFactory.js'

class AbstractProcessorFactory {

    // looks until it finds
    // good enough for now

    static createProcessor(type, config) {
        logger.trace(`\nAbstractProcessorFactory.createProcessor : type.value = ${type.value}`)
        //  logger.debug(`AbstractProcessorFactory.createProcessor : config = ${config}`)

        var processor = ExampleProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = UnsafeProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = HttpProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = McpProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = XmppProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = TestProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = UtilProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = FsProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = MarkupProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = TextProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = ProtocolsProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = RDFProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = PostcraftProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = SystemProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = FlowProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = GitHubProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = StagingProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = JSONProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = TerrapackProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = SPARQLProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

    }
}

export default AbstractProcessorFactory

================
File: src/processors/base/Processor.js
================
import { EventEmitter } from 'events'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import ProcessorSettings from './ProcessorSettings.js'

class Processor extends EventEmitter {
    constructor(config) {
        super()
        this.config = config
        this.settee = new ProcessorSettings(this.config)
        //  this.settee = null;
        this.messageQueue = []
        this.processing = false
        this.outputs = []

        this.app = null // Will be set from message
    }

    getAppPath(relativePath) {
        if (!this.app?.rootDir) {
            throw new Error('Application context not available')
        }
        return path.join(this.app.rootDir, relativePath)
    }

    getValues(property, fallback) {
        logger.debug(`Processor.getValues looking for ${property}`)

        const shortName = ns.getShortname(property)
        if (this.message && this.message[shortName]) {
            return [this.message[shortName]]
        }

        this.settee.settingsNode = this.settingsNode ////////////////////////////////////////
        const values = this.settee.getValues(property, fallback)
        logger.debug(`Processor.getValues values = ${values}`)
        return values
    }

    getProperty(property, fallback = undefined) {
        // logger.setLogLevel('debug')
        logger.debug(`Processor.getProperty looking for ${property}`)
        const shortName = ns.getShortname(property)
        if (this.message && this.message[shortName]) {
            logger.debug(`Found in message: ${this.message[shortName]}`)
            return this.message[shortName]
        }
        logger.debug(`Processor.getProperty, property = ${property}`)

        //   logger.debug(`Processor.getProperty, this.settee.config = ${this.settee.config}`)
        this.settee.settingsNode = this.settingsNode ////////////////////////////////////////////
        const value = this.settee.getValue(property, fallback)
        logger.debug(`Processor.getProperty, value = ${value}`)
        return value
    }

    async preProcess(message) {
        this.app = message.app
        this.config.app = this.app

        if (message.onProcess) { // Claude
            message.onProcess(this, message)
        }

        this.previousLogLevel = logger.getLevel()
        /*
        logger.setLogLevel('debug')
        const loglevel = this.getProperty(ns.trn.loglevel)
        logger.debug(`loglevel = ${loglevel}`)
        if (loglevel) {
            logger.setLogLevel(loglevel)
        }
            */
        const messageType = this.getProperty(ns.trn.messageType)
        if (messageType) {
            if (messageType.value) {
                message.messageType = messageType.value
            } else {
                message.messageType = messageType
            }
        }
        this.message = message
    }

    // cLAUDE
    async process(message) {
        if (message.onProcess) {
            message.onProcess(this, message)
        }
        await this.emit('message', message)
    }



    async postProcess(message) {
        logger.setLogLevel(this.previousLogLevel)
        this.previousLogLevel = null
    }

    async receive(message) {
        await this.enqueue(message)
    }

    async enqueue(message) {
        this.messageQueue.push({ message })
        if (!this.processing) {
            this.executeQueue()
        }
    }

    async executeQueue() {
        this.processing = true
        while (this.messageQueue.length > 0) {
            let { message } = this.messageQueue.shift()
            message = structuredClone(message)
            this.addTag(message)

            await this.preProcess(message)
            await this.process(message)
            await this.postProcess(message)
        }
        this.processing = false
    }

    async process(message) {
        throw new Error('process method not implemented')
    }

    addTag(message) {
        const tag = this.getTag()
        if (!message.tags) {
            message.tags = tag
            return
        }
        message.tags = message.tags + '.' + tag
    }

    getTag() {
        return ns.shortName(this.id)
    }

    async emit(event, message) {
        await new Promise(resolve => {
            super.emit(event, message)
            resolve()
        })
        return message
    }

    getOutputs() {
        const results = this.outputs
        this.outputs = []
        return results
    }

    toString() {
        logger.reveal(this.settings)
        const settingsNodeValue = this.settingsNode ? this.settingsNode.value : 'none'
        return `
        *** Processor ${this.constructor.name}
                id = ${this.id}
                label = ${this.label}
                type = ${this.type}
                description = ${this.description}
                settingsNodeValue = ${settingsNodeValue}
                settings = ${this.settings}
       `
    }
}

export default Processor

================
File: src/processors/base/ProcessorSettings.js
================
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'

class ProcessorSettings {
    constructor(config) {
        this.config = config

    }

    getValues(property, fallback) {
        logger.debug(`\n\nProcessorSettings.getValues, property = ${property.value}`)

        if (!this.settingsNode || !this.config) {
            return fallback ? [fallback] : []
        }

        const dataset = this.config
        const ptr = grapoi({ dataset, term: this.settingsNode })

        // Get all values and make them unique using distinct()
        logger.debug(`get all matches to ${this.settingsNode.value} ${property} ?value`)
        const values = ptr.out([property]).distinct()
        logger.debug(`Values found: ${values.terms.length}`)

        if (values.terms.length > 0) {
            const all = values.terms.map(term => term.value)
            logger.debug(`All values: ${all}`)
            return all
        }

        // logger.log(dataset)
        // Check settings reference
        const settingsPtr = ptr.out([ns.trn.settings]).distinct()
        if (settingsPtr.term) {
            const refPtr = grapoi({ dataset, term: settingsPtr.term })
            const refValues = refPtr.out([property]).distinct()
            logger.debug(`RefValues found: ${refValues.terms.length}`)
            if (refValues.terms.length > 0) {
                return refValues.terms.map(term => term.value)
            }
        }

        return fallback ? [fallback] : []
    }

    getValue(property, fallback) {
        const values = this.getValues(property, fallback)
        logger.debug(`All values2: ${values}`)
        if (values.length == 0) {
            return undefined
        }
        return values.length == 1 ? values[0] : values // TODO DEPRECATED
    }
}

export default ProcessorSettings

================
File: src/processors/example-group/ExampleProcessor.js
================
// src/processors/example-group/ExampleProcessor.js
/**
 * @class ExampleProcessor
 * @extends Processor
 * @classdesc
 * **a Basic Transmissions Processor**
 *
 * Provides a template for creating new processors, demonstrates use of config settings.
 *
 * #### __*Input*__
 * * **`message.common`** - addressed by all instances of this ExampleProcessor (optional, default undefined)
 * * **`message.something1`** - Template string (used if templateFilename is not provided)
 * * **`message.something2`** - Object with properties for template rendering (e.g., title, body)
 * * **`message.notavalue`** - Object with properties for template rendering (e.g., title, body)
 *
 * #### __*Output*__
 * * **`message.content`** - The rendered template content
 *
 * #### __*Processing*__
 * * Uses Nunjucks to render templates
 * * Can render from a template file or a template string
 * * Applies content from message.contentBlocks to the template
 *
* #### __*Side Effects*__
 *
 * #### __Tests__
 * *
 *
  * #### __*ToDo*__
 * * Add test information here
 * * Cache templates - cache in utils?
 */

import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class ExampleProcessor extends Processor {
    constructor(config) {
        super(config)
    }

    /**
      * Does something with the message and emits a 'message' event with the processed message.
      * @param {Object} message - The message object.
      */
    async process(message) {
        logger.debug(`\n\nExampleProcessor.process`)

        // TODO figure this out better
        // may be needed if preceded by a spawning processor, eg. fs/DirWalker
        if (message.done) {
            return this.emit('message', message)
            // or simply return
        }

        // message is processed here :

        // property values pulled from message | config settings | fallback
        const me = await this.getProperty(ns.trn.me)
        logger.log(`\nI am ${me}`)

        message.common = await this.getProperty(ns.trn.common)
        message.something1 = await this.getProperty(ns.trn.something1)

        message.something2 = await this.getProperty(ns.trn.something2)

        var added = await this.getProperty(ns.trn.added, '')
        message.something1 = message.something1 + added

        message.notavalue = await this.getProperty(ns.trn.notavalue, 'fallback value')

        // message forwarded
        return this.emit('message', message)
    }
}
export default ExampleProcessor

================
File: src/processors/example-group/ExampleProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import ExampleProcessor from './ExampleProcessor.js'
/*
   a ref to this should go in `src/processors/base/AbstractProcessorFactory.js`
*/


// import OtherProcessor from './ExampleProcessor.js'

class ExampleProcessorsFactory {

    static createProcessor(type, config) {

        if (type.equals(ns.trn.ExampleProcessor)) {
            return new ExampleProcessor(config)
        }

        /** Other processors in the group follow the same pattern

        if (type.equals(ns.trn.OtherProcessor)) {
            return new OtherProcessor(config)
        }
            ...
        */

        return false
    }
}
export default ExampleProcessorsFactory

================
File: src/processors/flow/DeadEnd.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class DeadEnd extends Processor {

    async process(message) {
        logger.log('DeadEnd at [' + message.tags + '] ' + this.getTag())
    }

}
export default DeadEnd

================
File: src/processors/flow/FlowProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import ForEach from './ForEach.js'
import Ping from './Ping.js'
import NOP from '../flow/NOP.js'
import DeadEnd from '../flow/DeadEnd.js'
import Halt from '../flow/Halt.js'
import Unfork from '../flow/Unfork.js'
import Fork from '../flow/Fork.js'

class FlowProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.ForEach)) {
            logger.debug('FlowProcessorsFactory: Creating ForEach processor')
            return new ForEach(config)
        }
        if (type.equals(ns.trn.Ping)) {
            logger.debug('FlowProcessorsFactory: Creating Ping processor')
            return new Ping(config)
        }
        if (type.equals(ns.trn.NOP)) {
            return new NOP(config)
        }
        if (type.equals(ns.trn.DeadEnd)) {
            return new DeadEnd(config)
        }
        if (type.equals(ns.trn.Halt)) {
            return new Halt(config)
        }
        if (type.equals(ns.trn.Fork)) {
            return new Fork(config)
        }
        if (type.equals(ns.trn.Unfork)) {
            return new Unfork(config)
        }
        return false
    }
}

export default FlowProcessorsFactory

================
File: src/processors/flow/ForEach.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ForEach extends Processor {
    constructor(config) {
        super(config)
    }

    async process(message) {
        //   logger.setLogLevel('debug')
        logger.debug('ForEach execute method called')

        if (!message.foreach || !Array.isArray(message.foreach)) {
            logger.error('ForEach: Invalid or missing foreach array in message')
            message.foreach = ["testing-testing", "one", "two", "three"]
            // throw new Error('Invalid or missing foreach array in message')
        }

        for (const item of message.foreach) {
            const clonedMessage = structuredClone(message)
            clonedMessage.currentItem = item
            delete clonedMessage.foreach // Remove the original array to prevent infinite loops TODO needed?

            logger.debug(`ForEach: Emitting message for item: ${item}`)
            this.emit('message', clonedMessage)
        }

        logger.debug('ForEach: Finished processing all items')
    }
}
export default ForEach

================
File: src/processors/flow/Fork.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'


// rough, only for system testing

class Fork extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {
        //   logger.setLogLevel('debug')
        const nForks = message.nForks || 2

        logger.debug('forks = ' + nForks)

        for (let i = 0; i < nForks; i++) {
            var messageClone = structuredClone(message)
            messageClone.forkN = i
            logger.debug('--- emit --- ' + i)
            this.emit('message', messageClone)
        }

        message.done = true // one extra to flag completion

        return this.emit('message', message)
        //   return this.getOutputs()
    }

}

export default Fork

================
File: src/processors/flow/Halt.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class Halt extends Processor {

    process(message) {
        logger.log('\n************************************************************************')
        logger.log('*** << Thou Hast Summoned HALT, the Mighty Stopper of All Things  >> ***')
        logger.log('*** <<                   ~~~ ALL IS GOOD ~~~                      >> ***')
        logger.log('*** <<                     Have a nice day!                       >> ***')
        logger.log('************************************************************************\n')
        logger.log('*** Transmission was : ' + message.tags)
        logger.log('*** Context now : ')
        logger.reveal(message)
        process.exit() // all good
    }
}

export default Halt

================
File: src/processors/flow/NOP.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class NOP extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {
        const done = message.done ? `DONE` : `NOT DONE`
        logger.log(`\nNOP at [${message.tags}] ${this.getTag()} (${done})`)

        return this.emit('message', message)
    }

    double(string) {
        return string + string
    }
}
export default NOP

================
File: src/processors/flow/Ping.js
================
import { Worker } from 'worker_threads';
import path from 'path';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class Ping extends Processor {
    constructor(config) {
        super(config);
        this.worker = null;
        this.pingConfig = {
            interval: this.getPropertyFromMyConfig(ns.trn.interval) || 5000,
            count: this.getPropertyFromMyConfig(ns.trn.count) || 0,
            payload: this.getPropertyFromMyConfig(ns.trn.payload) || 'ping',
            killSignal: this.getPropertyFromMyConfig(ns.trn.killSignal) || 'STOP',
            retryAttempts: this.getPropertyFromMyConfig(ns.trn.retryAttempts) || 3,
            retryDelay: this.getPropertyFromMyConfig(ns.trn.retryDelay) || 1000
        };
    }

    async process(message) {
        try {
            // Check for kill signal in incoming message
            if (message.kill === this.pingConfig.killSignal) {
                await this.shutdown();
                return this.emit('message', {
                    ...message,
                    pingStatus: 'stopped',
                    timestamp: Date.now()
                });
            }

            if (this.worker) {
                logger.warn('Ping worker already running, ignoring start request');
                return;
            }

            let retryCount = 0;
            const startWorker = async () => {
                try {
                    this.worker = new Worker(
                        path.join(process.cwd(), 'src/processors/flow/PingWorker.js')
                    );

                    this.worker.on('message', (msg) => {
                        switch (msg.type) {
                            case 'ping':
                                this.emit('message', {
                                    ...message,
                                    ping: {
                                        count: msg.count,
                                        timestamp: msg.timestamp,
                                        payload: msg.payload,
                                        status: 'running'
                                    }
                                });
                                break;
                            case 'complete':
                                this.emit('message', {
                                    ...message,
                                    pingComplete: true,
                                    timestamp: Date.now()
                                });
                                break;
                            case 'error':
                                this.handleWorkerError(msg.error, startWorker, retryCount);
                                break;
                        }
                    });

                    this.worker.on('error', (error) => {
                        this.handleWorkerError(error, startWorker, retryCount);
                    });

                    this.worker.on('exit', (code) => {
                        if (code !== 0) {
                            this.handleWorkerError(
                                new Error(`Worker stopped with exit code ${code}`),
                                startWorker,
                                retryCount
                            );
                        }
                        this.worker = null;
                    });

                    this.worker.postMessage({
                        type: 'start',
                        config: this.pingConfig
                    });

                } catch (error) {
                    this.handleWorkerError(error, startWorker, retryCount);
                }
            };

            await startWorker();

            return new Promise((resolve) => {
                this.worker.on('exit', () => {
                    resolve(message);
                });
            });

        } catch (error) {
            logger.error(`Failed to start ping processor: ${error}`);
            throw error;
        }
    }

    async handleWorkerError(error, retryFn, retryCount) {
        logger.error(`Ping worker error: ${error}`);

        if (retryCount < this.pingConfig.retryAttempts) {
            retryCount++;
            logger.info(`Retrying ping worker (attempt ${retryCount}/${this.pingConfig.retryAttempts})`);
            setTimeout(retryFn, this.pingConfig.retryDelay);
        } else {
            logger.error('Max retry attempts reached, stopping ping worker');
            this.emit('error', error);
            await this.shutdown();
        }
    }

    async shutdown() {
        if (this.worker) {
            this.worker.postMessage({ type: 'stop' });
            this.worker = null;
        }
    }
}

export default Ping;

================
File: src/processors/flow/Unfork.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import DeadEnd from './DeadEnd.js'
/*
TODO move to ./flow

only accept the first call
*/

class Unfork extends Processor {

    constructor(config) {
        super(config)

        /* NOPE
        if (Unfork._instance) {
            return new DeadEnd(config)
        }
        Unfork._instance = this;
*/
    }

    async process(message) {
        //     logger.setLogLevel("debug")
        logger.debug(`Unfork got message with done=${message.done}, tags=${message.tags}`)

        logger.debug('Unfork ----')
        if (message.done) {
            logger.debug(' - Unfork passing message >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>')
            message.done = false // in case it's needed later

            /*
                        await new Promise(resolve => {
                            //    super.emit(event, message)
                            return this.emit('message', message)
                            resolve()
                            logger.log(`after resolve has ${message.done}`)
                        })
            */
            return this.emit('message', message)
        } else {
            logger.debug(' - Unfork terminating pipe')
            return
        }
    }
}
export default Unfork

================
File: src/processors/fs/DirWalker.js
================
import { readdir } from 'fs/promises'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import StringUtils from '../../utils/StringUtils.js'

class DirWalker extends Processor {
    constructor(config) {
        super(config)
        //    this.includePatterns = ['.md']
        //  this.excludePrefixes = ['_', '.']
        this.fileCount = 0
    }

    async process(message) {
        //   logger.setLogLevel('debug')
        logger.debug('\nDirWalker.process')
        logger.debug(`\nDirWalker.process, this = ${this}`)
        message.counter = 0
        message.slugs = []
        message.done = false

        var sourceDir = this.getProperty(ns.trn.sourceDir)
        logger.debug(`DirWalker sourceDir from config = ${sourceDir}`)
        if (!message.sourceDir) {
            message.sourceDir = sourceDir
        }

        if (!sourceDir) {
            sourceDir = message.dataDir
        }


        this.includePatterns = this.getProperty(ns.trn.includePattern, ['*.md', '*.js', '*.json', '*.ttl'])
        this.excludePatterns = this.getProperty(ns.trn.excludePattern, ['*.', '.git', 'node_modules'])



        logger.debug('\n\nDirWalker, message.targetPath = ' + message.targetPath)
        logger.debug('DirWalker, message.rootDir = ' + message.rootDir)
        logger.debug('DirWalker, message.sourceDir = ' + message.sourceDir)

        //    logger.log(`DirWalker.sourceDir = ${sourceDir}`)
        //  logger.reveal(sourceDir)
        let dirPath
        if (path.isAbsolute(sourceDir)) {
            dirPath = sourceDir
        } else {
            if (message.targetPath) {
                dirPath = path.join(message.targetPath, sourceDir)
            } else {
                dirPath = path.join(message.rootDir, sourceDir)
            }
        }
        logger.debug(`DirWalker resolved dirPath = ${dirPath}`)

        await this.walkDirectory(dirPath, message)

        const finalMessage = structuredClone(message)
        finalMessage.done = true
        logger.debug("DirWalker emitting final done=true message")
        return this.emit('message', finalMessage)
    }

    // move to util.js ?
    // const markdownFiles = files.filter(file => matchesPattern(file, '*.md'));

    matchPatterns(str, patterns) {
        return StringUtils.matchPatterns(str, patterns)

        const matches = patterns.filter(pattern => this.matchesPattern(str, pattern))
        if (matches.length > 0) {
            return matches
        }
        return false
    }

    matchesPattern(str, pattern) {
        return StringUtils.matchesPattern(str, pattern)

        // Convert glob pattern to regex
        const regexPattern = pattern
            .replace(/\./g, '\\.')   // Escape dots
            .replace(/\*/g, '.*')   // Convert * to .*
        const regex = new RegExp(`^${regexPattern}$`)
        return regex.test(str)
    }

    async walkDirectory(dir, baseMessage) {
        logger.debug(`DirWalker.walkDirectory, dir = ${dir}`)
        //   logger.reveal(this.message)
        const entries = await readdir(dir, { withFileTypes: true })

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name)

            //   if (entry.isDirectory() && !this.excludePatterns.includes(entry.name[0])) {

            // should be dir? what about added includes?
            if (entry.isDirectory() && !this.matchPatterns(fullPath, this.excludePatterns)) {
                await this.walkDirectory(fullPath, baseMessage)
            } else if (entry.isFile()) {
                //   const extension = path.extname(entry.name)
                // const prefix = entry.name[0]

                if (!this.matchPatterns(fullPath, this.excludePatterns) &&
                    this.matchPatterns(fullPath, this.includePatterns)) {

                    //   if (!this.excludePatterns.includes(prefix) &&
                    //     this.includePatterns.includes(extension)) {
                    const message = structuredClone(baseMessage)
                    message.filename = entry.name
                    message.subdir = path.dirname(path.relative(message.targetPath, fullPath)).split(path.sep)[1]
                    message.fullPath = fullPath
                    message.filepath = path.relative(baseMessage.targetPath || baseMessage.rootDir, fullPath)
                    message.done = false
                    message.counter++

                    const slug = message.filename.split('.')[0]
                    message.slugs.push(slug)

                    logger.debug(`DirWalker emitting :
                        message.targetPath: ${message.targetPath}
                        message.filename: ${message.filename}
                        message.fullPath: ${message.fullPath}
                        message.subdir: ${message.subdir}
                        message.filepath: ${message.filepath}
                        message.slugs: ${message.slugs}`)
                    //        process.exit()
                    message.fileCount++
                    this.emit('message', message)
                }
            }
        }
    }
}

export default DirWalker

================
File: src/processors/fs/FileCopy.js
================
// src/processors/fs/FileCopy.js
/**
 * @class FileCopy
 * @extends Processor
 * @classdesc
 * **a Transmissions Processor**
 *
 * Copies files or entire directories on the local filesystem.
 *
 * #### __*Configuration*__
 * If a `settings` is provided in the transmission:
 * * **`ns.trn.source`** - The source path relative to `applicationRootDir`
 * * **`ns.trn.destination`** - The destination path relative to `applicationRootDir`
 *
 * #### __*Input*__
 * * **`message.rootDir`** (optional) - The root directory of the operation
 * * **`message.applicationRootDir`** (optional) - The root directory of the application, fallback `rootDir`
 * * **`message.source`** (if no `settings`) - The source path of the file or directory to copy
 * * **`message.destination`** (if no `settings`) - The destination path for the copied file or directory
 *
 * #### __*Output*__
 * * **`message`** - unmodified
 *
 * #### __*Behavior*__
 * * Copies the specified file or directory to the destination
 * * Checks and creates target directories if they don't exist
 * * Copies individual files directly
 * * Recursively copies directories and their contents
 * * Logs detailed information about the copying process for debugging
 *
 * #### __Tests__
 * * **`./run file-copy-remove-test`**
 * * **`npm test -- tests/integration/file-copy-remove-test.spec.js`**
 */

import { copyFile, mkdir, readdir, stat } from 'node:fs/promises'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class FileCopy extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Executes the file copy operation
     * @param {Object} message - The input message
     */
    async process(message) {
        //  logger.setLogLevel("info")

        logger.debug("message.rootDir = " + message.rootDir)
        var source, destination

        // Determine source and destination paths
        if (this.settings === 'undefined') {
            logger.debug('FileCopy: using message.source and message.destination')
            source = message.source
            destination = message.destination
        } else {
            logger.debug(`FileCopy: using settings ${this.settings.value}`)
            source = this.getPropertyFromMyConfig(ns.trn.source)
            destination = this.getPropertyFromMyConfig(ns.trn.destination)
            if (message.targetPath) {
                source = path.join(message.targetPath, source)
                destination = path.join(message.targetPath, destination)
            } else {
                source = path.join(message.rootDir, source)
                destination = path.join(message.rootDir, destination)
            }

        }

        logger.debug(`Source: ${source}`)
        logger.debug(`Destination: ${destination}`)

        try {
            await this.ensureDirectoryExists(path.dirname(destination))
            const sourceStat = await stat(source)

            if (sourceStat.isFile()) {
                logger.debug(`Copying file from ${source} to ${destination}`)
                await copyFile(source, destination)
            } else if (sourceStat.isDirectory()) {
                logger.debug(`Copying directory from ${source} to ${destination}`)
                await this.copyDirectory(source, destination)
            }
        } catch (err) {
            logger.error(`Error in FileCopy: ${err.message}`)
            logger.error(`Source: ${source}`)
            logger.error(`Destination: ${destination}`)
        }

        return this.emit('message', message)
    }

    /**
     * Ensures the specified directory exists, creating it if necessary
     * @param {string} dirPath - The directory path to ensure
     */
    async ensureDirectoryExists(dirPath) {
        logger.debug(`Ensuring directory exists: ${dirPath}`)
        try {
            await mkdir(dirPath, { recursive: true })
            logger.debug(`Directory created/ensured: ${dirPath}`)
        } catch (err) {
            logger.debug(`Error creating directory ${dirPath}: ${err.message}`)
            throw err
        }
    }

    /**
     * Recursively copies a directory and its contents
     * @param {string} source - The source directory path
     * @param {string} destination - The destination directory path
     */
    async copyDirectory(source, destination) {
        logger.debug(`Copying directory: ${source} to ${destination}`)
        try {
            await this.ensureDirectoryExists(destination)
            const entries = await readdir(source, { withFileTypes: true })

            for (const entry of entries) {
                const srcPath = path.join(source, entry.name)
                const destPath = path.join(destination, entry.name)

                logger.debug(`Processing: ${srcPath} to ${destPath}`)

                if (entry.isDirectory()) {
                    await this.copyDirectory(srcPath, destPath)
                } else {
                    await copyFile(srcPath, destPath)
                    logger.debug(`File copied: ${srcPath} to ${destPath}`)
                }
            }
        } catch (err) {
            logger.debug(`Error in copyDirectory: ${err.message}`)
            throw err
        }
    }
}

export default FileCopy

================
File: src/processors/fs/FilenameMapper.js
================
import Processor from '../base/Processor.js';
import path from 'path';
import logger from '../../utils/Logger.js';

class FilenameMapper extends Processor {
    constructor(config) {
        super(config);
        this.extensions = {
            html: '.mm.html',
            svg: '.mm.svg'
        };
    }

    async process(message) {
        const format = message.format || 'html';
        const extension = this.extensions[format];

        if (!extension) {
            throw new Error(`Unknown format: ${format}`);
        }

        const parsedPath = path.parse(message.filepath);
        message.filepath = path.join(
            parsedPath.dir,
            parsedPath.name + extension
        );

        return this.emit('message', message);
    }
}

export default FilenameMapper;

================
File: src/processors/fs/FileReader.js
================
import { readFile } from 'node:fs/promises'
import { access, constants, statSync } from 'node:fs'
import path from 'path'
import mime from 'node-mime-types'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'

class FileReader extends Processor {
    constructor(config) {
        super(config)
    }


    async process(message) {
        logger.debug(`FileReader.process, done=${message.done}`)

        if (message.done) return this.emit('message', message)

        let filePath

        // First try deriving path from message properties
        if (message.fullPath) {
            filePath = message.fullPath
        } else if (message.filepath) {
            if (message.targetPath && !path.isAbsolute(message.filepath)) {
                filePath = path.join(message.targetPath, message.filepath)
            } else {
                filePath = message.filepath
            }
        } else {
            // Fall back to getting path from config
            filePath = await this.getProperty(ns.trn.sourceFile)
            if (!filePath) {
                throw new Error('No file path provided in message or config')
            }

            // Resolve relative to targetPath or rootDir
            if (!path.isAbsolute(filePath)) {
                filePath = path.join(message.targetPath || message.rootDir, filePath)
            }
        }

        logger.debug(`FileReader.process(), reading file: ${filePath}`)
        logger.debug(`FileReader.process(), process.cwd() = ${process.cwd()}`)

        // Verify file is readable
        await new Promise((resolve, reject) => {
            access(filePath, constants.R_OK, (err) => {
                if (err) {
                    reject(new Error(`File ${filePath} is not readable: ${err.message}`))
                }
                resolve()
            })
        })

        // Handle metadata if requested
        const metaField = await this.getProperty(ns.trn.metaField)
        if (metaField) {
            const metadata = this.getFileMetadata(filePath)
            message[metaField] = metadata
        }

        // Read and return file content
        const content = await readFile(filePath, 'utf8')
        message.content = content

        logger.debug(`FileReader successfully read file: ${filePath}`)
        return this.emit('message', message)
    }

    getFileMetadata(filePath) {
        try {
            const stats = statSync(filePath)
            const filename = path.basename(filePath)
            return {
                filename: filename,
                mediaType: mime.getMIMEType(filename),
                filepath: filePath,
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                accessed: stats.atime,
                isDirectory: stats.isDirectory(),
                isFile: stats.isFile(),
                permissions: stats.mode,
                owner: stats.uid,
                group: stats.gid
            }
        } catch (error) {
            logger.error(`Error getting file metadata: ${error.message}`)
            return null
        }
    }
}

export default FileReader

================
File: src/processors/fs/FileRemove.js
================
// src/processors/fs/FileRemove.js
/**
 * FileRemove Processor
 *
 * Removes files or directory contents on the local filesystem.
 * @extends Processor
 *
 * #### __*Input*__
 * * message.applicationRootDir (optional) - The root directory of the application
 * * message.target (if no settings) - The path of the file or directory to remove
 *
 * #### __*Configuration*__
 * If a settings is provided in the transmission:
 * * ns.trn.target - The target path relative to applicationRootDir
 *
 * #### __*Output*__
 * * Removes the specified file or directory contents
 * * message (unmodified) - The input message is passed through
 *
 * #### __*Behavior*__
 * * Removes individual files directly
 * * Recursively removes directory contents
 * * Logs debug information about the removal process
 *
 * #### __Tests__
 * `./run file-copy-remove-test`
 * `npm test -- tests/integration/file-copy-remove-test.spec.js`
 *
 */

import { unlink, readdir, stat, rm } from 'node:fs/promises'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class FileRemove extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Executes the file or directory removal operation
     * @param {Object} message - The input message
     */
    async process(message) {

        //  logger.setLogLevel('debug')

        this.ignoreDotfiles = true // default, simplify ".gitinclude"

        var target

        // TODO add check for  ignoreDotfiles = false

        // Determine target path
        if (this.settings === 'undefined') {
            logger.debug('FileRemove no settings from transmission, using message.target')
            target = message.target
        } else {
            logger.debug('FileRemove this.settings = ' + this.settings.value)
            target = await this.getProperty(ns.trn.target)
            //       target = this.getPropertyFromMyConfig(ns.trn.target)
            target = path.join(message.rootDir, target)
        }

        logger.debug('FileRemove, target = ' + target)
        try {
            const removeStat = await stat(target)

            if (removeStat.isFile()) {
                await this.removeFile(target)
            } else if (removeStat.isDirectory()) {
                await this.removeDirectoryContents(target)
            }
        } catch (err) {
            // probably already gone
            logger.debug('FileRemove, target stat caused err : ' + target)
        }

        return this.emit('message', message)
    }

    /**
     * Removes a file
     * @param {string} filePath - The path to the file to remove
     */
    async removeFile(filePath) {
        await unlink(filePath)
    }

    /**
     * Recursively removes the contents of a directory
     * @param {string} dirPath - The path to the directory
     */
    async removeDirectoryContents(dirPath) {
        logger.debug('FileRemove, dirPath = ' + dirPath)
        const entries = await readdir(dirPath, { withFileTypes: true })

        for (const entry of entries) {
            if (this.ignoreDotfiles && (entry.name.charAt(0) === ".")) {
                continue
            }
            const entryPath = path.join(dirPath, entry.name)

            if (entry.isDirectory()) {
                await this.removeDirectoryContents(entryPath)
            } else {
                await unlink(entryPath)
            }
        }
    }
}

export default FileRemove

================
File: src/processors/fs/FileWriter.js
================
import path from 'path'
import { access, constants } from 'node:fs'
import ns from '../../utils/ns.js'
import { writeFile } from 'node:fs/promises'
import { dirname, join } from 'node:path'
import { mkdir, mkdirSync } from 'node:fs'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
/**
 * FileWriter class that extends Processor
 * Write data to a file.
 *
 * First checks `message.targetFilepath` and if not set, uses the value from `processors.ttl` using `settings` for this processor instance.
 *
 * #### __*Input*__
 * * message.filepath
 * * message.content
 * #### __*Output*__
 * * as Input
 *
 * if message.loadContext is set, that is used as a name in the message for the file content
 */
class FileWriter extends Processor {

    /**
     * Constructs a new FileWriter object.
     * @param {Object} config - The configuration object for the FileWriter.
     */
    constructor(config) {
        super(config)
    }

    /**
     * Executes the write operation.
     * @param {Object} message - The execution message.
     */
    async process(message) {
        //   logger.setLogLevel('debug')
        logger.debug(`\n\nFileWriter.process, message.done = ${message.done}`)
        if (message.done) {
            //   message.done = false
            return this.emit('message', message)
        }

        if (message.dump) {
            // TODO make optional (on done?) - is a pain for multi
            //    const filename = `message_${new Date().toISOString()}.json`
            const filename = 'message.json'
            const f = path.join(message.dataDir, filename)
            const content = JSON.stringify(message)
            // Check if the file is readable.
            access(f, constants.W_OK, (err) => {
                if (err) {
                    logger.error(`FileWriter error : ${f} is not writable.`)
                    logger.reveal(message)
                }
            })
            return this.doWrite(f, content, message)
        }

        logger.debug("Filewriter, message.filepath = " + message.filepath)

        var destinationFile = await this.getProperty(ns.trn.destinationFile)
        var filepath = message.filepath
        if (message.subdir) {
            filepath = path.join(message.subdir, filepath)
        }
        //path.join(message.sourceDir, message.filepath)
        logger.debug(`Filewriter, 1 filepath = ${filepath}`)
        //   logger.reveal(filePath)

        if (!destinationFile) { // TODO fix, do other cases, refactor
            var targetDir = message.targetDir ?
                message.targetDir : await this.getProperty(ns.trn.targetDir)
            targetDir = targetDir ? targetDir : '.'

            filepath = path.join(targetDir, filepath)
        }

        if (!path.isAbsolute(filepath)) {
            filepath = path.join(message.targetPath, filepath)
        }

        logger.debug(`Filewriter, filepath = ${filepath}`)
        const dirName = dirname(filepath)
        logger.debug("Filewriter, dirName = " + dirName)

        /*
                var contentPath = this.getPropertyFromMyConfig(ns.trn.contentPath)

                if (typeof contentPath === 'undefined' || contentPath === 'undefined' || contentPath.value === 'undefined') {
                    contentPath = 'content'
                }

                // logger.debug("Filewriter, contentPath = " + contentPath)
                var content = message[contentPath.toString()] // TODO generalise.it
                if (typeof content === 'object') {
                    content = JSON.stringify(content)
                }
        */
        var content = message.content // TODO generalise, see above
        //   logger.debug("Filewriter, content = " + content)
        // logger.debug("Filewriter, typeof content = " + typeof content)

        this.mkdirs(dirName) // sync - see below

        return await this.doWrite(filepath, content, message)
    }

    async doWrite(f, content, message) {
        logger.log(' - FileWriter writing : ' + f)
        await writeFile(f, content)
        return this.emit('message', message)
    }

    mkdirs(dir) {
        mkdirSync(dir, { recursive: true })
        /*
                mkdir(dir, { recursive: true }, (error) => {
                    logger.log('EEEEEEEEEEEEEEEEEK!' + error)
                })
           */
    }
}

export default FileWriter

================
File: src/processors/fs/FsProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import DirWalker from './DirWalker.js'
import FileReader from './FileReader.js'
import FileWriter from './FileWriter.js'
import FileCopy from './FileCopy.js'
import FileRemove from './FileRemove.js'
import FilenameMapper from './FilenameMapper.js'

class FsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.DirWalker)) {
            return new DirWalker(config)
        }
        if (type.equals(ns.trn.FileReader)) {
            return new FileReader(config)
        }
        if (type.equals(ns.trn.FileWriter)) {
            return new FileWriter(config)
        }
        if (type.equals(ns.trn.FileCopy)) {
            return new FileCopy(config)
        }
        if (type.equals(ns.trn.FileRemove)) {
            return new FileRemove(config)
        }
        if (type.equals(ns.trn.FilenameMapper)) {
            return new FilenameMapper(config)
        }
        return false
    }
}

export default FsProcessorsFactory

================
File: src/processors/github/GitHubList_no-pag.js
================
import { Octokit } from '@octokit/rest'
import dotenv from 'dotenv'
import Processor from '../base/Processor.js'
import logger from '../../utils/Logger.js'

dotenv.config({ path: './trans-apps/applications/git-apps/.env' })

class GitHubList extends Processor {
    constructor(config) {
        super(config)
        logger.debug('GitHubList constructor called')
        this.octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })
        logger.debug('Octokit instance created')
    }

    async process(message) {
        logger.debug('GitHubList execute method called')
        logger.debug('Input message:', JSON.stringify(message, null, 2))

        if (!message.github || !message.github.name) {
            logger.error('GitHub username not provided in the message')
            throw new Error('GitHub username not provided in the message')
        }

        const username = message.github.name
        logger.debug(`Fetching repositories for username: ${username}`)

        try {
            logger.debug('Calling GitHub API')
            const { data } = await this.octokit.repos.listForUser({ username })
            logger.debug(`Fetched ${data.length} repositories`)

            const repositories = data.map(repo => repo.name)
            logger.debug('Extracted repository names:' + repositories)

            message.github.repositories = repositories
            logger.debug('Updated message:', JSON.stringify(message, null, 2))

            this.emit('message', message)
            logger.debug('Emitted updated message')
        } catch (error) {
            logger.error(`Error fetching repositories for ${username}:`, error)
            logger.debug('Error details:', JSON.stringify(error, null, 2))
            if (error.status === 403) {
                logger.warn('Possible rate limit exceeded. Check GitHub API rate limits.')
            }
            throw error
        }
    }
}

export default GitHubList

================
File: src/processors/github/GitHubList.js
================
import { Octokit } from '@octokit/rest'
import dotenv from 'dotenv'
import Processor from '../../../../transmissions/src/processors/base/Processor.js'
import logger from '../../../../transmissions/src/utils/Logger.js'

dotenv.config({ path: './trans-apps/applications/git-apps/.env' })

class GitHubList extends Processor {
    constructor(config) {
        super(config)
        logger.debug('GitHubList constructor called')
        this.octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })
        logger.debug('Octokit instance created')
    }

    async process(message) {
        //    logger.setLogLevel('debug')
        logger.debug('GitHubList process method called')

        try {
            // Initialize payload.github if missing
            if (!message.payload) {
                message.payload = {}
            }
            if (!message.payload.github) {
                message.payload.github = {}
            }

            //     const username = message.payload.github.name
            const username = message.github.name
            logger.debug(`Processing for username: ${username}`)

            logger.debug('Calling GitHub API with pagination')
            logger.info(`Starting repository fetch for ${username}`)

            const repositories = await this.fetchAllRepositories(username)
            logger.debug(`Setting ${repositories.length} repositories in payload`)

            // Set in payload, not message.github
            message.payload.github.repositories = repositories
            message.payload.github.totalRepos = repositories.length

            return this.emit('message', message)
        } catch (error) {
            this.handleError(error, username)
        }
    }

    async fetchAllRepositories(username) {
        const repositories = []
        let page = 1
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms))

        /*
        while (true) {
            try {
                const response = await this.octokit.repos.listForUser({
                    username,
                    per_page: 100,
                    page: page
                })

                repositories.push(...response.data.map(repo => repo.name))
                logger.debug(`Fetched page ${page} with ${response.data.length} repositories`)

                this.checkRateLimit(response.headers)

                if (response.data.length < 100) break
                page++

                await delay(1000) // 1 second delay between API calls
            } catch (error) {
                throw this.createDetailedError(error, 'Error fetching repositories page')
            }
        }
            */

        while (true) {
            const response = await this.octokit.repos.listForUser({
                username,
                per_page: 100,
                page
            })

            let data = response.data
            //  data = data.slice(0, 3) // Limit to first 3 repos

            logger.debug(`Page ${page}: Got ${data.length} repos`)

            repositories.push(...data.map(repo => repo.name))

            if (data.length < 100) break
            page++

            // Add delay between requests
            await new Promise(r => setTimeout(r, 5000))
        }

        logger.debug(`Total repositories found: ${repositories.length}`)

        return repositories
    }

    checkRateLimit(headers) {
        const remaining = headers['x-ratelimit-remaining']
        const resetTime = new Date(headers['x-ratelimit-reset'] * 1000)
        logger.info(`Rate limit remaining: ${remaining}, Reset time: ${resetTime}`)

        if (remaining < 10) {
            logger.warn(`Rate limit is low. Only ${remaining} requests left. Reset at ${resetTime}`)
        }
    }

    createDetailedError(error, message) {
        const detailedError = new Error(`${message}: ${error.message}`)
        detailedError.status = error.status
        detailedError.response = error.response
        return detailedError
    }

    handleError(error, username) {
        logger.error(`Error fetching repositories for ${username}:`, error.message)
        logger.debug('Error details:', JSON.stringify(error, null, 2))

        if (error.status === 403) {
            logger.warn('Rate limit exceeded. Check GitHub API rate limits.')
            throw new Error('GitHub API rate limit exceeded')
        } else if (error.status === 404) {
            logger.warn(`User ${username} not found on GitHub`)
            throw new Error(`GitHub user ${username} not found`)
        } else {
            throw new Error(`Failed to fetch GitHub repositories: ${error.message}`)
        }
    }
}

export default GitHubList

================
File: src/processors/github/GitHubProcessorsFactory.js
================
// GitHubProcessorsFactory.js
import logger from '../../../../transmissions/src/utils/Logger.js';
import ns from '../../../../transmissions/src/utils/ns.js';
import GitHubList from './GitHubList.js';

class GitHubProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.GitHubList)) {
            return new GitHubList(config);
        }
        return false;
    }
}

export default GitHubProcessorsFactory;

================
File: src/processors/http/services/MetricsService.js
================
import WebSocket from 'ws';
import os from 'os';

class MetricsService {
    constructor(server) {
        this.wss = new WebSocket.Server({ server });
        this.metrics = {
            startTime: Date.now(),
            requests: 0,
            connections: 0,
            memory: {},
            cpu: {}
        };
        this.setupWebSocket();
        this.startMetricsCollection();
    }

    setupWebSocket() {
        this.wss.on('connection', (ws) => {
            this.metrics.connections++;
            ws.on('close', () => this.metrics.connections--);
        });
    }

    startMetricsCollection() {
        setInterval(() => {
            this.updateMetrics();
            this.broadcastMetrics();
        }, 1000);
    }

    updateMetrics() {
        this.metrics.uptime = (Date.now() - this.metrics.startTime) / 1000;
        this.metrics.memory = {
            used: process.memoryUsage().heapUsed,
            total: os.totalmem(),
            free: os.freemem()
        };
        this.metrics.cpu = {
            load: os.loadavg(),
            cores: os.cpus().length
        };
    }

    broadcastMetrics() {
        const data = JSON.stringify(this.metrics);
        this.wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(data);
            }
        });
    }

    incrementRequests() {
        this.metrics.requests++;
    }
}

export default MetricsService;

================
File: src/processors/http/services/ShutdownService.js
================
import crypto from 'crypto';

class ShutdownService {
    constructor() {
        // Generate random credentials on startup
        this.username = crypto.randomBytes(16).toString('hex');
        this.password = crypto.randomBytes(32).toString('hex');
    }

    setupMiddleware(app) {
        app.use('/admin', (req, res, next) => {
            const authHeader = req.headers.authorization;
            if (!this.validateAuth(authHeader)) {
                res.setHeader('WWW-Authenticate', 'Basic');
                return res.status(401).send('Authentication required');
            }
            next();
        });
    }

    validateAuth(authHeader) {
        if (!authHeader || !authHeader.startsWith('Basic ')) {
            return false;
        }
        const base64Credentials = authHeader.split(' ')[1];
        const credentials = Buffer.from(base64Credentials, 'base64').toString('utf-8');
        const [username, password] = credentials.split(':');

        return username === this.username && password === this.password;
    }

    setupEndpoints(app, shutdownCallback) {
        app.get('/admin/credentials', (req, res) => {
            res.json({ username: this.username, password: this.password });
        });

        app.post('/admin/shutdown', (req, res) => {
            res.send('Shutdown initiated');
            shutdownCallback();
        });
    }
}

export default ShutdownService;

================
File: src/processors/http/HttpClient.js
================
import logger from '../../utils/Logger.js' // path will likely change
import Processor from '../base/Processor.js' // maybe more specific

/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 */
class HttpClient extends Processor {

    /**
     * Constructs a new ProcessorExample instance.
     * @param {Object} config - The configuration object.
     */
    constructor(config) {
        super(config)
    }

    /**
     * Does something with the message and emits a 'message' event with the processed message.
     * @param {Object} message - The message object.
     */
    async process(message) {
        //   logger.setLogLevel('debug')

        // processing goes here
        return this.emit('message', message)
    }
}

export default HttpClient

================
File: src/processors/http/HttpProcessorsFactory.js
================
//import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import HttpServer from './HttpServer.js'
import HttpClient from './HttpClient.js'
import HttpProxy from './HttpProxy.js'

class HttpProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.HttpServer)) {
            return new HttpServer(config)
        }
        if (type.equals(ns.trn.HttpClient)) {
            return new HttpClient(config)
        }
        if (type.equals(ns.trn.HttpProxy)) {
            return new HttpProxy(config)
        }

        return false
    }
}
export default HttpProcessorsFactory

================
File: src/processors/http/HttpProxy.js
================
import logger from '../../utils/Logger.js' // path will likely change
import Processor from '../base/Processor.js' // maybe more specific

/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 */
class HttpProxy extends Processor {

    /**
     * Constructs a new ProcessorExample instance.
     * @param {Object} config - The configuration object.
     */
    constructor(config) {
        super(config)
    }

    /**
     * Does something with the message and emits a 'message' event with the processed message.
     * @param {Object} message - The message object.
     */
    async process(message) {
        //    logger.setLogLevel('debug')

        // processing goes here
        return this.emit('message', message)
    }
}

export default HttpProxy

================
File: src/processors/http/HttpServer.js
================
import path from 'path';
import { Worker } from 'worker_threads';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class HttpServer extends Processor {
    constructor(config) {
        super(config);
        this.worker = null;
        this.serverConfig = {
            port: this.getPropertyFromMyConfig(ns.trn.port) || 4000,
            basePath: this.getPropertyFromMyConfig(ns.trn.basePath) || '/transmissions/test/',
            staticPath: this.getPropertyFromMyConfig(ns.trn.staticPath),
            cors: this.getPropertyFromMyConfig(ns.trn.cors) || false,
            timeout: this.getPropertyFromMyConfig(ns.trn.timeout) || 30000,
            maxRequestSize: this.getPropertyFromMyConfig(ns.trn.maxRequestSize) || '1mb',
            rateLimit: {
                windowMs: 15 * 60 * 1000,
                max: 100
            }
        };
    }

    async process(message) {
        try {
            this.worker = new Worker(
                path.join(process.cwd(), 'src/processors/http/HttpServerWorker.js')
            );

            this.worker.on('message', (msg) => {
                switch (msg.type) {
                    case 'status':
                        if (msg.status === 'running') {
                            logger.info(`Server running on port ${msg.port}`);
                        } else if (msg.status === 'stopped') {
                            this.emit('message', { ...message, serverStopped: true });
                        }
                        break;
                    case 'error':
                        logger.error(`Server error: ${msg.error}`);
                        this.emit('error', new Error(msg.error));
                        break;
                }
            });

            this.worker.on('error', (error) => {
                logger.error(`Worker error: ${error}`);
                this.emit('error', error);
            });

            this.worker.postMessage({
                type: 'start',
                config: this.serverConfig
            });

            return new Promise((resolve) => {
                this.worker.on('exit', () => {
                    resolve(message);
                });
            });

        } catch (error) {
            logger.error(`Failed to start server: ${error}`);
            throw error;
        }
    }

    async shutdown() {
        if (this.worker) {
            this.worker.postMessage({ type: 'stop' });
        }
    }
}

export default HttpServer;

================
File: src/processors/http/HttpServerWorker.js
================
import { parentPort } from 'worker_threads';
import express from 'express';
import path from 'path';
import logger from '../../utils/Logger.js';

class ServerWorker {
    constructor(config) {
        this.app = express();
        this.server = null;
        this.config = config;
        this.setupMessageHandling();
    }

    setupMessageHandling() {
        parentPort.on('message', (message) => {
            switch (message.type) {
                case 'start':
                    this.start(message.config);
                    break;
                case 'stop':
                    this.stop();
                    break;
                default:
                    logger.warn(`Unknown message type: ${message.type}`);
            }
        });
    }

    async start(config) {
        try {
            const { port = 4000, basePath = '/transmissions/test/', staticPath } = config;

            if (staticPath) {
                this.app.use(basePath, express.static(staticPath));
            }

            this.app.post('/shutdown', (req, res) => {
                res.send('Server shutting down...');
                this.stop();
            });

            this.server = this.app.listen(port, () => {
                parentPort.postMessage({
                    type: 'status',
                    status: 'running',
                    port: port
                });
            });

        } catch (error) {
            parentPort.postMessage({
                type: 'error',
                error: error.message
            });
        }
    }

    async stop() {
        if (this.server) {
            try {
                await new Promise((resolve, reject) => {
                    this.server.close((err) => {
                        if (err) reject(err);
                        resolve();
                    });
                });

                parentPort.postMessage({
                    type: 'status',
                    status: 'stopped'
                });

                process.exit(0);
            } catch (error) {
                parentPort.postMessage({
                    type: 'error',
                    error: error.message
                });
                process.exit(1);
            }
        }
    }
}

const worker = new ServerWorker();

================
File: src/processors/json/Blanker.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class Blanker extends Processor {
    constructor(config) {
        super(config)
        //    logger.setLogLevel('debug')
        logger.debug(config.blankValue)
        this.blankValue = config.blankValue || ''
    }

    async process(message) {
        const pointer = this.getPropertyFromMyConfig(ns.trn.pointer)
        const preserve = this.getPropertyFromMyConfig(ns.trn.preserve)

        var preservePath = preserve.value ? preserve.value : 'nonono'

        logger.debug(`Blanker.process,  typeof preservePath = ${typeof preservePath}, preservePath = ${preservePath}`)
        logger.reveal(preservePath)
        if (!pointer) {
            if (preservePath) {
                message = this.blankValues(message, '', preservePath)
            } else {
                message = this.blankAllValues(message)
            }
        } else {
            const parts = pointer.toString().split('.')
            let target = message

            for (let i = 0; i < parts.length - 1; i++) {
                target = target[parts[i]]
                if (!target) break
            }

            if (target && target[parts[parts.length - 1]]) {
                if (preservePath) {
                    target[parts[parts.length - 1]] =
                        this.blankValues(target[parts[parts.length - 1]], parts.join('.'), preservePath)
                } else {
                    target[parts[parts.length - 1]] =
                        this.blankAllValues(target[parts[parts.length - 1]])
                }
            }
        }

        return this.emit('message', message)
    }

    shouldPreserve(path, preservePath) {
        logger.debug(`Blanker.shouldPreserve path = ${path}, preservePath = ${preservePath}`)
        if (!preservePath) return false
        const pathParts = path.split('.')
        const preserveParts = preservePath.split('.')

        if (pathParts.length < preserveParts.length) return false

        for (let i = 0; i < preserveParts.length; i++) {
            if (pathParts[i] !== preserveParts[i]) return false
        }
        return true
    }

    // TODO refactor...can I be arsed?
    blankAllValues(obj) {
        if (Array.isArray(obj)) {
            return obj.map(item => this.blankAllValues(item))
        } else if (typeof obj === 'object' && obj !== null) {
            const result = {}
            for (const [key, value] of Object.entries(obj)) {
                result[key] = this.blankAllValues(value)
            }
            return result
        } else if (typeof obj === 'string') {
            return ''
        }
        return obj
    }

    blankValues(obj, currentPath = '', preservePath = '') {
        if (Array.isArray(obj)) {
            return obj.map((item, index) =>
                this.blankValues(item, `${currentPath}[${index}]`, preservePath)
            )
        } else if (typeof obj === 'object' && obj !== null) {
            const result = {}
            for (const [key, value] of Object.entries(obj)) {
                const newPath = currentPath ? `${currentPath}.${key}` : key
                logger.debug(`Blanker.blankValues 1 newPath = ${newPath}, preservePath = ${preservePath}`)
                if (this.shouldPreserve(newPath, preservePath)) {
                    result[key] = value
                } else {
                    result[key] = this.blankValues(value, newPath, preservePath)
                }
            }
            return result
        } else if (typeof obj === 'string') {
            logger.debug(`Blanker.blankValues 2 currentPath = ${currentPath}, preservePath = ${preservePath}`)
            return this.shouldPreserve(currentPath, preservePath) ? obj : ''
        }
        return obj
    }
}

export default Blanker

================
File: src/processors/json/JSONProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import JSONWalker from './JSONWalker.js'
import Restructure from './Restructure.js'
import ValueConcat from './ValueConcat.js'
import Blanker from './Blanker.js'

class JSONProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.Restructure)) {
            return new Restructure(config)
        }
        if (type.equals(ns.trn.JSONWalker)) {
            return new JSONWalker(config)
        }
        if (type.equals(ns.trn.ValueConcat)) {
            return new ValueConcat(config)
        }
        if (type.equals(ns.trn.Blanker)) {
            return new Blanker(config)
        }
        return false
    }

}
export default JSONProcessorsFactory

================
File: src/processors/json/JsonRestructurer.js
================
// JsonRestructurer.js

import logger from '../../utils/Logger.js'

class JsonRestructurer {
    constructor(mappings) {
        //   logger.setLogLevel('info')
        if (!mappings?.mappings || !Array.isArray(mappings.mappings)) {
            throw new Error('Invalid mapping structure')
        }
        this.mappings = mappings.mappings
        logger.debug('JsonRestructurer,  this.mappings = ' + this.mappings)
        //  logger.reveal(this.mappings)
    }

    getValueByPath(obj, path) {
        //    logger.debug('JsonRestructurer, path = ' + path)
        //  logger.debug('JsonRestructurer, OBJECT = ' + obj)

        //        logger.reveal(obj)
        //      logger.debug('JsonRestructurer, OBJECT = ^^^^')

        //   logger.debug('JsonRestructurer, obj.item.chat_messages = ' + obj.item.chat_messages)
        try {
            const sp = path.split('.')
            logger.debug('JsonRestructurer, sp = ' + sp)
            const reduced = sp.reduce((acc, part) => acc[part], obj)
            logger.debug('JsonRestructurer, reduced = ' + reduced)
            return reduced
        } catch (e) {
            logger.warn(`Warning: Path ${path} not found`)
            return undefined
        }
    }

    setValueByPath(obj, path, value) {
        logger.debug(`JsonRestructurer.setValueByPath, obj = ${obj}, path = ${path}, value = ${value}`)
        const parts = path.split('.')
        const last = parts.pop()
        const target = parts.reduce((acc, part) => {
            acc[part] = acc[part] || {}
            return acc[part]
        }, obj)
        logger.debug(`JsonRestructurer.setValueByPath, target = ${target}, last = ${last}, value = ${value}`)
        target[last] = value
    }

    restructure(inputData) {
        //   logger.log(`typeof inputData = ${typeof inputData}`)
        if (typeof inputData === 'string') {
            try {
                inputData = JSON.parse(inputData)
            } catch (e) {
                throw new Error('Invalid JSON string provided')
            }
        }
        // logger.reveal(inputData)
        //  process.exit(0)
        const result = {}
        this.mappings.forEach(({ pre, post }) => {
            //   logger.log(`PRE = ${pre}, POST = ${post}`)
            const value = this.getValueByPath(inputData, pre)
            // logger.log(`PRE = ${pre}, POST = ${post} value = ${value}`)
            if (value !== undefined) {
                this.setValueByPath(result, post, value)
            }
        })
        //    logger.log('RESULT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55')
        //  logger.reveal(result)
        // logger.log('RESULT ^^^^')
        return result
    }
}
export default JsonRestructurer

================
File: src/processors/json/JSONWalker.js
================
// src/processors/json/JSONWalker.js
/**
* @class JSONWalker
* @extends Processor
* @classdesc
* **A Transmissions Processor**
*
* Walks through a JSON structure and emits messages for each item.
*
* ### Processor Signature
*
* #### ***Configuration***
* ***`ns.trn.targetDir`** - Target directory path relative to current working directory
*
* #### ***Input***
* ***`message.payload`** - JSON object to process
*
* #### ***Output***
* * Emits a message for each item in the input payload
* * Final message has `done: true` flag
* * Each emitted message contains:
*   * ***`message.item`** - Current item being processed
*   * ***`message.payload`** - Empty object (configurable)
*
* #### ***Behavior***
* * Validates input is a JSON object
* * Creates separate message for each value in payload
* * Clones messages to prevent cross-contamination
* * Signals completion with done flag
*/

import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class JSONWalker extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Processes JSON payload by walking its structure and emitting messages
     * @param {Object} message - Contains payload to process
     * @throws {Error} If payload is invalid
     * @emits message - For each item and completion
     */
    async process(message) {

        message.done = false
        var pointer = this.getProperty(ns.trn.pointer)

        logger.debug(`JSONWalker pointer =  ${pointer}`)

        //   process.exit(1)
        var content = structuredClone(message.content)
        if (typeof content === 'string') {
            logger.debug(`content is a string, parsing to JSON`)
            content = JSON.parse(content)
        }
        message.content = {} // TODO option in config
        logger.debug(`content.length  = ${content.length}`)
        var die = this.getProperty(ns.trn.die)
        logger.debug(`die = ${die}`)
        if (die == "true") {
            //    logger.debug(`content.slice(0, 10) = ${content.slice(0, 10)}`)
            //  logger.reveal(content.slice(0, 10))
            process.exit(1)
        }
        //  for (const item of Object.values(content)) {
        for (var i = 0; i < content.length; i++) {
            const newMessage = structuredClone(message)
            newMessage.content = content[i]
            this.emit('message', newMessage)
        }

        var finalMessage = structuredClone(message)
        finalMessage.content = content[content.length - 1]

        /* this is for values - dict
        for (const item of Object.values(content)) {
            const newMessage = structuredClone(message)
            newMessage.content = {}
            newMessage.content.items = []
            newMessage.content.items.push[item]
            //   message.item = item  // TODO refactor, it's just to grab the last
            finalMessage = newMessage
            this.emit('message', newMessage)
        }
            */

        finalMessage.done = true
        this.emit('message', finalMessage)

    }
}

export default JSONWalker

================
File: src/processors/json/Restructure.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import JsonRestructurer from './JsonRestructurer.js'
import ns from '../../utils/ns.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import rdf from 'rdf-ext'

class Restructure extends Processor {
    constructor(config) {
        super(config)
    }

    async getRenames(config, settings, term) {
        // logger.log(`***** config = ${config}`)
        //logger.log(`***** settings = ${settings}`)
        //logger.log(`***** term = ${term}`)

        // const renamesRDF = GrapoiHelpers.listToArray(config, settings, term)
        // listToArray(dataset, term, property) {
        //   this.settingsNode
        const renamesRDF = GrapoiHelpers.listToArray(config, this.settingsNode, term)
        const dataset = this.config

        var renames = []
        for (let i = 0; i < renamesRDF.length; i++) {
            let rename = renamesRDF[i]
            let poi = rdf.grapoi({ dataset: dataset, term: rename })
            let pre = poi.out(ns.trn.pre).value
            let post = poi.out(ns.trn.post).value
            renames.push({ "pre": pre, "post": post })
        }
        return renames
    }

    async process(message) {
        // logger.setLogLevel('info')
        //  logger.debug('Restructure this.settings = ' + this.settings.value)
        // Extract mappings array from config
        var renames
        if (this.config.simples) {
            renames = this.config.rename
        } else {
            renames = await this.getRenames(this.config, this.settings, ns.trn.rename)
        }

        //  logger.log('Renames :')
        // logger.reveal(renames)
        //   process.exit(1)
        // Initialize JsonRestructurer with mappings
        this.restructurer = new JsonRestructurer({
            mappings: renames
        })
        try {
            logger.debug('Restructure processor executing...')

            // Get input data from message
            // const input = message.payload?.item || message.payload
            const input = structuredClone(message)

            // Perform restructuring
            const restructured = this.restructurer.restructure(input)

            const type = typeof restructured
            //   logger.debug(`typeof restructured = ${type}`) // is object... TODO need different handling for returned arrays?
            // logger.debug(`restructured = ${restructured}`)
            //    logger.reveal(restructured)

            for (const key of Object.keys(restructured)) {
                message[key] = restructured[key]
            }


            logger.debug('Restructure successful')
            return this.emit('message', message)

        } catch (err) {
            logger.error("Restructure processor error: " + err.message)
            logger.reveal(message)
            throw err
        }
    }
}

export default Restructure

================
File: src/processors/json/ValueConcat.js
================
import logger from '../../utils/Logger.js'
import rdf from 'rdf-ext'
import ns from '../../utils/ns.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import Processor from '../base/Processor.js'

class ValueConcat extends Processor {

    constructor(config) {
        super(config)
        logger.log('CREATING VALUECONCAT')
    }

}
export default ValueConcat

================
File: src/processors/markup/LinkFinder.js
================
import * as cheerio from 'cheerio'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class LinkFinder extends Processor {

    async process(message) {

        await this.extractLinks(message)

        if (data === '~~done~~') {
            logger.log('LF DONE*****************')
            return this.emitLocal('message', '~~done~~', message)
            return
        }
    }


    relocate(filename, extension) {
        const split = filename.split('.').slice(0, -1)
        return split.join('.') + extension
    }

    async extractLinks(htmlContent, message) {

        const $ = cheerio.load(htmlContent)
        let label = ''

        $('a, h1, h2, h3, h4, h5, h6').each((_, element) => {
            const tagName = element.tagName.toLowerCase()
            if (tagName.startsWith('h')) {
                const level = tagName.substring(1)
                const headerText = $(element).text()
                label = `\n\n${'#'.repeat(parseInt(level))} ${headerText}\n`
            } else if (tagName === 'a') {
                const linkText = $(element).text()
                //  logger.debug('linkText = ' + linkText)
                let href = $(element).attr('href')
                // logger.debug('href = ' + href)
                if (!href || href.startsWith('#')) return
                // Create an absolute URL if the href is relative
                if (href && !href.includes('://')) {
                    //  logger.debug('message.sourceURL = ' + message.sourceURL)
                    const baseURL = message.sourceURL
                    //  logger.debug('this.baseUrl = ' + baseURL)
                    href = new URL(href, baseURL).toString()
                }
                label = `\n[${linkText}](${href})`

            }
            message.label = label
            return this.emit('message', message)
        })
    }
}

export default LinkFinder

================
File: src/processors/markup/MarkdownToHTML.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
// import { parse } from 'marked'
import { marked } from 'marked'

// marked extensions
import markedFootnote from 'marked-footnote'
import markedCodeFormat from 'marked-code-format'
// import customHeadingId from "marked-custom-heading-id";

class MarkdownToHTML extends Processor {


    async process(message) {
        logger.debug(`\n\nMarkdownToHTML.process`)
        logger.reveal(message)
        var input
        if (message.contentBlocks) { // using templating
            input = message.contentBlocks.content
        } else { // default
            input = message.content
        }


        // new Marked()
        message.content = await
            marked
                //                .use(customHeadingId())
                .use(markedFootnote())
                .use(
                    markedCodeFormat({
                        /* Prettier options */
                    })
                )
                .parse(input.toString())

        return this.emit('message', message)
    }
}

export default MarkdownToHTML

================
File: src/processors/markup/MarkupProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import MetadataExtractor from './MetadataExtractor.js'
import LinkFinder from './LinkFinder.js'
import MarkdownToHTML from './MarkdownToHTML.js'

class MarkupProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.MetadataExtractor)) {
            return new MetadataExtractor(config)
        }
        if (type.equals(ns.trn.MarkdownToHTML)) {
            return new MarkdownToHTML(config)
        }
        if (type.equals(ns.trn.LinkFinder)) {
            return new LinkFinder(config)
        }
        return false
    }
}

export default MarkupProcessorsFactory

================
File: src/processors/markup/MetadataExtractor.js
================
import * as cheerio from 'cheerio'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class MetadataExtractor extends Processor {

    async process(message) {
        const filename = data.filename
        const content = data.content

        logger.debug("MetadataExtractor input file : " + filename)
        const targetFilename = this.relocate(filename)
        logger.debug("MetadataExtractor outputfile : " + targetFilename)

        const jsonData = this.convertEmailToJSON(content)

        const jsonString = JSON.stringify(jsonData)

        const output = { filename: targetFilename, content: jsonString }

        return this.emit('message', output, message)
    }

    relocate(filename) {
        //   var newFileName = filename.replace(/\. \w+$/, '.json')
        const split = filename.split('.').slice(0, -1)
        var newFileName = split.join('.') + '.json'
        return newFileName
    }

    convertEmailToJSON(htmlContent) {
        const $ = cheerio.load(htmlContent)
        var subjectLine = $('H1').text().trim()
        var fromName = $('B').first().text().trim()
        var nextMessageLink = $('LINK[REL="Next"]').attr('HREF')
        var previousMessageLink = $('LINK[REL="Previous"]').attr('HREF')
        var messageText = $('PRE').text().trim()
        messageText = this.pruneContent(messageText)
        const jsonResult = {
            subjectLine: subjectLine,
            fromName: fromName,
            nextMessageLink: nextMessageLink,
            previousMessageLink: previousMessageLink,
            messageText: messageText

        }

        /*
                const jsonResult = {
                    subject: $('H1').text().trim(),
                    from: $('B').first().text().trim(),
                    'next-message': $('LINK[REL="Next"]').attr('HREF'),
                    'previous-message': $('LINK[REL="Previous"]').attr('HREF'),
                    'message-text': $('PRE').text().trim()
                };
                */

        /*
        + ' ' + $('A').first().attr('href').match(/mailto:(.+\?)/)[1].replace('?Subject=', ' '),
            cc: '', // The sample does not contain a CC field to extract
        // Removing parameters from email address in 'from' field
        jsonResult.from = jsonResult.from.split('?')[0];

        //    'in-reply-to': $('LINK[REL="made"]').attr('HREF').match(/In-Reply-To=(.*)/)[1],
        */
        /*
        :\n\n>
        */

        return jsonResult
    }

    pruneContent(content) {
        // "keep this\nremove this\n\n>: keep this";
        const regex1 = /(^|\n).*?:\n>/s
        content = content.replace(regex1, '$1')

        const regex2 = /\n>.*?\n/g

        //   const inputString = "keep before\n>remove this\nkeep after";
        //   const cleanedString = inputString.replace(regex2, '\n');
        //   console.log(cleanedString);
        content = content.replace(regex2, '\n')
        //  content = (content + '\n').replace(regex2, '\n').trim();
        return content
    }
}



export default MetadataExtractor

================
File: src/processors/mcp/McpClient.js
================
import logger from "../../utils/Logger.js" // path will likely change
import Processor from "../base/Processor.js" // maybe more specific

/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 */
class McpClient extends Processor {
  /**
   * Constructs a new ProcessorExample instance.
   * @param {Object} config - The configuration object.
   */
  constructor(config) {
    super(config)
  }

  /**
   * Does something with the message and emits a 'message' event with the processed message.
   * @param {Object} message - The message object.
   */
  async process(message) {
    // logger.setLogLevel("debug")

    // processing goes here
    return this.emit("message", message)
  }
}

export default McpClient

================
File: src/processors/mcp/McpProcessorsFactory.js
================
import logger from "../../utils/Logger.js";
import ns from "../../utils/ns.js";

import ProcessorTemplate from "./McpClient.js";

// ref needed in transmissions/src/processors/base/AbstractProcessorFactory.js

class ProcessorsFactoryTemplate {
  static createProcessor(type, config) {
    if (type.equals(ns.trn.ProcessorTemplate)) {
      return new ProcessorTemplate(config);
    }

    return false;
  }
}
export default ProcessorsFactoryTemplate;

================
File: src/processors/mcp/McpServer.js
================
import logger from "../../utils/Logger.js" // path will likely change
import Processor from "../base/Processor.js" // maybe more specific

/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 */
class McpServer extends Processor {
  /**
   * Constructs a new ProcessorExample instance.
   * @param {Object} config - The configuration object.
   */
  constructor(config) {
    super(config)
  }

  /**
   * Does something with the message and emits a 'message' event with the processed message.
   * @param {Object} message - The message object.
   */
  async process(message) {
    //  logger.setLogLevel("debug")

    // processing goes here
    return this.emit("message", message)
  }
}

export default McpServer

================
File: src/processors/postcraft/AtomFeedPrep.js
================
import fs from 'fs/promises';
import path from 'path';
import Processor from '../base/Processor.js';
import logger from '../../utils/Logger.js';

class AtomFeedPrep extends Processor {
    constructor(config) {
        super(config);
    }

    async process(message) {
        //  logger.setLogLevel('debug')
        const entries = message.slugs || [];
        const siteUrl = message.site?.url || 'https://danny.ayers.name';

        if (message.targetPath) {
            message.templateFilename = path.join(message.targetPath, message.atomFeed.templateFilename)
        } else {
            message.templateFilename = path.join(message.rootDir, message.atomFeed.templateFilename)
        }

        const feed = {
            title: message.site?.title || "Danny Ayers' Blog",
            subtitle: message.site?.subtitle || '',
            updated: new Date().toISOString(),
            id: siteUrl,
            link: siteUrl,
            author: {
                name: "Danny Ayers",
                email: "danny.ayers@gmail.com"
            },
            entries: []
        };

        // Get same number of entries as front page
        const entryCount = Math.min(5, entries.length);
        const rangeStart = entries.length - entryCount;
        const rangeEnd = entries.length - 1;

        for (let i = rangeEnd; i >= rangeStart; i--) {
            const slug = entries[i];
            if (slug) {
                let filePath;
                if (message.targetPath) {
                    filePath = path.join(message.targetPath, message.entryContentMeta.targetDir, slug + '.html');
                } else {
                    filePath = path.join(message.rootDir, message.entryContentMeta.targetDir, slug + '.html');
                }

                const entry = {
                    title: `Entry ${slug}`, // TODO: Extract real title
                    id: `${siteUrl}/entries/${slug}.html`,
                    link: `${siteUrl}/entries/${slug}.html`,
                    updated: message.contentBlocks?.updated || new Date().toISOString(),
                    content: await this.getEntryContent(filePath)
                };

                feed.entries.push(entry);
            }
        }

        message.contentBlocks = feed;
        message.filepath = path.join(message.targetPath || message.rootDir, 'public/home/atom.xml');

        return this.emit('message', message);
    }

    async getEntryContent(filePath) {
        try {
            return await fs.readFile(filePath, 'utf8');
        } catch (error) {
            logger.error(`Error reading entry file ${filePath}: ${error}`);
            return '';
        }
    }
}

export default AtomFeedPrep;

================
File: src/processors/postcraft/EntryContentToPagePrep.js
================
import path from 'path'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class EntryContentToPagePrep extends Processor {

  constructor(config) {
    super(config)
  }

  async process(message) {
    if (message.done) {
      return this.emit('message', message)
      return
    }
    //  logger.setLogLevel('debug')

    // logger.reveal(message)

    /*
        if (message.targetPath) {
          message.templateFilename = path.join(message.targetPath, message.entryContentToPage.templateFilename)
        } else {
          message.templateFilename = path.join(message.rootDir, message.entryContentToPage.templateFilename)
        }

        logger.log("################ message.templateFilename = " + message.templateFilename)

        message.template = false // ???????????
    */
    message.contentBlocks.content = message.content
    //logger.reveal(message)

    /*
    if (path.isAbsolute(message.targetDir)) {
      message.filepath = path.join(message.targetDir, message.slug + '.html')
    } else {
      if (message.targetPath) {
        message.filepath = path.join(message.targetPath, message.targetDir, message.slug + '.html')
      } else {
        message.filepath = path.join(message.rootDir, message.targetDir, message.slug + '.html')
      }
    }
      */
    message.filepath = path.join(message.contentGroup.PostPages.targetDir, message.slug + '.html')
    logger.debug('EntryContentToPagePrep, message.filepath = ' + message.filepath)

    this.emit('message', message)
  }

}

export default EntryContentToPagePrep

================
File: src/processors/postcraft/FrontPagePrep.js
================
// src/processors/postcraft/FrontPagePrep.js

import path from 'path'
import { readFile } from 'node:fs/promises'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'


class FrontPagePrep extends Processor {
  constructor(config) {
    super(config)
  }


  async process(message) {
    //  logger.setLogLevel('debug')
    //   logger.reveal(message)
    /*
    if (message.targetPath) {
      message.templateFilename = path.join(message.targetPath, message.indexPage.templateFilename)
    } else {
      message.templateFilename = path.join(message.rootDir, message.indexPage.templateFilename)
    }

    logger.debug('FrontPagePrep, Template = ' + message.templateFilename)
*/

    const rawEntryPaths = this.resolveRawEntryPaths(message)
    message.content = ''

    // TODO tidy up //
    const entryCount = Math.min(5, rawEntryPaths.length) // Limit to 5 entries or less
    logger.debug('FrontPagePrep, entryCount = ' + entryCount)

    const rangeStart = rawEntryPaths.length - entryCount
    const rangeEnd = rawEntryPaths.length - 1
    //     for (let i = 0; i < entryCount; i++) {
    for (let i = rangeEnd; i >= rangeStart; i--) {
      logger.debug('FrontPagePrep, i = ' + entryCount)
      const rawEntryPath = rawEntryPaths[i]
      if (rawEntryPath) {
        message.content += await readFile(rawEntryPath, 'utf8')
      } else {
        logger.warn(`Skipping undefined entry path at index ${i}`)
      }
    }

    message.contentBlocks.content = message.content

    if (message.targetPath) {
      message.filepath = path.join(message.targetPath, message.indexPage.filepath)
    } else {
      message.filepath = path.join(message.rootDir, message.indexPage.filepath)
    }
    return this.emit('message', message)

  }

  //
  resolveRawEntryPaths(message) {
    const paths = []
    const slugs = message.slugs || []
    const entryCount = slugs.length

    for (let i = 0; i < entryCount; i++) {
      const slug = slugs[i]
      if (slug) {
        //   const path = message.rootDir + '/' + message.entryContentMeta.targetDir + '/' + slug + '.html'
        let filePath
        /*
        if (message.targetPath) {
          filePath = path.join(message.targetPath, message.entryContentMeta.targetDir, slug + '.html')
        } else {
          filePath = path.join(message.rootDir, message.entryContentMeta.targetDir, slug + '.html')
        }
          */
        filePath = path.join(message.targetPath, slug + '.html')
        paths.push(filePath)
      }
    }

    return paths
  }
}

export default FrontPagePrep

================
File: src/processors/postcraft/PostcraftDispatcher.js
================
//// UNUSED

import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

/**
 * A class that represents the PostcraftDispatcher processor.
* #### __*Input*__
* **data** : any
* **message** : needs dataset
* #### __*Output*__
* **data** : templateFilename
* **message** : adds sourceDir, targetDir, templateFilename
* @extends Processor
*/
class PostcraftDispatcher extends Processor {

  /**
   * Creates an instance of PostcraftDispatcher.
   * @param {Object} config - The configuration object.
   */
  constructor(config) {
    super(config)
  }

  /**
   * Executes the PostcraftDispatcher processor.
   * @param {Object} data - The data object.
   * @param {Object} message - The message object.
   */
  async process(message) {
    //  logger.setLogLevel('debug')
    const postcraftConfig = message.dataset
    message.template = data.toString()
    logger.debug('PostcraftDispatcherPostcraftDispatcherPostcraftDispatcher ' + data)
    process.exit(0)
    const poi = grapoi({ dataset: postcraftConfig })

    for (const q of poi.out(ns.rdf.type).quads()) {
      if (q.object.equals(ns.trn.ContentGroup)) {
        await this.processContentGroup(message, q.subject)
      }
    }
  }

  /**
   * Processes a content group.
   * @param {Object} message - The message object.
   * @param {string} contentGroupID - The ID of the content group.
   */
  async processContentGroup(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })
    const sourceDir = groupPoi.out(ns.trn.sourceDirectory).term.value
    const targetDir = groupPoi.out(ns.trn.targetDirectory).term.value
    const templateFilename = groupPoi.out(ns.trn.template).term.value

    // logger.log('sourceDir = ' + sourceDir)
    // logger.log('targetDir = ' + targetDir)
    // logger.log('templateFilename  = ' + templateFilename)

    message.sourceDir = sourceDir
    message.targetDir = targetDir
    message.templateFilename = templateFilename
    message.loadContext = 'template'

    return this.emit('message', sourceDir, message)
  }
}

export default PostcraftDispatcher

================
File: src/processors/postcraft/PostcraftPrep.js
================
import path from 'path'
import logger from '../../utils/Logger.js'

import Processor from '../base/Processor.js'

class PostcraftPrep extends Processor {

  constructor(config) {
    super(config)
  }

  async process(message) {
    //  logger.setLogLevel("debug")

    if (message.done) {
      return this.emit('message', message)
    }
    message.slug = this.extractSlug(message)
    message.targetFilename = this.extractTargetFilename(message)
    message.contentBlocks = {}
    message.contentBlocks.relURL = this.extractRelURL(message)

    // TODO generalise - use path.join
    message.contentBlocks.link = 'entries/' + message.contentBlocks.relURL

    message.contentBlocks.title = this.extractTitle(message)

    const { created, updated } = this.extractDates(message)
    message.contentBlocks.created = created
    message.contentBlocks.updated = updated

    return this.emit('message', message)
  }

  // TODO lots of tidying up
  extractSlug(message) { // TODO move this into a utils file - is also in DirWalker

    var slug = message.filename
    // logger.reveal(message)
    if (slug.includes('.')) {
      slug = slug.substr(0, slug.lastIndexOf("."))
    }
    return slug
  }

  extractTargetFilename(message) {


    /*
    if (message.targetPath) {
      return path.join(message.targetPath, message.entryContentMeta.targetDir, this.extractSlug(message) + '.html')
    } else {
      return path.join(message.rootDir, message.entryContentMeta.targetDir, this.extractSlug(message) + '.html')
    }
*/
    logger.reveal(message)

    /*
    if (message.targetPath) {
      return path.join(message.targetPath, message.targetDir, this.extractSlug(message) + '.html')
    } else {
      return path.join(message.rootDir, message.targetDir, this.extractSlug(message) + '.html')
    }
      */
    return path.join(message.contentGroup.PostPages.targetDir, this.extractSlug(message) + '.html')
  }

  extractRelURL(message) { // TODO refactor
    return this.extractSlug(message) + '.html'
  }

  extractDates(message) {
    const today = (new Date()).toISOString().split('T')[0]
    const dates = { created: today, updated: today }

    //  eg. 2024-04-19_hello-postcraft.md
    const nonExt = message.filename.split('.').slice(0, -1).join()
    const shreds = nonExt.split('_')
    if (Date.parse(shreds[0])) { // filename version is not NaN
      dates.created = shreds[0]
    }
    return dates
  }

  // first heading in the markdown
  // or formatted from filename
  // or raw filename
  extractTitle(message) {
    let title = 'Title'
    let match = message.content.toString().match(/^#(.*)$/m)
    let contentTitle = match ? match[1].trim() : null
    if (contentTitle) {
      title = contentTitle.replaceAll('#', '') // TODO make nicer
      return title
    }

    // derive from filename
    // eg. 2024-04-19_hello-postcraft.md
    try {
      const nonExt = message.filename.split('.').slice(0, -1).join()
      const shreds = nonExt.split('_')

      // let title = shreds[1] // fallback, get it from filename
      title = shreds[1].split('-') // split the string into words
        .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // capitalize the first letter of each word
        .join(' ') // join the words back together with spaces
    } catch (err) {
      title = message.filename
    }
    return title
  }
}

export default PostcraftPrep

================
File: src/processors/postcraft/PostcraftProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import PostcraftDispatcher from './PostcraftDispatcher.js'
import PostcraftPrep from './PostcraftPrep.js'
import EntryContentToPagePrep from './EntryContentToPagePrep.js'
import FrontPagePrep from './FrontPagePrep.js'
import AtomFeedPrep from './AtomFeedPrep.js'

class PostcraftProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.PostcraftDispatcher)) {
            return new PostcraftDispatcher(config)
        }
        if (type.equals(ns.trn.PostcraftPrep)) {
            return new PostcraftPrep(config)
        }
        if (type.equals(ns.trn.EntryContentToPagePrep)) {
            return new EntryContentToPagePrep(config)
        }
        if (type.equals(ns.trn.FrontPagePrep)) {
            return new FrontPagePrep(config)
        }
        if (type.equals(ns.trn.AtomFeedPrep)) {
            return new AtomFeedPrep(config)
        }
        return false
    }
}

export default PostcraftProcessorsFactory

================
File: src/processors/protocols/HttpGet.js
================
// src/processors/http/HttpGet.js
/**
 * @class HttpGet
 * @extends Processor
 * @classdesc
 * **A Transmissions Processor**
 *
 * Retrieves content from HTTP URLs using GET requests.
 *
 * ### Processor Signature
 *
 * #### ***Input***
 * ***`url`** - The HTTP URL to fetch content from
 * ***`message`** - A message object that will be enriched with response data
 *
 * #### ***Output***
 * ***`message`** - Original message with added sourceURL property
 * ***`content`** - The retrieved content from the URL
 *
 * #### ***Behavior***
 * * Fetches content from specified HTTP URL
 * * Adds source URL to message object
 * * Handles special '~~done~~' URL marker
 * * Emits retrieved content along with enriched message
 * * Logs detailed debug information during operation
 */

import axios from 'axios'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class HttpGet extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Processes an HTTP GET request for the given URL
     * @param {string} url - Target URL to fetch
     * @param {Object} message - Message object to enrich with response data
     * @emits message - Emits retrieved content and enriched message
     */
    async process(url, message) {
        //   logger.setLogLevel('debug')
        logger.debug('HttpGet, url = ' + url)
        if (url === '~~done~~') {
            logger.log('HG DONE*****************')
            return this.emit('message', url, message)
            return
        }
        try {
            logger.log('HG GETTING*****************')
            const response = await axios.get(url)
            const content = response.data

            message.sourceURL = url
            return this.emit('message', content, message)
        } catch (error) {
            logger.error("HttpGet.execute error\n" + error)
        }
    }
}

export default HttpGet

================
File: src/processors/protocols/ProtocolsProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import HttpGet from './HttpGet.js'



class ProtocolsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.HttpGet)) {
            return new HttpGet(config)
        }

        return false
    }
}

export default ProtocolsProcessorsFactory

================
File: src/processors/rdf/__ConfigMap.js
================
// src/processors/rdf/ConfigMap.js
/**
 * @class ConfigMap
 * @extends Processor
 * @classdesc
 * **a Transmissions Processor**
 *
 * Maps RDF dataset contents to key-value pairs in the message object based on config.ttl
 *
 * ### Signature
 *
 * #### __*Input*__
 * * **`message.dataset`** - RDF dataset containing configuration
 *
 * #### __*Output*__
 * * **`message`** - Updated with mapped key-value pairs based on the dataset content
 *
 * #### __*Behavior*__
 * * Processes the RDF dataset in the message
 * * Identifies and processes different content groups (PostContent, PostPages, IndexPage)
 * * Maps relevant information to specific message properties
 *
 * #### __Tests__
 * * TODO: Add test information
 */

import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ConfigMap extends Processor {
  constructor(config) {
    super(config)
  }

  /**
   * Executes the ConfigMap processor
   * @param {Object} message - The message object containing the dataset
   * @todo Refactor for better generalization and maintainability
   */
  async process(message) {
    //  logger.setLogLevel('debug')

    logger.debug(`ConfigMap, Using settings ${this.settings.value}`)

    const group = this.getPropertyFromMyConfig(ns.trn.group)
    const targetGroup = rdf.namedNode(group)
    logger.debug(`ConfigMap, group =  ${targetGroup}`)

    // source = path.join(message.rootDir, source);

    this.preProcess(message)
    const dataset = message.dataset
    const poi = grapoi({ dataset, factory: rdf })
    const quads = await poi.out(ns.rdf.type).quads()

    for (const q of quads) {
      const type = q.object
      //   logger.debug('type = ' + type.value)
      // logger.debug('targetGroup = ' + targetGroup)
      if (type.equals(targetGroup)) {
        //          if (type.equals(ns.trn.ContentGroup)) {
        await this.processContentGroup(message, q.subject)
      }
    }

    return this.emit('message', message)
  }

  /**
   * Processes a content group based on its type
   * @param {Object} message - The message object
   * @param {Object} contentGroupID - The ID of the content group
   */
  async processContentGroup(message, contentGroupID) {
    logger.debug('contentGroupID = ' + contentGroupID.value)
    switch (contentGroupID.value) {
      case ns.trn.PostContent.value:
        await this.markdownToEntryContent(message, contentGroupID)
        break
      case ns.trn.PostPages.value:
        await this.entryContentToPostPage(message, contentGroupID)
        break
      case ns.trn.IndexPage.value:
        await this.indexPage(message, contentGroupID)
        break
      case ns.trn.AtomFeed.value:
        await this.atomFeed(message, contentGroupID)
        break
      default:
        logger.log('Group not found in dataset: ' + contentGroupID.value)
    }
  }

  /**
   * Processes markdown to entry content
   * @param {Object} message - The message object
   * @param {Object} contentGroupID - The ID of the content group
   */
  async markdownToEntryContent(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })

    // message.location = groupPoi.out(ns.trn.location).term.value
    // message.subdir = groupPoi.out(ns.trn.subdir).term.value
    message.filepath = groupPoi.out(ns.trn.template).term.value
    message.template = '§§§ placeholer for debugging §§§'

    message.entryContentMeta = {
      sourceDir: groupPoi.out(ns.trn.sourceDirectory).term.value,
      targetDir: groupPoi.out(ns.trn.targetDirectory).term.value,
      templateFilename: groupPoi.out(ns.trn.template).term.value
    }
  }

  /**
   * Processes entry content to post page
   * @param {Object} message - The message object
   * @param {Object} contentGroupID - The ID of the content group
   */
  async entryContentToPostPage(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })

    message.entryContentToPage = {
      targetDir: groupPoi.out(ns.trn.targetDirectory).term.value,
      templateFilename: groupPoi.out(ns.trn.template).term.value
    }
  }

  /**
   * Processes index page
   * @param {Object} message - The message object
   * @param {Object} contentGroupID - The ID of the content group
   */
  async indexPage(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })

    message.indexPage = {
      filepath: groupPoi.out(ns.trn.filepath).term.value,
      templateFilename: groupPoi.out(ns.trn.template).term.value
    }
  }

  /**
 * Processes feed page
 * @param {Object} message - The message object
 * @param {Object} contentGroupID - The ID of the content group
 */
  async atomFeed(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })

    message.atomFeed = {
      filepath: groupPoi.out(ns.trn.filepath).term.value,
      templateFilename: groupPoi.out(ns.trn.template).term.value
    }
  }
}

export default ConfigMap

================
File: src/processors/rdf/ConfigMap.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ConfigMap extends Processor {
  constructor(config) {
    super(config)
  }

  async process(message) {
    // logger.setLogLevel('debug')

    /*
     if (!message.dataset) {
       logger.warn('No dataset provided')
       return this.emit('message', message)
     }
 */
    logger.debug(`ConfigMap.process`)
    this.showMyConfig()

    const basePath = message.targetPath || message.rootDir
    logger.debug(`ConfigMap using base path: ${basePath}`)

    const dataset = message.dataset
    const poi = grapoi({ dataset })

    // Find ConfigSet instances
    for (const quad of poi.out(ns.rdf.type, ns.trn.ConfigSet).quads()) {
      const groupID = quad.subject

      let groupName = ns.getShortname(groupID.value)
      //   let type = ns.getShortname(processorType.value)
      logger.debug(`*** groupName = ${groupName} `)
      // *** groupID.value = http://hyperdata.it/transmissions/AtomFeed

      const groupPoi = grapoi({ dataset, term: groupID })

      if (!message.contentGroup) message.contentGroup = {}
      // Extract paths
      if (groupPoi.out(ns.trn.sourceDirectory).term) {
        let sourceDir = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.sourceDirectory).term.value)

        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].sourceDir = sourceDir
      }

      if (groupPoi.out(ns.trn.targetDirectory).term) {
        let targetDir = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.targetDirectory).term.value
        )
        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].targetDir = targetDir
      }

      if (groupPoi.out(ns.trn.template).term) {
        let templateFile = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.template).term.value
        )
        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].templateFile = templateFile
      }

      /*
logger.debug(`Resolved :
  groupName: ${groupName}
  sourceDir: ${sourceDir}
  targetDir: ${targetDir}
  templateFile: ${templateFile}`)


message.contentGroup[groupName] =
{ "sourceDir": sourceDir, "targetDir": targetDir, "templateFile": templateFile }
*/
      //  logger.reveal(message)
    }
    // process.exit()

    return this.emit('message', message)
  }

  resolvePath(basePath, relativePath) {
    if (!basePath || !relativePath) {
      throw new Error('Base path and relative path required')
    }

    const resolved = path.isAbsolute(relativePath)
      ? relativePath
      : path.join(basePath, relativePath)

    return path.normalize(resolved)
  }
}

export default ConfigMap

================
File: src/processors/rdf/DatasetReader.js
================
import path from 'path';
import rdf from 'rdf-ext';
import { fromFile } from 'rdf-utils-fs';
import ns from '../../utils/ns.js';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';

class DatasetReader extends Processor {
    constructor(config) {
        super(config);
    }

    async process(message) {
        try {
            const datasetFile = this.getPropertyFromMyConfig(ns.trn.datasetFile);
            const datasetPath = path.join(message.rootDir, datasetFile);

            logger.debug(`Reading dataset from ${datasetPath}`);
            const stream = fromFile(datasetPath);
            message.dataset = await rdf.dataset().import(stream);

            if (message.dataset.size === 0) {
                logger.warn('Empty dataset loaded');
            } else {
                logger.debug(`Loaded dataset with ${message.dataset.size} quads`);
            }

            return this.emit('message', message);
        } catch (err) {
            logger.error('Failed to read dataset:', err);
            throw err;
        }
    }
}

export default DatasetReader;

================
File: src/processors/rdf/RDFConfig.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class RDFConfig extends Processor {
  constructor(config) {
    super(config)
    this.configMap = new Map()
  }

  async process(message) {
    if (!message.dataset) {
      throw new Error('No RDF dataset provided')
    }

    const dataset = message.dataset
    const poi = grapoi({ dataset })

    // Find all ConfigGroup instances
    for (const configGroup of poi.out(ns.rdf.type, ns.trn.ConfigGroup).terms) {
      const groupPoi = grapoi({ dataset, term: configGroup })

      // Extract property mappings
      const mappings = {}
      for (const quad of groupPoi.quads()) {
        if (!quad.predicate.equals(ns.rdf.type)) {
          mappings[quad.predicate.value] = this.resolveValue(quad.object)
        }
      }

      this.configMap.set(configGroup.value, mappings)
      message.configMap = this.configMap
    }

    // Apply configuration patterns
    if (message.configPatterns) {
      for (const pattern of message.configPatterns) {
        const config = this.configMap.get(pattern)
        if (config) {
          Object.assign(message, config)
        }
      }
    }

    return this.emit('message', message)
  }

  resolveValue(term) {
    // Handle different RDF term types
    if (term.termType === 'NamedNode') {
      return term.value
    } else if (term.termType === 'Literal') {
      const value = term.value
      // Convert numeric literals
      return isNaN(value) ? value : Number(value)
    }
    return term.value
  }

  getConfig(groupId) {
    return this.configMap.get(groupId)
  }
}

export default RDFConfig

================
File: src/processors/rdf/RDFProcessorsFactory.js
================
import ns from '../../utils/ns.js'
import DatasetReader from './DatasetReader.js'
import ConfigMap from './ConfigMap.js'
import RDFConfig from './RDFConfig.js'

class RDFProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.DatasetReader)) {
            return new DatasetReader(config)
        }
        if (type.equals(ns.trn.ConfigMap)) {
            return new ConfigMap(config)
        }
        if (type.equals(ns.trn.RDFConfig)) {
            return new RDFConfig(config)
        }
        return false
    }
}

export default RDFProcessorsFactory

================
File: src/processors/sparql/component-interaction.mermaid
================
sequenceDiagram
    participant C as Client
    participant V as Validator
    participant T as Template Engine
    participant U as TextUtils
    participant L as LanguageConfig
    
    C->>V: validate(message)
    activate V
    V->>L: checkLanguageTags()
    V->>U: validateURLs()
    V-->>C: ValidationResult
    deactivate V
    
    alt validation passed
        C->>T: render(message)
        activate T
        T->>U: escapeStringLiteral()
        T->>L: getLanguageConfig()
        T->>U: escapeIRI()
        T-->>C: turtleRDF
        deactivate T
    else validation failed
        C->>C: handleError()
    end

================
File: src/processors/sparql/config.js
================
// config.js
export const config = {
    baseUrl: 'http://example.com',
    requiredFields: ['slug', 'title'],
    dateFormat: 'YYYY-MM-DDThh:mm:ssZ',
    
    setBaseUrl(url) {
        if (!url.startsWith('http')) {
            throw new Error('Base URL must start with http(s)');
        }
        this.baseUrl = url;
    }
};

================
File: src/processors/sparql/custom-predicates.js
================
// customPredicates.js
export const customPredicates = {
    validate(predicate, value) {
        if (!this[predicate]) {
            throw new Error(`Unknown predicate: ${predicate}`);
        }
        return this[predicate].validate(value);
    },
    
    format(predicate, value) {
        return this[predicate].format(value);
    },
    
    category: {
        validate: value => typeof value === 'string' && value.length > 0,
        format: value => `schema:category "${value}"`
    },
    
    keywords: {
        validate: value => Array.isArray(value) && value.every(v => typeof v === 'string'),
        format: value => value.map(keyword => `schema:keywords "${keyword}"`).join(' ; ')
    },
    
    license: {
        validate: value => typeof value === 'string' && value.startsWith('http'),
        format: value => `schema:license <${value}>`
    }
}

================
File: src/processors/sparql/handover-doc (1).md
================
# RDF Turtle Template System

## System Overview

A templating system for generating RDF Turtle syntax from JavaScript objects, with support for multilingual content, custom predicates, and configurable validation rules.

### System Architecture
The system follows a modular architecture with clear separation of concerns:

![System Architecture](system-architecture)

### Processing Flow
Message processing follows a strict validation and transformation pipeline:

![Message Processing Flow](message-processing-flow)

### Component Interactions
Components interact through well-defined interfaces:

![Component Interaction Sequence](component-interaction)

### Language Processing
Multilingual content follows a deterministic processing flow:

![Language Processing Flow](language-processing)

### Core Components

1. **Template Engine**: Nunjucks-based template for RDF generation
2. **TextUtils**: String manipulation and escaping utilities
3. **Validator**: Input validation and sanitization
4. **Configuration**: System-wide settings management
5. **Language Handling**: BCP47 language tag support

## Architecture

### Module Structure

```
src/
├── templates/
│   └── turtle.njk         # Main Nunjucks template
├── lib/
│   ├── TextUtils.js       # Text processing utilities
│   ├── Validator.js       # Validation logic
│   ├── Config.js          # Configuration management
│   └── CustomPredicates.js # Custom RDF predicate handling
└── config/
    └── languageConfig.js  # Language-specific settings
```

## Implementation Details

### Data Model

Input messages follow this structure:

```javascript
interface Message {
    slug: string;
    title: string | LocalizedString;
    content: string | LocalizedString;
    summary?: string | LocalizedString;
    datePublished?: string;  // ISO 8601
    dateModified?: string;   // ISO 8601
    author?: Author;
    translations?: Translations;
    customProperties?: CustomProperties;
}

interface LocalizedString {
    value: string;
    lang: string;  // BCP47 language tag
}

interface Author {
    name: string;
    homepage?: string;
    nick?: string;
}

interface Translations {
    [field: string]: {
        [lang: string]: string;
    };
}
```

### Usage Examples

#### Basic Usage

```javascript
import { MessageValidator } from './lib/Validator';
import { config } from './lib/Config';
import nunjucks from 'nunjucks';

const message = {
    slug: 'example-post',
    title: {
        value: 'Example Post',
        lang: 'en'
    },
    content: 'Post content',
    author: {
        name: 'John Doe',
        homepage: 'https://example.com/john'
    }
};

// Validate input
const validation = MessageValidator.validate(message);
if (!validation.isValid) {
    throw new Error(`Invalid message: ${validation.errors.join(', ')}`);
}

// Generate Turtle
const turtle = nunjucks.render('turtle.njk', { message });
```

#### Multilingual Content

```javascript
const multilingualMessage = {
    slug: 'multilingual-post',
    title: {
        value: 'Hello World',
        lang: 'en'
    },
    translations: {
        title: {
            'es': 'Hola Mundo',
            'fr': 'Bonjour le Monde'
        },
        content: {
            'es': 'Contenido del post',
            'fr': 'Contenu du post'
        }
    }
};
```

#### Custom Predicates

```javascript
// Adding custom predicates
import { customPredicates } from './lib/CustomPredicates';

customPredicates.category = {
    validate: value => typeof value === 'string' && value.length > 0,
    format: value => `schema:category "${value}"`
};

const messageWithCustom = {
    // ... basic fields ...
    customProperties: {
        category: 'Technology'
    }
};
```

## Validation Rules

### Required Fields
- slug
- title
- content

### Field-Specific Validation

```javascript
const validationRules = {
    slug: {
        pattern: /^[a-z0-9-]+$/,
        maxLength: 100
    },
    datePublished: {
        format: 'ISO8601',
        required: false
    },
    author: {
        type: 'object',
        properties: {
            name: { required: true },
            homepage: { type: 'url', required: false }
        }
    }
};
```

## Language Handling

### Configuration

```javascript
// languageConfig.js
export const languageConfig = {
    defaultLanguage: 'en',
    supportedLanguages: ['en', 'es', 'fr', 'de'],
    languageFields: {
        title: ['en', 'es', 'fr', 'de'],
        content: ['en', 'es', 'fr']
    }
};
```

### BCP47 Validation

All language tags are validated against BCP47 specifications using the following regex:
```javascript
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
```

## Output Format

The system generates Turtle RDF following W3C specifications. Example output:

```turtle
@prefix schema: <http://schema.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://example.com/example-post> a schema:Article ;
    schema:headline "Example Post"@en ;
    schema:articleBody "Post content"@en ;
    schema:author [
        a schema:Person ;
        schema:name "John Doe" ;
        foaf:homepage <https://example.com/john>
    ] .
```

## Error Handling

Errors are handled through a structured validation system:

```javascript
interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}

// Example error handling
try {
    const validation = MessageValidator.validate(message);
    if (!validation.isValid) {
        logger.error('Validation failed:', validation.errors);
        throw new ValidationError(validation.errors);
    }
} catch (error) {
    if (error instanceof ValidationError) {
        // Handle validation errors
    } else {
        // Handle other errors
    }
}
```

## Testing

Tests are written using Jasmine. Run with:
```bash
npm test
```

Key test areas:
- Input validation
- RDF generation
- Language tag handling
- Custom predicate processing
- Error handling

## Configuration Options

System-wide settings are managed through the Config module:

```javascript
config.setBaseUrl('https://example.com');
config.setDefaultLanguage('en');
config.addRequiredField('category');
```

## Performance Considerations

- Template compilation is cached
- Language tag validation uses regex for speed
- String escaping is optimized for common cases
- Validation runs only once per message

## Known Limitations

1. No support for RDF lists
2. Limited datatype handling
3. No blank node reference support
4. Single-document processing only

## Future Enhancements

1. Graph merging support
2. Extended datatype handling
3. Streaming processing for large datasets
4. SHACL validation integration

## Maintenance Notes

1. Update language tags when adding new languages
2. Monitor template performance with large datasets
3. Regular validation of IRIs against service health
4. Review custom predicate implementations

## Dependencies

- nunjucks: ^3.2.0
- loglevel: ^1.8.0
- validator: ^13.7.0

================
File: src/processors/sparql/handover-doc.md
================
# RDF Turtle Template System

## System Overview

A templating system for generating RDF Turtle syntax from JavaScript objects, with support for multilingual content, custom predicates, and configurable validation rules.

### System Architecture
The system follows a modular architecture with clear separation of concerns:

![System Architecture](system-architecture)

### Processing Flow
Message processing follows a strict validation and transformation pipeline:

![Message Processing Flow](message-processing-flow)

### Component Interactions
Components interact through well-defined interfaces:

![Component Interaction Sequence](component-interaction)

### Language Processing
Multilingual content follows a deterministic processing flow:

![Language Processing Flow](language-processing)

### Core Components

1. **Template Engine**: Nunjucks-based template for RDF generation
2. **TextUtils**: String manipulation and escaping utilities
3. **Validator**: Input validation and sanitization
4. **Configuration**: System-wide settings management
5. **Language Handling**: BCP47 language tag support

## Architecture

### Module Structure

```
src/
├── templates/
│   └── turtle.njk         # Main Nunjucks template
├── lib/
│   ├── TextUtils.js       # Text processing utilities
│   ├── Validator.js       # Validation logic
│   ├── Config.js          # Configuration management
│   └── CustomPredicates.js # Custom RDF predicate handling
└── config/
    └── languageConfig.js  # Language-specific settings
```

## Implementation Details

### Data Model

Input messages follow this structure:

```javascript
interface Message {
    slug: string;
    title: string | LocalizedString;
    content: string | LocalizedString;
    summary?: string | LocalizedString;
    datePublished?: string;  // ISO 8601
    dateModified?: string;   // ISO 8601
    author?: Author;
    translations?: Translations;
    customProperties?: CustomProperties;
}

interface LocalizedString {
    value: string;
    lang: string;  // BCP47 language tag
}

interface Author {
    name: string;
    homepage?: string;
    nick?: string;
}

interface Translations {
    [field: string]: {
        [lang: string]: string;
    };
}
```

### Usage Examples

#### Basic Usage

```javascript
import { MessageValidator } from './lib/Validator';
import { config } from './lib/Config';
import nunjucks from 'nunjucks';

const message = {
    slug: 'example-post',
    title: {
        value: 'Example Post',
        lang: 'en'
    },
    content: 'Post content',
    author: {
        name: 'John Doe',
        homepage: 'https://example.com/john'
    }
};

// Validate input
const validation = MessageValidator.validate(message);
if (!validation.isValid) {
    throw new Error(`Invalid message: ${validation.errors.join(', ')}`);
}

// Generate Turtle
const turtle = nunjucks.render('turtle.njk', { message });
```

#### Multilingual Content

```javascript
const multilingualMessage = {
    slug: 'multilingual-post',
    title: {
        value: 'Hello World',
        lang: 'en'
    },
    translations: {
        title: {
            'es': 'Hola Mundo',
            'fr': 'Bonjour le Monde'
        },
        content: {
            'es': 'Contenido del post',
            'fr': 'Contenu du post'
        }
    }
};
```

#### Custom Predicates

```javascript
// Adding custom predicates
import { customPredicates } from './lib/CustomPredicates';

customPredicates.category = {
    validate: value => typeof value === 'string' && value.length > 0,
    format: value => `schema:category "${value}"`
};

const messageWithCustom = {
    // ... basic fields ...
    customProperties: {
        category: 'Technology'
    }
};
```

## Validation Rules

### Required Fields
- slug
- title
- content

### Field-Specific Validation

```javascript
const validationRules = {
    slug: {
        pattern: /^[a-z0-9-]+$/,
        maxLength: 100
    },
    datePublished: {
        format: 'ISO8601',
        required: false
    },
    author: {
        type: 'object',
        properties: {
            name: { required: true },
            homepage: { type: 'url', required: false }
        }
    }
};
```

## Language Handling

### Configuration

```javascript
// languageConfig.js
export const languageConfig = {
    defaultLanguage: 'en',
    supportedLanguages: ['en', 'es', 'fr', 'de'],
    languageFields: {
        title: ['en', 'es', 'fr', 'de'],
        content: ['en', 'es', 'fr']
    }
};
```

### BCP47 Validation

All language tags are validated against BCP47 specifications using the following regex:
```javascript
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
```

## Output Format

The system generates Turtle RDF following W3C specifications. Example output:

```turtle
@prefix schema: <http://schema.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://example.com/example-post> a schema:Article ;
    schema:headline "Example Post"@en ;
    schema:articleBody "Post content"@en ;
    schema:author [
        a schema:Person ;
        schema:name "John Doe" ;
        foaf:homepage <https://example.com/john>
    ] .
```

## Error Handling

Errors are handled through a structured validation system:

```javascript
interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}

// Example error handling
try {
    const validation = MessageValidator.validate(message);
    if (!validation.isValid) {
        logger.error('Validation failed:', validation.errors);
        throw new ValidationError(validation.errors);
    }
} catch (error) {
    if (error instanceof ValidationError) {
        // Handle validation errors
    } else {
        // Handle other errors
    }
}
```

## Testing

Tests are written using Jasmine. Run with:
```bash
npm test
```

Key test areas:
- Input validation
- RDF generation
- Language tag handling
- Custom predicate processing
- Error handling

## Configuration Options

System-wide settings are managed through the Config module:

```javascript
config.setBaseUrl('https://example.com');
config.setDefaultLanguage('en');
config.addRequiredField('category');
```

## Performance Considerations

- Template compilation is cached
- Language tag validation uses regex for speed
- String escaping is optimized for common cases
- Validation runs only once per message

## Known Limitations

1. No support for RDF lists
2. Limited datatype handling
3. No blank node reference support
4. Single-document processing only

## Future Enhancements

1. Graph merging support
2. Extended datatype handling
3. Streaming processing for large datasets
4. SHACL validation integration

## Maintenance Notes

1. Update language tags when adding new languages
2. Monitor template performance with large datasets
3. Regular validation of IRIs against service health
4. Review custom predicate implementations

## Dependencies

- nunjucks: ^3.2.0
- loglevel: ^1.8.0
- validator: ^13.7.0

================
File: src/processors/sparql/handover-metadata.txt
================
@prefix schema: <http://schema.org/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .

<http://example.com/docs/turtle-template-system>
    a schema:TechArticle ;
    dcterms:title "RDF Turtle Template System - Technical Documentation" ;
    dcterms:created "2025-01-25T00:00:00Z"^^xsd:dateTime ;
    dcterms:description "Technical documentation for the RDF Turtle templating system including architecture, implementation details, and usage examples." ;
    schema:version "1.0" ;
    schema:keywords "RDF", "Turtle", "Template", "Multilingual", "Validation" ;
    
    schema:programmingLanguage "JavaScript" ;
    schema:codeRepository "https://example.com/repo/turtle-template" ;
    
    prov:wasDerivedFrom [
        a schema:SoftwareSourceCode ;
        schema:name "Turtle Template System" ;
        schema:programmingLanguage "JavaScript" ;
        schema:softwareVersion "1.0.0"
    ] ;
    
    dcterms:requires [
        a schema:SoftwareApplication ;
        schema:name "Node.js" ;
        schema:softwareVersion ">=14.0.0"
    ] ;
    
    schema:maintainer [
        a schema:Person ;
        schema:name "Development Team" ;
        schema:email "team@example.com"
    ] .

================
File: src/processors/sparql/language-processing.mermaid
================
flowchart LR
    Input[Input String] --> HasLang{Has Language?}
    HasLang --> |Yes| ValidLang{Valid BCP47?}
    HasLang --> |No| DefLang{Default Language?}
    
    ValidLang --> |Yes| AddTag[Add Language Tag]
    ValidLang --> |No| Error[Language Error]
    
    DefLang --> |Yes| NonLangField{Non-Language Field?}
    DefLang --> |No| Plain[Plain Literal]
    
    NonLangField --> |Yes| Plain
    NonLangField --> |No| AddDefTag[Add Default Tag]
    
    AddTag --> Escape[Escape String]
    AddDefTag --> Escape
    Plain --> Escape
    
    Escape --> Output[RDF Literal]
    
    class Input,Output borderbox
    class Error emphasis

================
File: src/processors/sparql/message-processing-flow.mermaid
================
flowchart TB
    Input[Message Input] --> Validate{Validate}
    Validate --> |Invalid| Error[Validation Error]
    Validate --> |Valid| Transform[Transform to RDF]
    
    subgraph Validation
        V1[Check Required Fields] --> V2[Validate Types]
        V2 --> V3[Check Language Tags]
        V3 --> V4[Validate URLs]
        V4 --> V5[Custom Predicates]
    end
    
    subgraph Transform
        T1[Load Template] --> T2[Process Message]
        T2 --> T3[Generate Triples]
        T3 --> T4[Format Output]
    end
    
    Transform --> Output[Turtle RDF]
    
    class Input,Output,Error borderbox
    class Validation,Transform subdomain

================
File: src/processors/sparql/SessionEnvironment.js
================
import axios from 'axios'
import nunjucks from 'nunjucks'
import fs from 'fs/promises'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

class SessionEnvironment {
    constructor(processor) {
        this.processor = processor
        this.endpoints = null
        this.templateCache = new Map()
    }

    async loadEndpoints(dir) {
        // logger.setLogLevel('debug')
        logger.debug(`SessionEnvironment.loadEndpoints dir = ${dir}`)
        const settingsPath = this.processor.getProperty(ns.trn.endpointSettings)
        logger.debug(`SessionEnvironment.loadEndpoints dir = ${dir}`)
        logger.debug(`SessionEnvironment.loadEndpoints settingsPath = ${settingsPath}`)

        if (!settingsPath) {
            throw new Error('Endpoint settings path is undefined')
        }

        const filePath = path.join(dir, settingsPath)
        logger.debug(`SessionEnvironment.loadEndpoints filePath = ${filePath}`)
        const data = await fs.readFile(filePath, 'utf8')
        this.endpoints = JSON.parse(data)
    }

    getQueryEndpoint() {
        return this.endpoints.find(e => e.type === 'query')
    }

    getUpdateEndpoint() {
        return this.endpoints.find(e => e.type === 'update')
    }

    async getTemplate(dir, templateFilename) {
        logger.setLogLevel('debug')
        logger.debug(`SessionEnvironment.getTemplate dir = ${dir}`)
        logger.debug(`SessionEnvironment.getTemplate templateFilename = ${templateFilename}`)

        const cacheKey = path.join(dir, templateFilename)

        if (this.templateCache.has(cacheKey)) {
            return this.templateCache.get(cacheKey)
        }

        const template = await fs.readFile(cacheKey, 'utf8')
        this.templateCache.set(cacheKey, template)
        logger.debug(`SessionEnvironment.getTemplate cacheKey = ${cacheKey}`)
        logger.debug(`SessionEnvironment.getTemplate template = ${template}`)
        return template
    }

    clearTemplateCache() {
        this.templateCache.clear()
    }

    // getProperty(property) {
    //   return property;
    //}

    getBasicAuthHeader(endpoint) {
        return `Basic ${Buffer.from(
            `${endpoint.credentials.user}:${endpoint.credentials.password}`
        ).toString('base64')}`
    }
}

export default SessionEnvironment

================
File: src/processors/sparql/SPARQLProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import SPARQLSelect from './SPARQLSelect.js'
import SPARQLUpdate from './SPARQLUpdate.js'

/**
 * @class SPARQLProcessorsFactory
 * @classdesc
 * **Factory for SPARQL Processors**
 *
 * Creates instances of SPARQL query and update processors.
 *
 */
class SPARQLProcessorsFactory {

    static createProcessor(type, config) {

        if (type.equals(ns.trn.SPARQLSelect)) {
            return new SPARQLSelect(config)
        }
        if (type.equals(ns.trn.SPARQLUpdate)) {
            return new SPARQLUpdate(config)
        }

        return false
    }
}
export default SPARQLProcessorsFactory

================
File: src/processors/sparql/SPARQLSelect.js
================
import axios from 'axios';
import nunjucks from 'nunjucks';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';
import SessionEnvironment from './SessionEnvironment.js';

class SPARQLSelect extends Processor {
    constructor(config) {
        super(config);
        this.env = new SessionEnvironment(this);
    }

    async process(message) {
        if (!this.env.endpoints) {
            await this.env.loadEndpoints(message.rootDir);
        }

        const endpoint = this.env.getQueryEndpoint();
        const template = await this.env.getTemplate(
            message.rootDir,
            await this.getProperty(ns.trn.templateFilename)
        );

        const queryData = {
            startDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
            ...message
        };

        const query = nunjucks.renderString(template, queryData);

        try {
            const response = await axios.post(endpoint.url, query, {
                headers: {
                    'Content-Type': 'application/sparql-query',
                    'Accept': 'application/json',
                    'Authorization': this.env.getBasicAuthHeader(endpoint)
                }
            });

            message.queryResults = response.data;
            return this.emit('message', message);
        } catch (error) {
            logger.error('SPARQL query error:', error);
            throw error;
        }
    }
}

export default SPARQLSelect;

================
File: src/processors/sparql/SPARQLUpdate.js
================
import axios from 'axios'
import nunjucks from 'nunjucks'
import crypto from 'crypto'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import SessionEnvironment from './SessionEnvironment.js'

class SPARQLUpdate extends Processor {
    constructor(config) {
        super(config)
        this.env = new SessionEnvironment(this)
    }

    async process(message) {
        logger.setLogLevel('debug')
        logger.debug(`\nSPARQLUpdate.process`)


        if (!this.env.endpoints) {
            await this.env.loadEndpoints(message.rootDir)
        }


        const endpoint = this.env.getUpdateEndpoint()
        logger.debug(`SPARQLUpdate.process endpoint = ${endpoint}`)
        const template = await this.env.getTemplate(
            message.rootDir,
            await this.getProperty(ns.trn.templateFilename)
        )
        logger.debug(`SPARQLUpdate.process template = ${template}`)

        const now = new Date().toISOString()
        const updateData = {
            id: crypto.randomUUID(),
            title: message.meta?.title || 'Untitled Post',
            content: message.content,
            published: now,
            modified: now,
            author: { // default to me!!
                name: 'Danny',
                email: 'danny.ayers@gmail.com',
                url: 'https://danny.ayers.name'
            },
            ...message
        }
        logger.setLogLevel('debug')

        logger.debug(`renderString(template = ${template}
            updateData = ${updateData})`)
        const update = nunjucks.renderString(template, updateData)

        try {
            const response = await axios.post(endpoint.url, update, {
                headers: {
                    'Content-Type': 'application/sparql-update',
                    'Authorization': this.env.getBasicAuthHeader(endpoint)
                }
            })

            message.updateStatus = response.status === 200 ? 'success' : 'error'
            message.updateResponse = response.data

            return this.emit('message', message)
        } catch (error) {
            logger.error('SPARQL update error:', error)
            throw error
        }
    }
}

export default SPARQLUpdate

================
File: src/processors/sparql/system-architecture.mermaid
================
graph TB
    subgraph Core Components
        TE[Template Engine]
        TU[TextUtils]
        VAL[Validator]
    end
    
    subgraph Configuration
        CONF[Config]
        LANG[Language Config]
        PRED[Custom Predicates]
    end
    
    subgraph Input Processing
        MSG[Message]
        VAL_RES[Validation Result]
        RDF[RDF Output]
    end
    
    MSG --> VAL
    VAL --> VAL_RES
    VAL_RES --> TE
    TE --> RDF
    
    CONF --> TE
    CONF --> VAL
    
    LANG --> TE
    LANG --> VAL
    
    PRED --> VAL
    PRED --> TE
    
    TU --> TE
    TU --> VAL
    
    classDef core fill:#f9f,stroke:#333,stroke-width:2px
    classDef config fill:#bbf,stroke:#333,stroke-width:2px
    classDef process fill:#bfb,stroke:#333,stroke-width:2px
    
    class TE,TU,VAL core
    class CONF,LANG,PRED config
    class MSG,VAL_RES,RDF process

================
File: src/processors/sparql/validator.js
================
// validator.js
import { config } from './config.js';
import { TextUtils } from './TextUtils.js';
import { customPredicates } from './customPredicates.js';

export class MessageValidator {
    static validate(message) {
        const errors = [];
        
        // Check required fields
        for (const field of config.requiredFields) {
            if (!message[field]) {
                errors.push(`Missing required field: ${field}`);
            }
        }
        
        // Validate dates
        if (message.datePublished && !TextUtils.isValidDateTime(message.datePublished)) {
            errors.push('Invalid datePublished format');
        }
        
        if (message.dateModified && !TextUtils.isValidDateTime(message.dateModified)) {
            errors.push('Invalid dateModified format');
        }
        
        // Validate URLs
        if (message.author?.homepage && !TextUtils.isValidURL(message.author.homepage)) {
            errors.push('Invalid author homepage URL');
        }
        
        // Validate custom properties
        if (message.customProperties) {
            for (const [prop, value] of Object.entries(message.customProperties)) {
                try {
                    if (!customPredicates.validate(prop, value)) {
                        errors.push(`Invalid value for custom predicate: ${prop}`);
                    }
                } catch (e) {
                    errors.push(e.message);
                }
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }
}

================
File: src/processors/staging/MarkdownFormatter.js
================
import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class MarkdownFormatter extends Processor {
    constructor(config) {
        super(config)
    }

    async process(message) {

        if (message.done) return

        // TODO move to config
        const dir = '/home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md'

        const filename = `${message.content.created_at.substring(0, 10)}_${message.content.uuid.substring(0, 3)}.md`

        message.filepath = path.join(dir, message.meta.conv_uuid.substring(0, 4), filename)
        message.content = this.extractMarkdown(message)

        return this.emit('message', message)
    }

    // https://claude.ai/chat/be3ae4a9-51cd-42f6-a903-3193af00fed8

    extractMarkdown(message) {
        // TODO move to config
        const urlBase = 'https://claude.ai/chat/'

        const lines = []
        lines.push(`# [${message.meta.conv_name}](${urlBase}${message.meta.conv_uuid})\n`)
        //   lines.push(`${message.meta.conv_uuid}\n`)
        lines.push(`${message.content.uuid}\n`)
        // lines.push('')
        lines.push(message.content.text)
        lines.push('\n---\n')

        for (const [key, value] of Object.entries(message)) {
            if (key !== 'content' && value !== null) {
                if (value) {
                    const v = typeof value === 'object' ? JSON.stringify(value, null, 2) : value.toString()
                    lines.push(`* **${key}** : ${v}`)
                } else {
                    lines.push(`* **${key}** : [undefined]`)
                }
            }
        }

        return lines.join('\n')
    }

}

export default MarkdownFormatter

================
File: src/processors/staging/StagingProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import MarkdownFormatter from './MarkdownFormatter.js'
import TurtleFormatter from './TurtleFormatter.js'

// ref needed in transmissions/src/engine/AbstractProcessorFactory.js


class StagingProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.MarkdownFormatter)) {
            return new MarkdownFormatter(config)
        }
        if (type.equals(ns.trn.TurtleFormatter)) {
            return new TurtleFormatter(config)
        }
        return false
    }
}
export default StagingProcessorsFactory

================
File: src/processors/staging/TurtleFormatter.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class TurtleFormatter extends Processor {
    constructor(config) {
        super(config)
        this.baseURI = config.baseURI || 'http://example.org/'
    }

    async process(message) {
        try {
            const item = message.currentItem
            if (!item) {
                return
            }

            // Convert item to Turtle
            const turtle = this.formatTurtle(item)
            message.content = turtle
            message.targetFile = `${item.id}.ttl`

            this.emit('message', message)
        } catch (err) {
            logger.error("TurtleFormatter.execute error: " + err.message)
            throw err
        }
    }

    formatTurtle(item) {
        const lines = []
        lines.push('@prefix : <http://example.org/ns#> .')
        lines.push('@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .')
        lines.push('')

        const subject = `<${this.baseURI}${item.id}>`
        lines.push(`${subject} a :Item ;`)

        const entries = Object.entries(item)
        entries.forEach(([key, value], index) => {
            if (value !== null) {
                const isLast = index === entries.length - 1
                const literal = typeof value === 'string' ?
                    `"${value.replace(/"/g, '\\"')}"` :
                    `"${JSON.stringify(value)}"`
                lines.push(`    :${key} ${literal}${isLast ? ' .' : ' ;'}`)
            }
        })

        return lines.join('\n')
    }
}

export default TurtleFormatter

================
File: src/processors/system/EnvLoader.js
================
import 'dotenv/config'

// import { readFile } from 'node:fs/promises' // whatever else

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js' // maybe more specific


/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 *
 * ### References
 * * https://dotenvx.com/
 * * https://github.com/motdotla/dotenv
*/
class EnvLoader extends Processor {

    /**
     * Constructs a new ProcessorExample instance.
     * @param {Object} config - The configuration object.
     */
    constructor(config) {
        super(config)
    }

    /**
     * Does something with the message and emits a 'message' event with the processed message.
     * @param {Object} message - The message object.
     */
    async process(message) {
        //   logger.setLogLevel('debug')
        // console.log(process.env)

        this.config.whiteboard.env = process.env

        return this.emit("message", message)
    }
}

export default EnvLoader

================
File: src/processors/system/SystemProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import EnvLoader from './EnvLoader.js'



class SystemsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.EnvLoader)) {
            return new EnvLoader(config)
        }
        return false
    }
}
export default SystemsProcessorsFactory

================
File: src/processors/terrapack/comment-stripper.js
================
import path from 'path';

const LANGUAGE_PATTERNS = {
    js: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    jsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    ts: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    tsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    py: {
        single: '#',
        multi: { start: '"""', end: '"""' }
    },
    java: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    cpp: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    c: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    h: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    }
};

export function commentStripper(content, filepath) {
    const ext = path.extname(filepath).toLowerCase().slice(1);
    const patterns = LANGUAGE_PATTERNS[ext];

    if (!patterns) {
        return content;
    }

    let lines = content.split('\n');
    let inMultiLineComment = false;
    let result = [];

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();

        if (inMultiLineComment) {
            if (line.includes(patterns.multi.end)) {
                inMultiLineComment = false;
                line = line.split(patterns.multi.end)[1];
            } else {
                continue;
            }
        }

        if (patterns.multi && line.includes(patterns.multi.start)) {
            const parts = line.split(patterns.multi.start);
            if (!parts[1].includes(patterns.multi.end)) {
                inMultiLineComment = true;
                line = parts[0];
            } else {
                line = parts[0] + parts[1].split(patterns.multi.end)[1];
            }
        }

        if (patterns.single && line.startsWith(patterns.single)) {
            continue;
        }

        if (patterns.single) {
            const commentIndex = line.indexOf(patterns.single);
            if (commentIndex >= 0) {
                line = line.substring(0, commentIndex).trim();
            }
        }

        if (line.trim()) {
            result.push(line);
        }
    }

    return result.join('\n');
}

================
File: src/processors/terrapack/CommentStripper.js
================
import path from 'path';

const LANGUAGE_PATTERNS = {
    js: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    jsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    ts: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    tsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    py: {
        single: '#',
        multi: { start: '"""', end: '"""' }
    },
    java: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    cpp: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    c: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    h: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    }
};

export function commentStripper(content, filepath) {
    const ext = path.extname(filepath).toLowerCase().slice(1);
    const patterns = LANGUAGE_PATTERNS[ext];

    if (!patterns) {
        return content;
    }

    let lines = content.split('\n');
    let inMultiLineComment = false;
    let result = [];

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();

        if (inMultiLineComment) {
            if (line.includes(patterns.multi.end)) {
                inMultiLineComment = false;
                line = line.split(patterns.multi.end)[1];
            } else {
                continue;
            }
        }

        if (patterns.multi && line.includes(patterns.multi.start)) {
            const parts = line.split(patterns.multi.start);
            if (!parts[1].includes(patterns.multi.end)) {
                inMultiLineComment = true;
                line = parts[0];
            } else {
                line = parts[0] + parts[1].split(patterns.multi.end)[1];
            }
        }

        if (patterns.single && line.startsWith(patterns.single)) {
            continue;
        }

        if (patterns.single) {
            const commentIndex = line.indexOf(patterns.single);
            if (commentIndex >= 0) {
                line = line.substring(0, commentIndex).trim();
            }
        }

        if (line.trim()) {
            result.push(line);
        }
    }

    return result.join('\n');
}

================
File: src/processors/terrapack/file-container.js
================
import Processor from '../base/Processor.js';
import logger from '../../utils/Logger.js';
import ns from '../../utils/ns.js';
import path from 'path';

class FileContainer extends Processor {
    constructor(config) {
        super(config);
        this.container = {
            files: {},
            summary: {
                totalFiles: 0,
                fileTypes: {},
                timestamp: new Date().toISOString()
            }
        };
    }

    async process(message) {
        if (message.done) {
            message.content = JSON.stringify(this.container, null, 2);
            message.filepath = this.getPropertyFromMyConfig(ns.trn.destination);
            return this.emit('message', message);
        }

        if (!message.filepath || !message.content) {
            logger.warn('FileContainer: Missing filepath or content');
            return;
        }

        // Get relative path from target dir
        const targetDir = message.targetPath || message.rootDir;
        const relativePath = path.relative(targetDir, message.filepath);

        // Store file content and metadata
        this.container.files[relativePath] = {
            content: message.content,
            type: path.extname(message.filepath),
            timestamp: new Date().toISOString()
        };

        // Update summary stats
        this.container.summary.totalFiles++;
        const fileType = path.extname(message.filepath) || 'unknown';
        this.container.summary.fileTypes[fileType] = (this.container.summary.fileTypes[fileType] || 0) + 1;

        return this.emit('message', message);
    }
}

export default FileContainer;

================
File: src/processors/terrapack/FileContainer.js
================
import Processor from '../base/Processor.js'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import path from 'path'

class FileContainer extends Processor {
    constructor(config) {
        super(config)
        this.container = {
            files: {},
            summary: {
                totalFiles: 0,
                fileTypes: {},
                timestamp: new Date().toISOString()
            }
        }
    }

    async process(message) {
        //    logger.setLogLevel('debug')
        message.filepath = await this.getProperty(ns.trn.destination)
        if (message.done) {

            // TODO FIX ME
            message.filepath = message.filepath + '_done.txt'

            message.content = JSON.stringify(this.container, null, 2)
            //   message.filepath = this.getPropertyFromMyConfig(ns.trn.destination);

            return this.emit('message', message)
        }

        if (!message.filepath || !message.content) {
            logger.warn('FileContainer: Missing filepath or content')
            // this.emit('message', message);
            return
        }

        // Store relative path from target directory
        const targetDir = message.targetPath || message.rootDir
        const relativePath = path.relative(targetDir, message.filepath)

        // Add file to container
        this.container.files[relativePath] = {
            content: message.content,
            type: path.extname(message.filepath),
            timestamp: new Date().toISOString()
        }

        // Update summary
        this.container.summary.totalFiles++
        const fileType = path.extname(message.filepath) || 'unknown'
        this.container.summary.fileTypes[fileType] = (this.container.summary.fileTypes[fileType] || 0) + 1

        return this.emit('message', message)
    }
}

export default FileContainer

================
File: src/processors/terrapack/terrapack-factory.js
================
import logger from '../../utils/Logger.js';
import ns from '../../utils/ns.js';
import FileContainer from './FileContainer.js';

class PackerProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.FileContainer)) {
            logger.debug('PackerProcessorsFactory: Creating FileContainer processor');
            return new FileContainer(config);
        }
        return false;
    }
}

export default PackerProcessorsFactory;

================
File: src/processors/terrapack/TerrapackProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import FileContainer from './FileContainer.js'

class TerrapackProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.FileContainer)) {
            logger.debug('TerrapackProcessorsFactory: Creating FileContainer processor')
            return new FileContainer(config)
        }
        return false
    }
}

export default TerrapackProcessorsFactory

================
File: src/processors/test/TestProcessorsFactory.js
================
import ns from '../../utils/ns.js'

import TestSettings from './TestSettings.js'

class TestProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.TestSettings)) {
            return new TestSettings(config)
        }
        return false
    }
}

export default TestProcessorsFactory

================
File: src/processors/test/TestSettings.js
================
// src/processors/example-group/TestSettings.js
/**
 * @class TestSettings
 * @extends Processor
 * @classdesc
 * **a Basic Transmissions Processor**
 *
 * Provides a template for creating new processors, demonstrates use of config settings.
 *
 * #### __*Input*__
 * * **`message.common`** - addressed by all instances of this TestSettings (optional, default undefined)
 * * **`message.something1`** - Template string (used if templateFilename is not provided)
 * * **`message.something2`** - Object with properties for template rendering (e.g., title, body)
 * * **`message.notavalue`** - Object with properties for template rendering (e.g., title, body)
 *
 * #### __*Output*__
 * * **`message.content`** - The rendered template content
 *
 * #### __*Behavior*__
 * * Uses Nunjucks to render templates
 * * Can render from a template file or a template string
 * * Applies content from message.contentBlocks to the template
 *
 * #### __Tests__
 * *
 *
  * #### __*ToDo*__
 * * Add test information here
 * * Cache templates - cache in utils?
 */

import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class TestSettings extends Processor {
    constructor(config) {
        super(config)
    }

    /**
      * Does something with the message and emits a 'message' event with the processed message.
      * @param {Object} message - The message object.
      */
    async process(message) {
        //   logger.setLogLevel('debug')
        logger.debug(`\n\nTestSettings.process`)

        // property values pulled from message | config settings | fallback

        const me = this.getProperty(ns.trn.me, 'default me')
        logger.log(`\nI am ${me}`)

        switch (me) {
            case ':settingsUseMessage':
                message.test = 'this came from message'
                logger.log(`${this.getProperty(ns.trn.test)}`)
                break

            case ':settingsSingle':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                break

            case ':settingsURI':
                logger.log(`${this.getProperty(ns.trn.uri)}`)
                break

            case ':settingsPath':
                // need to check ontology for this
                // TODO needs something like :path a :Path .
                logger.log(`${this.getProperty(ns.trn.path)}`)
                break

            case ':settingsMulti':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                logger.log(`${this.getProperty(ns.trn.uri)}`)
                break

            // TODO where did I use this?
            case ':settingsKeyValue':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                break

            case ':settingsLists':
                logger.log(`aSetting : \n${this.getProperty(ns.trn.aSetting)}`)
                logger.log(`bSetting : \n${this.getProperty(ns.trn.bSetting)}`)
                break

            default:
                logger.log(`This is fallback : ${this.getProperty(ns.trn.name, 'yes it is')}`)
                break
        }

        // message forwarded
        return this.emit('message', message)
    }
}
export default TestSettings

================
File: src/processors/text/LineReader.js
================
import { readFile } from 'node:fs/promises'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class LineReader extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {

        const text = data.toString()


        const lines = text.split('\n')
        for await (let line of lines) {
            if (line.trim() && !line.startsWith('#')) {
                logger.debug('Line = [[[' + line + ']]]')
                return this.emit('message', line, message)
            }
        }

        return this.emit('message', '~~done~~', message)
    }
}

export default LineReader

================
File: src/processors/text/StringFilter.js
================
import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import StringUtils from '../../utils/StringUtils.js'

class StringFilter extends Processor {
    constructor(config) {
        super(config)
    }

    // filepath maybe a good default, but..?
    async process(message) {
        if (message.done) {
            return this.emit('message', message)
        }

        if (!message.filepath) {
            logger.warn('StringFilter: No filepath provided')
            return
        }
        this.includePatterns = this.getValues(ns.trn.includePattern)
        this.excludePatterns = this.getValues(ns.trn.excludePattern)

        if (this.isAccepted(message.filepath)) {
            return this.emit('message', message)
        }
    }

    //matchPattern(filePath, pattern) {
    //  try {
    //    const regexPattern = pattern
    //      .replace(/\./g, '\\.')
    //    .replace(/\*/g, '.*')
    //  .replace(/\?/g, '.');
    //        const regex = new RegExp(`^${regexPattern}$`);
    //      const filename = path.basename(filePath);
    //    return regex.test(filename);
    //} catch (error) {
    //  logger.error('Pattern matching error:', { pattern, error });
    //return false;
    //  }
    // }

    isAccepted(filePath) {
        if (!filePath) return false

        if (this.excludePatterns.length === 0 && this.includePatterns.length === 0) {
            return true
        }

        /*
        for (const pattern of this.excludePatterns) {
            if (this.matchPattern(filePath, pattern)) {
                logger.debug(`File ${filePath} excluded by pattern ${pattern}`)
                return false
            }
        }
        */
        if (StringUtils.matchPatterns(filePath, this.excludePatterns)) {
            return false
        }

        if (StringUtils.matchPatterns(filePath, this.includePatterns)) {
            return true
        }

        /*
        if (this.includePatterns.length > 0) {
            for (const pattern of this.includePatterns) {
                if (this.matchPattern(filePath, pattern)) {
                    logger.debug(`File ${filePath} included by pattern ${pattern}`)
                    return true
                }
            }
            return false
        }
            */

        return true
    }
}

export default StringFilter

================
File: src/processors/text/StringMerger.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

// OLD : PRE-REFACTOR
class StringMerger extends Processor {
    constructor(config) {
        super(config)
        this.merged = ''
    }

    async process(message) {
        logger.log('SMDATA*********************************\n' + data)

        if (data === '~~done~~') {
            logger.log('SM  DONE**********************************\n' + this.merged)
            return this.emit('message', this.merged, message)
            return
        }
        this.merged = this.merged + data

    }
}

export default StringMerger

================
File: src/processors/text/StringReplace.js
================
// src/processors/text/StringReplace.js
/**
 * @class StringReplace
 * @extends Processor
 * @classdesc
 * **a Transmissions Processor**
 *
 * Replaces all occurrences of a specified substring in the content with a replacement string.
 *
 * ### Signature
 *
 * #### __*Input*__
 * * **`message.content`** - The original string content
 * * **`message.match`** - The substring to be replaced
 * * **`message.replace`** - The replacement string
 *
 * #### __*Output*__
 * * **`message.content`** - The modified string with replacements
 *
 * #### __*Behavior*__
 * * Replaces every exact occurrence of `message.match` in `message.content` with `message.replace`
 * * If `message.match` is not found, the content remains unchanged
 *
 * #### __Tests__
 * * TODO: Add test information
 */

import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class StringReplace extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Executes the string replacement process
     * @param {Object} message - The message object containing content, match, and replace strings
     */
    async process(message) {
        // logger.setLogLevel('debug')
        const inputField = await this.getProperty(ns.trn.inputField)
        const outputField = await this.getProperty(ns.trn.outputField)

        var match = message.match ? message.match : await this.getProperty(ns.trn.match)
        var replace = message.replace ? message.replace : await this.getProperty(ns.trn.replace)

        var input = message.input ? message.input : message[inputField]
        if (!input) {
            input = message.content
        }

        logger.debug('StringReplace.process input = ' + input)

        // global s & r
        const output = input.split(match).join(replace)

        logger.debug('StringReplace output: ' + output)
        try {
            message[outputField] = output
        } catch {
            message.content = output
        }
        return this.emit('message', message)
    }
}

export default StringReplace

================
File: src/processors/text/Templater.js
================
// src/processors/text/Templater.js
/**
 * @class Templater
 * @extends Processor
 * @classdesc
 * **a Transmissions Processor**
 *
 * Provides templating functionality using Nunjucks.
 *
 * #### __*Input*__
 * * **`message.templateFilename`** - Path to the template file (optional)
 * * **`message.template`** - Template string (used if templateFilename is not provided)
 * * **`message.contentBlocks`** - Object with properties for template rendering (e.g., title, body)
 *
 * #### __*Output*__
 * * **`message.content`** - The rendered template content
 *
 * #### __*Behavior*__
 * * Uses Nunjucks to render templates
 * * Can render from a template file or a template string
 * * Applies content from message.contentBlocks to the template
 *
 * #### __Tests__
 * *
 *
  * #### __TODO__
 * * Add test information here
 * * Cache templates - cache in utils?
 */

import Processor from '../base/Processor.js'
import nunjucks from 'nunjucks'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

class Templater extends Processor {
    constructor(config) {
        super(config)
    }

    /**
     * Executes the templating process
     * @param {Object} message - The message object containing template and content information
     */
    async process(message) {
        //    logger.setLogLevel('debug')
        //   logger.log(this.getPropertyFromMyConfig(ns.trn.templateFilename))
        //    this.addPropertyToMyConfig(ns.trn.templateFilename, 'poo')
        //   this.showMyConfig()
        var templateFilename = await this.getProperty(ns.trn.templateFilename)

        logger.debug(`\nTemplater.process, templateFilename = ${templateFilename}`)
        // process.exit()

        if (templateFilename) {
            //       logger.debug(`\nTemplater.process, templateFilename = ${templateFilename}`)

            // Extract path and filename from templateFilename
            var targetPath = templateFilename.substr(0, templateFilename.lastIndexOf("/"))
            const filename = templateFilename.substr(templateFilename.lastIndexOf("/") + 1)

            if (!path.isAbsolute(targetPath)) {
                targetPath = path.join(await this.getProperty(ns.trn.targetPath, message.rootDir), targetPath)
            }

            logger.debug('\nTemplater, targetPath = ' + targetPath)
            logger.debug('Templater, filename = ' + filename)

            // Configure Nunjucks with the template path
            nunjucks.configure(targetPath, { autoescape: false })

            //   logger.debug(`content PRE = ${message.content}`)
            // Render the template file
            message.content = nunjucks.render(filename, message.contentBlocks)

            logger.debug(`content POST = ${message.content}`)


        } else {   // Configure Nunjucks for string templates
            // TODO priorities

            nunjucks.configure({ autoescape: false })

            //    logger.reveal(message)
            // Render the template string
            message.content = nunjucks.renderString(message.template, message.contentBlocks)
        }

        return this.emit('message', message)
    }
}
export default Templater

================
File: src/processors/text/TextProcessorsFactory.js
================
import ns from '../../utils/ns.js'

import LineReader from './LineReader.js'
import StringFilter from './StringFilter.js'
import StringMerger from './StringMerger.js'
import StringReplace from './StringReplace.js'
import Templater from './Templater.js'

class TextProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.Templater)) {
            return new Templater(config)
        }
        if (type.equals(ns.trn.LineReader)) {
            return new LineReader(config)
        }

        if (type.equals(ns.trn.StringFilter)) {
            return new StringFilter(config)
        }

        if (type.equals(ns.trn.StringMerger)) {
            return new StringMerger(config)
        }

        if (type.equals(ns.trn.StringReplace)) {
            return new StringReplace(config)
        }

        //     if (type.equals(ns.trn.CommentStripper)) {
        //       return new CommentStripper(config)
        // }

        return false
    }
}

export default TextProcessorsFactory

================
File: src/processors/unsafe/_RunCommand.spec.js
================
import RunCommand from '../../src/processors/unsafe/RunCommand.js';
import { expect } from 'chai';
import fs from 'fs/promises';
import path from 'path';

describe('RunCommand', function () {
    let runCommand;
    const dataDir = 'src/applications/test_runcommand/data';

    beforeEach(function () {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;
        runCommand = new RunCommand({
            simples: true,
            allowedCommands: ['echo', 'ls'],
            blockedPatterns: ['rm', '|']
        });
    });

    it('should validate command output against required file', async function () {
        const requiredPath = path.join(dataDir, 'output', 'required-01.txt');
        const required = await fs.readFile(requiredPath, 'utf8');
        const message = { command: 'echo "Hello from RunCommand!"' };

        const result = await runCommand.process(message);
        expect(result.content.trim()).to.equal(required.trim());
    });

    it('should handle timeouts', async function () {
        try {
            await runCommand.executeCommand('sleep 10');
            expect.fail('Should have timed out');
        } catch (error) {
            expect(error.message).to.include('timeout');
        }
    });
});

================
File: src/processors/unsafe/ExampleProcessor.js
================
// src/processors/example-group/ExampleProcessor.js
/**
 * @class ExampleProcessor
 * @extends Processor
 * @classdesc
 * **a Basic Transmissions Processor**
 *
 * Provides a template for creating new processors, demonstrates use of config settings.
 *
 * #### __*Input*__
 * * **`message.common`** - addressed by all instances of this ExampleProcessor (optional, default undefined)
 * * **`message.something1`** - Template string (used if templateFilename is not provided)
 * * **`message.something2`** - Object with properties for template rendering (e.g., title, body)
 * * **`message.notavalue`** - Object with properties for template rendering (e.g., title, body)
 *
 * #### __*Output*__
 * * **`message.content`** - The rendered template content
 *
 * #### __*Processing*__
 * * Uses Nunjucks to render templates
 * * Can render from a template file or a template string
 * * Applies content from message.contentBlocks to the template
 *
* #### __*Side Effects*__
 *
 * #### __Tests__
 * *
 *
  * #### __*ToDo*__
 * * Add test information here
 * * Cache templates - cache in utils?
 */

import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class ExampleProcessor extends Processor {
    constructor(config) {
        super(config)
    }

    /**
      * Does something with the message and emits a 'message' event with the processed message.
      * @param {Object} message - The message object.
      */
    async process(message) {
        logger.debug(`\n\nExampleProcessor.process`)

        // TODO figure this out better
        // may be needed if preceded by a spawning processor, eg. fs/DirWalker
        if (message.done) {
            return this.emit('message', message)
            // or simply return
        }

        // message is processed here :

        // property values pulled from message | config settings | fallback
        const me = await this.getProperty(ns.trn.me)
        logger.log(`\nI am ${me}`)

        message.common = await this.getProperty(ns.trn.common)
        message.something1 = await this.getProperty(ns.trn.something1)

        message.something2 = await this.getProperty(ns.trn.something2)

        var added = await this.getProperty(ns.trn.added, '')
        message.something1 = message.something1 + added

        message.notavalue = await this.getProperty(ns.trn.notavalue, 'fallback value')

        // message forwarded
        return this.emit('message', message)
    }
}
export default ExampleProcessor

================
File: src/processors/unsafe/RunCommand.js
================
import { exec } from 'child_process';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class RunCommand extends Processor {
    constructor(config) {
        super(config);
        this.allowedCommands = config.allowedCommands || [];
        this.blockedPatterns = config.blockedPatterns || [];
        this.timeout = config.timeout || 5000;
        this.initializeSecurity();
    }

    async initializeSecurity() {
        if (this.settings) {
            const allowed = await this.getPropertyFromMyConfig(ns.trn.allowedCommands);
            this.allowedCommands = allowed ? allowed.split(',') : [];

            const blocked = await this.getPropertyFromMyConfig(ns.trn.blockedPatterns);
            this.blockedPatterns = blocked ? blocked.split(',') : [];
        }
    }

    validateCommand(command) {
        if (!command) {
            throw new Error('No command specified');
        }

        const commandName = command.split(' ')[0];
        const isAllowed = this.allowedCommands.length === 0 ||
            this.allowedCommands.includes(commandName);

        if (!isAllowed) {
            throw new Error(`Command '${commandName}' not in allowed list`);
        }

        const hasBlocked = this.blockedPatterns.some(pattern =>
            command.includes(pattern)
        );
        if (hasBlocked) {
            throw new Error('Command contains blocked pattern');
        }
    }

    async process(message) {
        let command = message.command;
        if (!command) {
            command = this.getPropertyFromMyConfig(ns.trn.command);
        }

        try {
            this.validateCommand(command);
            const result = await this.executeCommand(command);
            message.content = result.stdout;
            message.commandResult = result;
            logger.debug(`Command executed successfully: ${command}`);
        } catch (error) {
            logger.error(`Command error: ${error.message}`);
            message.commandError = error.message;
            message.content = error.message;
            throw error;
        }

        return this.emit('message', message);
    }

    executeCommand(command) {
        return new Promise((resolve, reject) => {
            const child = exec(command, {
                timeout: this.timeout
            }, (error, stdout, stderr) => {
                if (error) {
                    if (error.signal === 'SIGTERM') {
                        reject(new Error('Command timeout'));
                    } else {
                        reject(error);
                    }
                    return;
                }
                resolve({
                    stdout: stdout.toString(),
                    stderr: stderr.toString(),
                    code: 0
                });
            });
        });
    }
}

export default RunCommand;

================
File: src/processors/unsafe/UnsafeProcessorsFactory.js
================
// import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import RunCommand from './RunCommand.js'


class UnsafeProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.RunCommand)) {
            return new RunCommand(config)
        }

        return false
    }
}
export default UnsafeProcessorsFactory

================
File: src/processors/util/CaptureAll.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class CaptureAll extends Processor {
    constructor(config) {
        // Ensure whiteboard is initialized as an array
        if (!config.whiteboard || !Array.isArray(config.whiteboard)) {
            config.whiteboard = []
        }
        super(config)

        if (CaptureAll.singleInstance) {
            return CaptureAll.singleInstance
        }
        CaptureAll.singleInstance = this
    }

    async process(message) {
        logger.debug(`CaptureAll at [${message.tags}] ${this.getTag()}, done=${message.done}`)
        this.config.whiteboard.push(message)
        return this.emit('message', message)
    }
}

export default CaptureAll

================
File: src/processors/util/SetMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'

class SetMessage extends Processor {

    constructor(config) {
        super(config)
        logger.log('SetMessage constructor')
    }

    async process(message) {
        //   logger.setLogLevel('debug')
        const setters = await this.getSetters(this.config, this.settingsNode, ns.trn.setValue)
        for (let i = 0; i < setters.length; i++) {
            message[setters[i].key] = setters[i].value
        }
        return this.emit('message', message)
    }

    async getSetters(config, settings, term) { // TODO refactor - is same in RestructureJSON
        //   logger.debug(`***** config = ${config}`)
        logger.debug(`***** settings.value = ${settings.value}`)
        logger.debug(`***** term = ${term}`)
        const settersRDF = GrapoiHelpers.listToArray(config, settings, term)
        const dataset = this.config
        var setters = []
        for (let i = 0; i < settersRDF.length; i++) {
            let setter = settersRDF[i]
            let poi = rdf.grapoi({ dataset: dataset, term: setter })
            let key = poi.out(ns.trn.key).value
            let value = poi.out(ns.trn.value).value
            setters.push({ "key": key, "value": value })
        }
        return setters
    }
}

export default SetMessage

================
File: src/processors/util/ShowConfig.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowConfig extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {

        logger.log("***************************")
        logger.log("***   Config Triples   ***")
        logger.log(this.config)
        logger.log("***************************")
        return this.emit('message', message)
    }
}

export default ShowConfig

================
File: src/processors/util/ShowMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowMessage extends Processor {

    constructor(config) {
        super(config)
        this.verbose = false
    }

    async process(message) {

        //    logger.log("\n\nStringSink outputs : \"" + data + "\"\n\n")

        if (this.verbose) logger.log("\n***  Show Message ***")

        logger.log("***************************")
        logger.log("***  Message")
        logger.reveal(message)
        logger.log("***************************")
        //     logger.log("***  Trace")
        //   console.trace() // move to Logger, only when debugging
        // logger.log("***************************")

        return this.emit('message', message)
    }
}

export default ShowMessage

================
File: src/processors/util/ShowSettings.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'

// probably not needed, see TestSetting
class ShowSettings extends Processor {

    constructor(config) {
        super(config)
        //   this.verbose = false
    }

    async process(message) {
        //  logger.setLogLevel('debug')
        logger.debug(`ShowSettings.process`)

        const property = ns.trn.name

        logger.debug(`ShowSettings.process, property = ${property}`)

        const value = await this.getProperty(property)

        logger.debug(`ShowSettings.process, value  = ${value}`)

        return this.emit('message', message)
    }
}

export default ShowSettings

================
File: src/processors/util/ShowTransmission.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowTransmission extends Processor {

    async process(message) {
        logger.log(this.transmission.toString())
        return this.emit('message', message)
    }
}

export default ShowTransmission

================
File: src/processors/util/Stash.js
================
import rdf from 'rdf-ext'
import { fromFile, toFile } from 'rdf-utils-fs'
import Processor from '../base/Processor.js'

/**
 * Takes the input and stashes it in the message as told by processors.ttl
 * 
 * #### __*Input*__
 * **data** : any
 * **message** : any
 * #### __*Output*__
 * **data** : as Input
 * **message** : adds key:value determined by processors.ttl
 * @extends Processor
 */
class Stash extends Processor {

    /**
     * Create a DatasetReader.
     * @param {Object} config - The configuration object.
     */
    constructor(config) {
        super(config)
    }

    /**
     * Execute the DatasetReader processor.
     * @param {string} data -.
     * @param {Object} message - .
     */
    async process(message) {
        const manifestFilename = rootDir + '/manifest.ttl'
        const stream = fromFile(manifestFilename)

        // should append RDF to incoming
        message.rootDir = rootDir
        message.dataset = await rdf.dataset().import(stream)
        return this.emit('message', message)
    }
}
export default Stash

================
File: src/processors/util/UtilProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import ShowMessage from './ShowMessage.js'
import ShowTransmission from './ShowTransmission.js'
import CaptureAll from './CaptureAll.js'
import ShowConfig from './ShowConfig.js'
import WhiteboardToMessage from './WhiteboardToMessage.js'
import SetMessage from './SetMessage.js'
import ShowSettings from './ShowSettings.js'
ShowSettings

class UtilProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.ShowMessage)) {
            return new ShowMessage(config)
        }
        if (type.equals(ns.trn.ShowTransmission)) {
            return new ShowTransmission(config)
        }
        if (type.equals(ns.trn.CaptureAll)) {
            return new CaptureAll(config)
        }
        if (type.equals(ns.trn.ShowConfig)) {
            return new ShowConfig(config)
        }
        if (type.equals(ns.trn.WhiteboardToMessage)) {
            return new WhiteboardToMessage(config)
        }
        if (type.equals(ns.trn.SetMessage)) {
            return new SetMessage(config)
        }
        if (type.equals(ns.trn.ShowSettings)) {
            return new ShowSettings(config)
        }
        return false
    }
}
export default UtilProcessorsFactory

================
File: src/processors/util/WhiteboardToMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class WhiteboardToMessage extends Processor {

    constructor(config) {
        super(config)
    }
    async process(message) {

        logger.debug('WhiteboardToMessage at [' + message.tags + '] ' + this.getTag())

        const originalArray = this.config.whiteboard

        message.whiteboard = Object.keys(originalArray).reduce((acc, key) => {
            const value = originalArray[key]
            if (value !== undefined && value !== null) {
                Object.keys(value).forEach((prop) => {
                    if (!acc[prop]) {
                        acc[prop] = []
                    }
                    acc[prop].push(value[prop])
                })
            }
            return acc
        }, {})

        return this.emit('message', message)
    }
}

export default WhiteboardToMessage

================
File: src/processors/xmpp/XmppClient.js
================
import logger from "../../utils/Logger.js"; // path will likely change
import Processor from "../base/Processor.js"; // maybe more specific

/**
 * FileReader class that extends xxxxxProcessor.
 * DESCRIPTION
 * #### __*Input*__
 * **message.INPUT**
 * #### __*Output*__
 * **message.OUTPUT**
 */
class XmppClient extends Processor {
  /**
   * Constructs a new ProcessorExample instance.
   * @param {Object} config - The configuration object.
   */
  constructor(config) {
    super(config);
  }

  /**
   * Does something with the message and emits a 'message' event with the processed message.
   * @param {Object} message - The message object.
   */
  async process(message) {
    logger.setLogLevel("debug");

    // processing goes here
    return this.emit("message", message);
  }
}

export default XmppClient

================
File: src/processors/xmpp/XmppProcessorsFactory.js
================
import logger from "../../utils/Logger.js";
import ns from "../../utils/ns.js";

import ProcessorTemplate from "./XmppClient.js";

// ref needed in transmissions/src/processors/base/AbstractProcessorFactory.js

class XmppProcessorsFactory {
  static createProcessor(type, config) {
    if (type.equals(ns.trn.XmppClient)) {
      return new XmppClient(config)
    }
    return false
  }
}
export default XmppProcessorsFactory

================
File: src/processors/about.md
================
# Creating a new Processor

- update repopacks for `transmissions` and `trans-apps`
- create a new chat session in existing Project
- upload repopacks to Claude, with anything else that might be relevant (handover from previous session?)
- follow the prompt model as in `/home/danny/workspaces_hkms-desktop/postcrafts-raw/transmissions/prompts/github-list.md`
- remember additions to `xProcessorsFactory.js` and `transmissions/src/engine/AbstractProcessorFactory.js`

#:todo add comment creation
#:todo check simples & application suitability
#:todo create document creation workflow
#:todo create manifest.ttl creation
#:todo make crossrefs.md, crossrefs.ttl
#:todo create manifest.ttl consumption
#:todo add test creation
#:todo wire to an API, include file creation ops
#:todo add support in #:hyperdata-desktop

#:todo dedicated transmissions model, fine-tuned on relevant docs

#:todo extract todos as something like :

```turtle
<http://hyperdata.it/transmissions/src/processors/about/nid123> a pv:ToDoItem ;
dc:source <http://hyperdata.it/transmissions/src/processors/about.md> ;
pv:semtag "#:todo" ;
dc:line "3" ;
dc:title "tbd" ;
dc:content "extract todos as something like :" .
```

================
File: src/simples/env-loader/about.md
================
node src/apps-simple/env-loader/env-loader.js

from:

:envy a trm:Pipeline ;

# trm:pipe (:SC :s10 :s20 :SM) .

trm:pipe (:p10 :p20 :SC) .
:p10 a :EnvLoader .
:p20 a :WhiteboardToMessage .

================
File: src/simples/env-loader/env-loader.js
================
import logger from '../../utils/Logger.js'
import EnvLoader from '../../processors/system/EnvLoader.js'
import WhiteboardToMessage from '../../processors/util/WhiteboardToMessage.js'

logger.log('EnvLoader simple')

const config = { whiteboard: [] }

const p10 = new EnvLoader(config)
p10.id = 'http://purls.org/stuff/#p10'

const p20 = new WhiteboardToMessage(config)
p10.id = 'http://purls.org/stuff/#p20'

var message = {
    "dataDir": "src/applications/env-loader-test/data",
    "rootDir": "[no key]",
    "tags": "SM"
}

const x = 3

message = await p10.process(message)

logger.log('p10 output ' + p10.getTag() + message)

message = await p20.process(message)

logger.log('p20 output ')

logger.reveal(message)

================
File: src/simples/nop/nop.js
================
// nop.js
// node src/simples/nop/nop.js

import NOP from '../../processors/flow/NOP.js'

const config = {
    "runmode": "functions",
    whiteboard: []
}

const nop = new NOP(config)

var message = { 'value': '42' }

message = await nop.process(message)

console.log('value = ' + message.value)

================
File: src/simples/nop/simple-runner.js
================
// simple-runner.js
import NOP from '../../processors/flow/NOP.js'
import Fork from '../../processors/flow/Fork.js'

/*
async function runProcessor(processor, message) {
    const outputs = await processor.process(message)
    return outputs
}
*/

async function main() {
    const config = {}
    const nop = new NOP(config)
    const fork = new Fork(config)

    var message = { 'value': '42' }

    // Run NOP
    // message = await nop.execut(message)
    var outputs = await nop.process(message)
    console.log('NOP outputs:', outputs)

    // Run Fork
    message.nForks = 3
    outputs = await fork.process(message)
    console.log('Fork outputs:', outputs)
}

main().catch(console.error)

================
File: src/simples/set-message/set-message.js
================
// set-message.js
// node src/simples/set-message/set-message.js 

import logger from '../../utils/Logger.js'
import SetMessage from '../../processors/util/SetMessage.js'

const config = {
    "runmode": "functions",
    whiteboard: []
}

const setm = new SetMessage(config)

var message = { 'value': '42' }

message = await setm.process(message)

logger.log('value = ' + message.value)

logger.reveal(message)

================
File: src/utils/cache.js
================
/* TODO implement

filename/URI, meta, content
*/

================
File: src/utils/footpath.js
================
import path from 'path'
import { fileURLToPath } from 'url'

import logger from './Logger.js'

/*
resolves paths so both runtime and tests work

must be a better way of doing this, but I can't be bothered looking today
*/

let footpath = {}

footpath.resolve = function footpath(here, relative, start) {

    const loggy = false
    if (loggy) {
        logger.debug("\n*** start footpath.resolve ***")
        logger.debug("process.cwd() = " + process.cwd())
        logger.debug("here = " + here)
        logger.debug("relative = " + relative)
        logger.debug("start = " + start)
    }

    const __filename = fileURLToPath(here)
    const __dirname = path.dirname(__filename)
    const rootDir = path.resolve(__dirname, relative)
    const filePath = path.join(rootDir, start)

    if (loggy) {
        logger.debug("__filename = " + __filename)
        logger.debug("__dirname = " + __dirname)
        logger.debug("rootDir = " + rootDir)
        logger.debug("filePath = " + filePath)
        logger.debug("*** end footpath.resolve ***\n")
    }

    return filePath
}

footpath.urlLastPart = function footpath(url = 'http://example.org/not-a-url') {
    // logger.debug('url = ' + url)
    //   try {
    const urlObj = new URL(url);
    const hash = urlObj.hash;
    const path = urlObj.pathname;
    const lastPart = hash ? hash.replace(/^#/, '') : path.split('/').pop();
    // } catch {
    //  return 'not-a-url'
    //}
    return lastPart;
}

export default footpath

================
File: src/utils/GrapoiHelpers.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import { fromFile, toFile } from 'rdf-utils-fs'
import ns from './ns.js'
import logger from './Logger.js'

// probably already exist - ask Bergi

class GrapoiHelpers {

    // file utils
    static async readDataset(filename) {
        const stream = fromFile(filename)
        const dataset = await rdf.dataset().import(stream)
        return dataset
    }

    static async writeDataset(dataset, filename) {
        await toFile(dataset.toStream(), filename)
    }

    // follows chain in rdf:List
    static listToArray(dataset, term, property) {
        const poi = rdf.grapoi({ dataset: dataset, term: term })
        const first = poi.out(property).term

        let p = rdf.grapoi({ dataset, term: first })
        let object = p.out(ns.rdf.first).term
        //  logger.log('object = ' + object.value)
        const result = [object]

        while (true) {
            let restHead = p.out(ns.rdf.rest).term
            let p2 = rdf.grapoi({ dataset, term: restHead })
            let object = p2.out(ns.rdf.first).term
            //   logger.log('restHead = ' + restHead.value)
            if (restHead.equals(ns.rdf.nil)) break
            result.push(object)
            p = rdf.grapoi({ dataset, term: restHead })
        }
        return result
    }



    // unused & untested
    // [subjects] predicate ->  [objects]
    static listObjects(dataset, subjectList, predicate) {
        const objects = []
        for (const subject of subjectList) {
            logger.log("subject = " + subject.value)
            let p = rdf.grapoi({ dataset, term: subject })
            let object = p.out(predicate).term
            logger.log("object = " + object.value)
            objects.push(object)
        }
        return objects
    }
}
export default GrapoiHelpers

================
File: src/utils/Logger.js
================
import log from 'loglevel'
import fs from 'fs'
import chalk from 'chalk'

const logger = {}

//  logger.log(`\n\nconfig dataset: ${[...config].map(q => `${q.subject.value} ${q.predicate.value} ${q.object.value}`).join('\n')}`)


// Map log levels to chalk styles
const LOG_STYLES = {
    "trace": chalk.bgGray.greenBright,
    "debug": chalk.cyanBright,
    "info": chalk.white,
    "warn": chalk.red.italic,
    "error": chalk.red.bold
}
const LOG_LEVELS = ["trace", "debug", "info", "warn", "error"]

logger.logfile = 'latest.log'
logger.currentLogLevel = "warn"

log.setLevel(logger.currentLogLevel)

logger.getLevel = () => log.getLevel()
logger.enableAll = () => log.enableAll()
logger.disableAll = () => log.disableAll()
logger.setDefaultLevel = (level) => log.setDefaultLevel(level)
logger.getLogger = (name) => {
    const namedLogger = log.getLogger(name)
    return wrapLogger(namedLogger, name)
}

logger.methodFactory = log.methodFactory

logger.noConflict = () => log.noConflict()

function wrapLogger(baseLogger, name = 'root') {
    const wrapped = {}

    wrapped.log = function (msg, level = "info") {  // Changed default to info
        const timestamp = chalk.dim(`[${logger.timestampISO()}]`)
        const levelStyle = LOG_STYLES[level] || LOG_STYLES["info"]  // Fallback to info style
        const levelTag = levelStyle(`[${level.toUpperCase()}]`)
        const nameTag = chalk.green(`[${name}]`)
        const message = levelStyle(msg)

        //   const consoleMessage = `${timestamp} ${levelTag} ${nameTag} - ${message}`;
        const consoleMessage = `${message}`
        const fileMessage = `[${logger.timestampISO()}] [${level.toUpperCase()}] [${name}] - ${msg}`

        baseLogger[level](consoleMessage)
        logger.appendLogToFile(fileMessage)
    }

    LOG_LEVELS.forEach(level => {
        wrapped[level] = (msg) => wrapped.log(msg, level)
    })

    wrapped.getLevel = () => baseLogger.getLevel()
    wrapped.setLevel = (level, persist) => baseLogger.setLevel(level, persist)
    wrapped.setDefaultLevel = (level) => baseLogger.setDefaultLevel(level)
    wrapped.enableAll = () => baseLogger.enableAll()
    wrapped.disableAll = () => baseLogger.disableAll()
    wrapped.methodFactory = baseLogger.methodFactory
    wrapped.setMethodFactory = function (factory) {
        baseLogger.methodFactory = factory
        baseLogger.rebuild()
    }

    return wrapped
}

logger.appendLogToFile = function (message) {
    if (logger.logfile) {
        fs.appendFileSync(logger.logfile, message + '\n', 'utf8')
    }
}

logger.setLogLevel = function (logLevel = "warn", persist = true) {
    logger.currentLogLevel = logLevel
    log.setLevel(logLevel, persist)
}

logger.timestampISO = function () {
    return new Date().toISOString()
}

logger.log = function (msg, level = "info") {
    const levelStyle = LOG_STYLES[level] || LOG_STYLES["info"]
    const message = levelStyle(msg)
    const consoleMessage = `${message}`
    const fileMessage = `[${logger.timestampISO()}] [${level.toUpperCase()}] [root] - ${msg}`
    try {
        //   console.log(`level = ${level}`)
        // console.log(`consoleMessage = ${consoleMessage}`)

        log[level](consoleMessage)
        logger.appendLogToFile(fileMessage)
    } catch (err) {
        console.log(`wtf? ${err.message}`)
    }

}

// have this return a string
logger.reveal = function (instance) {

    if (!instance) {
        // logger.warn('*** no instance defined ***')
        return
    }

    const serialized = {}

    const loglevel = logger.getLevel()
    logger.setLogLevel('trace')


    if (instance.constructor) {
        logger.log(`*** Class : ${instance.constructor.name}`)
    }
    logger.log('* Keys :  ', 'debug')
    for (const key in instance) {
        if (key === 'dataset') {
            logger.log('[[dataset found, skipping]]', 'debug')
            continue
        }

        if (key.startsWith('_')) {
            logger.log(`       ${key}`, 'debug')
            continue
        }

        if (instance.hasOwnProperty(key)) {
            var value = instance[key]

            if (value) {
                if (Buffer.isBuffer(value)) {
                    value = value.toString()
                }
                if (value.length > 100) {
                    try {
                        value = value.substring(0, 100) + '...'
                    } catch (e) {
                        value = value.slice(0, 99)
                    }
                }

                serialized[key] = value

            } else {
                serialized[key] = '[no key]'
            }
        }
    }

    const props = JSON.stringify(serialized, null, 2)
    //  logger.log(`Instance of ${chalk.bold(instance.constructor.name)} with properties - \n${props}`, 'trace');
    logger.log(`Instance of ${chalk.yellow(chalk.bold(instance.constructor.name))} with properties - \n${chalk.yellow(props)})`)
    logger.setLogLevel(loglevel)
}

LOG_LEVELS.forEach(level => {
    logger[level] = (msg) => logger.log(msg, level)
})

logger.poi = function exploreGrapoi(grapoi, predicates, objects, subjects) {
    console.log(chalk.bold('Properties of the Grapoi object:'))
    for (const prop in grapoi) {
        console.log(chalk.cyan(`\t${prop}: ${grapoi[prop]}`))
    }

    console.log(chalk.bold('\nPath:'))
    const path = grapoi.out(predicates, objects).in(predicates, subjects)
    for (const quad of path.quads()) {
        console.log(chalk.cyan(`\t${quad.predicate.value}: ${quad.object.value}`))
    }
}

function handleExit(options, exitCode) {
    if (options.cleanup) {
        // Perform cleanup
    }
    if (exitCode || exitCode === 0) console.log(exitCode)
    if (options.exit) process.exit()
}

process.on('exit', handleExit.bind(null, { cleanup: true }))
process.on('SIGINT', handleExit.bind(null, { exit: true }))
process.on('SIGUSR1', handleExit.bind(null, { exit: true }))
process.on('SIGUSR2', handleExit.bind(null, { exit: true }))
process.on('uncaughtException', handleExit.bind(null, { exit: true }))

// TESTING
// logger.setLogLevel('info')
// logger.log('a log() message on info - show yellow, concise')
// logger.debug('a debug() message on info -  dont show')
// logger.setLogLevel('debug')
// logger.log('a log() message on debug - show yellow, with prefix')
// logger.debug('a debug() message on debug - show red, with prefix')

export default logger

================
File: src/utils/MockApplicationManager.js
================
import logger from './Logger.js'

class MockApplicationManager {
    constructor() {
        this.appsDir = 'src/applications'
        logger.debug('MockApplicationManager: Created new instance')
    }

    async initialize(appName, appPath, subtask, target, flags) {
        logger.debug(`MockApplicationManager.initialize(${appName}, ${appPath}, ${subtask}, ${target})`)

        if (!appName) {
            throw new Error('Application name is required')
        }

        this.app = {
            appName,
            appPath: appPath || appName,
            subtask,
            targetPath: target,
            dataset: {},
            manifestFilename: target ? `${target}/manifest.ttl` : null
        }

        return Promise.resolve()
    }

    async start(message = {}) {
        logger.debug('MockApplicationManager.start()')
        logger.debug('Message:', message)

        if (!this.app) {
            throw new Error('Application not initialized')
        }

        // Simulate successful processing
        return {
            success: true,
            whiteboard: [
                { type: 'processingComplete', timestamp: new Date().toISOString() }
            ]
        }
    }

    async listApplications() {
        logger.debug('MockApplicationManager.listApplications()')

        // Return mock list of applications
        return [
            'test_app1',
            'test_app2',
            'example_app'
        ]
    }

    resolveApplicationPath(appName) {
        if (!appName) {
            throw new Error('Application name is required')
        }

        logger.debug(`MockApplicationManager.resolveApplicationPath(${appName})`)

        if (appName.startsWith('/')) {
            return appName
        }

        if (appName.startsWith('..')) {
            return path.resolve(process.cwd(), appName)
        }

        return path.join(process.cwd(), this.appsDir, appName)
    }
}

export default MockApplicationManager

================
File: src/utils/ns.js
================
import rdf from 'rdf-ext'

const ns = {
    rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
    rdfs: rdf.namespace('http://www.w3.org/2000/01/rdf-schema#'),
    dc: rdf.namespace('http://purl.org/dc/terms/'),
    schema: rdf.namespace('http://schema.org/'),
    xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#'),
    trn: rdf.namespace('http://purl.org/stuff/transmissions/'),
    //  t: rdf.namespace('http://hyperdata.it/transmissions/'),
    //  fs: rdf.namespace('http://purl.org/stuff/filesystem/'),
    //pc: rdf.namespace('http://purl.org/stuff/postcraft/')
}

//ns.getPrefix = function (nsObj) {
//  return Object.keys(nsObj)[0];
//}

ns.shortName = ns.getShortname = function (url) { // I keep mixing up the name

    if (!url) return
    url = url.toString()
    const lastSlashIndex = url.lastIndexOf('/');
    const lastHashIndex = url.lastIndexOf('#');
    const path = url.slice(lastSlashIndex + 1);
    return path.split('#')[0].split('?')[0];
}
export default ns

================
File: src/utils/RDFUtils.js
================
import rdf from 'rdf-ext'
import { fromFile } from 'rdf-utils-fs'
import { fileURLToPath } from 'url'
import path from 'path'
import logger from './Logger.js'

class RDFUtils {
    static async loadDataset(relativePath) {
        try {
            const __filename = fileURLToPath(import.meta.url)
            const __dirname = path.dirname(__filename)
            const rootDir = path.resolve(__dirname, '../..')
            const filePath = path.join(rootDir, relativePath)

            logger.debug(`Loading RDF dataset from: ${filePath}`)
            const stream = fromFile(filePath)
            const dataset = await rdf.dataset().import(stream)
            logger.debug(`Loaded ${dataset.size} quads`)

            return dataset
        } catch (error) {
            logger.error(`Error loading dataset: ${error.message}`)
            logger.error(`Stack: ${error.stack}`)
            throw error
        }
    }
}

export default RDFUtils

================
File: src/utils/StringUtils.js
================
import logger from './Logger.js'

class StringUtils {

    // const markdownFiles = files.filter(file => matchesPattern(file, '*.md'));
    static matchPatterns(str, patterns) {
        logger.trace(`StringUtils.matchPatterns, patterns = ${patterns}`)
        const matches = patterns.filter(pattern => this.matchesPattern(str, pattern))
        if (matches.length > 0) {
            return matches
        }
        return false
    }

    // Convert glob pattern to regex
    static matchesPattern(str, pattern) {

        logger.trace(`StringUtils.matchesPattern, pattern = ${pattern}`)
        const regexPattern = pattern
            .replace(/\./g, '\\.')   // Escape dots
            .replace(/\*/g, '.*')   // Convert * to .*
        const regex = new RegExp(`^${regexPattern}$`)
        return regex.test(str)
    }
}
export default StringUtils

================
File: src/utils/t2j.js
================
/*
* Turtle to JSON-LD converter
*/

import { Readable } from 'readable-stream'
import rdf from '@rdfjs/data-model'
import SerializerJsonld from '@rdfjs/serializer-jsonld'
import Serializer from '@rdfjs/serializer-turtle'
import N3Parser from '@rdfjs/parser-n3'
import { fromFile } from 'rdf-utils-fs'
import { toFile } from 'rdf-utils-fs'

const testTurtle = `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix : <https://hyperdata.it/transmissions/> . # for custom terms & instances

:simplepipe a trm:TransmissionTransmission ;
    trm:pipe (:s1 :s2 :s3) .

:s1 a trm:StringSource .
:s2 a trm:AppendProcess .
:s3 a trm:StringSink .
`
export class Turtle2JSONLD {
    static async convert(turtle) {
        // create N3 parser instance
        let parser = new N3Parser({ factory: rdf })
        //   const stream = Turtle2JSONLD.stringToStream(turtle)
        //  let quadStream = parser.import(stream)

        const input = Readable.from(turtle)

        const output = parser.import(input)

        const serializerJsonld = new SerializerJsonld()
        const jsonStream = serializerJsonld.import(output)

        //      let outputJson = ''

        //            outputJson = outputJson + JSON.stringify(jsonld, null, 2)
        //    })
        const outputJson = await Turtle2JSONLD.streamToString(jsonStream)
        return outputJson
    }

    static stringToStream(str) {
        const stream = new Readable();
        stream.push(str); // Add the string to the stream
        stream.push(null); // Indicates that the stream has ended
        return stream;
    }

    static streamToString(stream) {
        const chunks = [];
        return new Promise((resolve, reject) => {
            stream.on('data', (chunk) => {
                chunks.push(Buffer.from(chunk))
                console.log('chunk:', chunk)
            }
            );
            stream.on('error', (err) => reject(err));
            stream.on('end', () => {
                const result = Buffer.concat(chunks).toString('utf8')
                resolve(result)
                console.log('****************** result:', result)
            });
        })
    }
}

// Convert a string to a stream

const testJson = await Turtle2JSONLD.convert(testTurtle)
console.log('àààààààààààààààààààààà')
console.log(testJson)

================
File: src/utils/test_runner.js
================
import fs from 'fs';
import path from 'path';

const testFiles = fs.readdirSync(__dirname).filter(file => file.startsWith('test_'));

testFiles.forEach(testFile => {
    console.log(`Running ${testFile}`);
    require(path.join(__dirname, testFile));
});

================
File: src/utils/text-utils.js
================
/**
 * Utility functions for escaping text content in Turtle RDF
 * @module TextUtils
 */

/**
 * Escapes a string literal for use in Turtle RDF
 * Handles quotes, backslashes, line breaks per RDF 1.1 Turtle spec
 * @param {string} str The input string to escape
 * @returns {string} The escaped string
 */
/**
 * Regular expression for validating BCP47 language tags
 * Supports basic language tags like 'en', 'en-US', 'zh-Hans' etc.
 */
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;

/**
 * Validates a language tag according to BCP47 rules
 * @param {string} langTag Language tag to validate
 * @returns {boolean} True if valid
 */
export function isValidLanguageTag(langTag) {
    return LANGUAGE_TAG_REGEX.test(langTag);
}

/**
 * Creates a Turtle string literal with optional language tag or datatype
 * @param {string} str The string value
 * @param {Object} options Configuration options
 * @param {string} [options.language] Language tag (BCP47)
 * @param {string} [options.datatype] Datatype IRI
 * @returns {string} Formatted Turtle literal
 */
export function escapeStringLiteral(str, options = {}) {
    if (!str) return '';
    
    const escaped = str.includes('\n') 
        ? `"""${str.replace(/"""/g, '\\"\\"\\"')
                 .replace(/\\/g, '\\\\')
                 .replace(/\r/g, '\\r')
                 .replace(/\t/g, '\\t')}"""`
        : `"${str.replace(/"/g, '\\"')
               .replace(/\\/g, '\\\\')
               .replace(/\r/g, '\\r')
               .replace(/\n/g, '\\n')
               .replace(/\t/g, '\\t')}"`;
               
    if (options.language && isValidLanguageTag(options.language)) {
        return `${escaped}@${options.language.toLowerCase()}`;
    }
    
    if (options.datatype) {
        return `${escaped}^^${options.datatype}`;
    }
    
    return escaped;
}

/**
 * Escapes an IRI for use in Turtle RDF
 * Handles characters not allowed in IRIs per RFC 3987
 * @param {string} iri The IRI to escape
 * @returns {string} The escaped IRI
 */
export function escapeIRI(iri) {
    if (!iri) return '';
    
    return iri.replace(/[\x00-\x20<>"{}|^`\\]/g, (char) => {
        return `\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`;
    });
}

/**
 * Escapes a local name for use in Turtle RDF prefixed names
 * Handles special characters in local names per RDF 1.1 Turtle spec
 * @param {string} localName The local name to escape
 * @returns {string} The escaped local name
 */
export function escapeLocalName(localName) {
    if (!localName) return '';
    
    return localName.replace(/[~.!$&'()*+,;=/?#@%_-]/g, '\\$&');
}

/**
 * Validates if a string is a valid xsd:dateTime
 * @param {string} dateStr The date string to validate
 * @returns {boolean} True if valid xsd:dateTime format
 */
export function isValidDateTime(dateStr) {
    const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/;
    return regex.test(dateStr);
}

/**
 * Clean and normalize a string for use as a URL slug
 * @param {string} str The input string
 * @returns {string} URL-safe slug
 */
export function createSlug(str) {
    return str.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
}

/**
 * Validates a URL string
 * @param {string} url The URL to validate
 * @returns {boolean} True if valid URL
 */
export function isValidURL(url) {
    try {
        new URL(url);
        return true;
    } catch {
        return false;
    }
}

================
File: staging/schema-documentation.md
================
# Transmissions Templates Schema Documentation

## JSON Schema
The JSON schema provides a strict validation structure for application definitions:

### Core Components
1. `appName`: String identifier used in paths & configurations
2. `purpose`: Object describing application goals
   - `primaryGoal`: Single sentence description
   - `inputs`/`outputs`: Array of expected formats
   - `behavior`: Expected processing behavior 

3. `processingRequirements`: Object defining data flow
   - `input`: Message & file specifications
   - `steps`: Array of processing stages
   - `output`: Expected results format

4. `components`: Required implementation pieces
   - `newProcessors`: New code needed
   - `configFiles`: Configuration files
   - `existingProcessors`: Reused components

5. `testing`: Test specifications
   - `unitTests`: Component-level tests
   - `integrationTests`: Pipeline tests

## RDF Schema
The RDF schema models the application definition as linked data:

### Core Classes
1. `trm:ApplicationDefinition`
   - Links requirements, components, testing
   - Provides metadata about application

2. `trm:Requirements` 
   - Models input/output specifications
   - Defines processing steps
   - Links to configurations

3. `trm:ComponentList`
   - Catalogs needed processors
   - Specifies configurations
   - References existing code

4. `trm:TestingRequirements`
   - Defines test scenarios
   - Specifies test data
   - Documents expectations

### Additional Properties
```turtle
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix prj: <http://purl.org/stuff/project/> .

trm:ApplicationDefinition
    trm:hasVersion "1.0" ;
    trm:requiresTransmissionsVersion "2.0" ;
    trm:category "data-processing" ;
    prj:status "development" ;
    prj:priority "medium" ;
    prj:estimatedEffort "2d" ;
    prj:dependencies [
        a prj:DependencyList ;
        prj:requires "markmap-lib", "rdf-ext"
    ] ;
    prj:documentation [
        a prj:DocumentationRequirements ;
        prj:requiresAPIDoc true ;
        prj:requiresUserGuide true
    ] ;
    prj:deployment [
        a prj:DeploymentRequirements ;
        prj:environment "node16+" ;
        prj:memoryRequirements "512MB"
    ] .
```

================
File: staging/template-cli.js
================
#!/usr/bin/env node
import TemplateGenerator from './TemplateGenerator.js';

const generator = new TemplateGenerator();
generator.run();

================
File: staging/template-generator.js
================
import fs from 'fs/promises';
import path from 'path';
import { Command } from 'commander';
import inquirer from 'inquirer';
import { rdf, namespace } from '@rdfjs/data-model';
import { Writer } from 'n3';

const ns = {
    trm: namespace('http://purl.org/stuff/transmission/'),
    prj: namespace('http://purl.org/stuff/project/'),
    app: namespace('http://example.org/app/')
};

class TemplateGenerator {
    constructor() {
        this.program = new Command();
        this.setupCommands();
    }

    setupCommands() {
        this.program
            .name('trans-template')
            .description('Generate Transmissions application templates')
            .version('1.0.0');

        this.program
            .command('create')
            .description('Create new application templates')
            .argument('<name>', 'Application name')
            .option('-f, --format <format>', 'Output format (json|turtle|markdown)', 'json')
            .action(async (name, options) => {
                const answers = await this.promptForDetails(name);
                await this.generateTemplates(name, answers, options.format);
            });
    }

    async promptForDetails(name) {
        return inquirer.prompt([
            {
                type: 'input',
                name: 'primaryGoal',
                message: 'What is the primary goal of this application?'
            },
            {
                type: 'input',
                name: 'inputs',
                message: 'Input formats (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'input',
                name: 'outputs',
                message: 'Output formats (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'input',
                name: 'processors',
                message: 'Required processors (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'confirm',
                name: 'needsTests',
                message: 'Generate test templates?',
                default: true
            }
        ]);
    }

    async generateTemplates(name, answers, format) {
        const outputDir = path.join(process.cwd(), name);
        await fs.mkdir(outputDir, { recursive: true });

        const templates = {
            json: () => this.generateJSON(name, answers),
            turtle: () => this.generateTurtle(name, answers),
            markdown: () => this.generateMarkdown(name, answers)
        };

        const content = templates[format]();
        const fileExt = format === 'turtle' ? 'ttl' : format;

        await fs.writeFile(
            path.join(outputDir, `app-definition.${fileExt}`),
            content
        );

        // Generate basic file structure
        await this.generateFileStructure(outputDir, answers);

        console.log(`Generated ${format} template in ${outputDir}`);
    }

    generateJSON(name, answers) {
        return JSON.stringify({
            appName: name,
            purpose: {
                primaryGoal: answers.primaryGoal,
                inputs: answers.inputs,
                outputs: answers.outputs
            },
            processingRequirements: {
                steps: answers.processors.map(p => ({
                    name: p,
                    processor: p,
                    config: {}
                }))
            },
            testing: {
                unitTests: answers.processors.map(p => ({
                    component: p,
                    cases: ['basic', 'error']
                }))
            }
        }, null, 2);
    }

    generateTurtle(name, answers) {
        const writer = new Writer();
        const app = ns.app(name);

        writer.addQuad(
            app,
            ns.trn('title'),
            rdf.literal(name)
        );

        writer.addQuad(
            app,
            ns.trn('primaryGoal'),
            rdf.literal(answers.primaryGoal)
        );

        answers.processors.forEach(p => {
            const proc = ns.app(p);
            writer.addQuad(
                app,
                ns.trn('hasProcessor'),
                proc
            );
        });

        return writer.toString();
    }

    generateMarkdown(name, answers) {
        return `# ${name}

## Purpose
${answers.primaryGoal}

## Inputs
${answers.inputs.map(i => `- ${i}`).join('\n')}

## Outputs
${answers.outputs.map(o => `- ${o}`).join('\n')}

## Processors
${answers.processors.map(p => `- ${p}`).join('\n')}

## Testing
${answers.needsTests ? '- Unit tests required\n- Integration tests required' : 'No tests specified'}
`;
    }

    async generateFileStructure(outputDir, answers) {
        const dirs = [
            'processors',
            'tests',
            'config'
        ];

        for (const dir of dirs) {
            await fs.mkdir(path.join(outputDir, dir), { recursive: true });
        }

        // Create basic files
        const files = {
            'transmissions.ttl': '',
            'config.ttl': '',
            'about.md': `# ${path.basename(outputDir)}\n\n${answers.primaryGoal}`
        };

        for (const [file, content] of Object.entries(files)) {
            await fs.writeFile(
                path.join(outputDir, file),
                content
            );
        }
    }

    run() {
        this.program.parse();
    }
}

export default TemplateGenerator;

================
File: staging/template-tool-docs.md
================
# Transmissions Template Generator

## Overview
Command-line tool to generate scaffold for new Transmissions applications.

## Installation
```bash
npm install -g trans-template
```

## Usage
```bash
# Generate new application template
trans-template create my-app

# Specify output format
trans-template create my-app --format turtle

# Help
trans-template --help
```

## Generated Structure
```
my-app/
├── processors/      # New processors
├── tests/          # Test files
├── config/         # Configuration files
├── transmissions.ttl  # Pipeline definition
├── config.ttl         # Service configuration
└── about.md          # Application documentation
```

## Template Formats

### JSON
- Full application definition
- Validates against JSON schema
- Used for tooling/automation

### Turtle
- RDF representation
- Linked data model
- Integration with semantic tools

### Markdown
- Human-readable format
- Documentation focus
- GitHub-friendly

## Environment Variables
- `TRANS_TEMPLATE_PATH`: Base path for templates
- `TRANS_CONFIG_PATH`: Path to configuration

## Error Handling
- Validates input parameters
- Creates missing directories
- Reports detailed errors

## Extension
Custom templates can be added in:
```bash
~/.config/trans-template/templates/
```

================
File: staging/transmissions-prompt-template.md
================
# Transmissions Application Definition Template

## Application Name
[Short name for the application, will be used in file paths]

## Purpose
- Primary goal in one sentence
- Key inputs and outputs
- Expected behavior

## Technical Context
- Base paths:
  - Transmissions core: ~/github-danny/transmissions
  - Applications: ~/github-danny/trans-apps

## Processing Requirements 
1. Input Format
   - Message structure
   - File formats/paths
   - Required fields

2. Processing Steps
   - List processing stages in sequence
   - Note any existing processors to use
   - Identify new processors needed

3. Output Format
   - Expected message structure
   - File formats/paths
   - Required fields

## Required Components
- New processors to create [list]
- Configuration files needed [list]
- Existing processors to reuse [list]

## Example Usage
```bash
./trans [app-name] [example command line arguments]
```

## Success Criteria
- List specific conditions that indicate successful implementation
- Example outputs or results

## Technical Constraints
- Note any performance requirements
- Special error handling needs
- Specific processor features needed

## Reference Material
- Links to example code
- Related processors
- Documentation needed

================
File: staging/transmissions-template-schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Transmissions Application Definition",
  "type": "object",
  "required": ["appName", "purpose", "technicalContext", "processingRequirements", "components", "testing"],
  "properties": {
    "appName": {
      "type": "string",
      "description": "Short name for the application"
    },
    "purpose": {
      "type": "object",
      "required": ["primaryGoal", "inputs", "outputs", "behavior"],
      "properties": {
        "primaryGoal": { "type": "string" },
        "inputs": { "type": "array", "items": { "type": "string" }},
        "outputs": { "type": "array", "items": { "type": "string" }},
        "behavior": { "type": "string" }
      }
    },
    "technicalContext": {
      "type": "object",
      "required": ["transmissionsPath", "applicationsPath"],
      "properties": {
        "transmissionsPath": { "type": "string" },
        "applicationsPath": { "type": "string" }
      }
    },
    "processingRequirements": {
      "type": "object",
      "required": ["input", "steps", "output"],
      "properties": {
        "input": {
          "type": "object",
          "properties": {
            "messageStructure": { "type": "object" },
            "fileFormats": { "type": "array", "items": { "type": "string" }},
            "requiredFields": { "type": "array", "items": { "type": "string" }}
          }
        },
        "steps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "processor": { "type": "string" },
              "config": { "type": "object" }
            }
          }
        },
        "output": {
          "type": "object",
          "properties": {
            "messageStructure": { "type": "object" },
            "fileFormats": { "type": "array", "items": { "type": "string" }},
            "requiredFields": { "type": "array", "items": { "type": "string" }}
          }
        }
      }
    },
    "components": {
      "type": "object",
      "required": ["newProcessors", "configFiles", "existingProcessors"],
      "properties": {
        "newProcessors": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "configFiles": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "existingProcessors": { 
          "type": "array", 
          "items": { "type": "string" }
        }
      }
    },
    "testing": {
      "type": "object",
      "required": ["unitTests", "integrationTests"],
      "properties": {
        "unitTests": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "component": { "type": "string" },
              "cases": { 
                "type": "array",
                "items": { "type": "string" }
              }
            }
          }
        },
        "integrationTests": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "scenario": { "type": "string" },
              "steps": { 
                "type": "array",
                "items": { "type": "string" }
              }
            }
          }
        }
      }
    }
  }
}

================
File: staging/transmissions-template-turtle.txt
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix prj: <http://purl.org/stuff/project/> .
@prefix app: <http://example.org/app/> .

app:Application a trm:ApplicationDefinition ;
    dcterms:title "Application Name" ;
    dcterms:description "Primary goal description" ;
    trm:basePath "/path/to/application" ;
    trm:hasRequirement app:ProcessingRequirements ;
    trm:hasComponent app:Components ;
    trm:hasTesting app:Testing .

app:ProcessingRequirements a trm:Requirements ;
    trm:input [
        a trm:InputRequirement ;
        trm:messageStructure "JSON structure" ;
        trm:fileFormat "format specification" ;
        trm:requiredField "field1", "field2"
    ] ;
    trm:processing [
        a trm:ProcessingStep ;
        trm:order 1 ;
        trm:processor "ProcessorName" ;
        trm:configuration app:ProcessorConfig
    ] ;
    trm:output [
        a trm:OutputRequirement ;
        trm:messageStructure "JSON structure" ;
        trm:fileFormat "format specification" ;
        trm:requiredField "field1", "field2"
    ] .

app:Components a trm:ComponentList ;
    trm:newProcessor [
        a trm:Processor ;
        dcterms:title "Processor Name" ;
        trm:class "ProcessorClass" ;
        trm:sourcePath "/path/to/source"
    ] ;
    trm:configFile [
        a trm:Configuration ;
        dcterms:title "Config Name" ;
        trm:format "Turtle" ;
        trm:path "/path/to/config"
    ] ;
    trm:existingProcessor [
        a trm:Processor ;
        dcterms:title "Existing Processor" ;
        trm:class "ProcessorClass"
    ] .

app:Testing a trm:TestingRequirements ;
    trm:unitTest [
        a trm:UnitTest ;
        dcterms:title "Test Name" ;
        trm:component "ComponentName" ;
        trm:testCase "test description"
    ] ;
    trm:integrationTest [
        a trm:IntegrationTest ;
        dcterms:title "Test Scenario" ;
        trm:step "step description" ;
        trm:expectedResult "expected outcome"
    ] ;
    trm:testData [
        a trm:TestData ;
        trm:input "/path/to/test/input" ;
        trm:expected "/path/to/test/output"
    ] .

================
File: staging/transmissions-testing-template.md
================
# Transmissions Testing Requirements Template

## Unit Tests
1. Individual Processors
   - Input validation tests
   - Core processing tests 
   - Error handling tests
   - Edge case tests
   - Sample data needed

2. Configuration Tests
   - Config file loading
   - Config validation
   - Default values
   - Error conditions

## Integration Tests
1. Pipeline Tests
   - Full transmission flow
   - Inter-processor communication
   - Message transformations
   - File I/O operations

2. System Tests
   - CLI interface testing
   - File system interactions
   - Error recovery
   - Resource cleanup

## Test Data Requirements
1. Input Test Files
   - Sample files needed
   - File formats
   - Edge cases
   - Invalid data samples

2. Expected Outputs
   - Reference output files
   - Validation criteria
   - Format specifications
   - Error conditions

## Test Environment
1. Setup Requirements
   - Directory structure
   - Required permissions
   - External dependencies
   - Configuration files

2. Cleanup Procedures
   - File cleanup
   - Resource cleanup
   - State reset
   - Verification steps

## Documentation
1. Test Coverage
   - Required coverage metrics
   - Critical paths
   - Exception paths
   - Performance criteria

2. Test Reports
   - Required metrics
   - Format specifications
   - Success criteria
   - Failure analysis

================
File: tests/examples/test-data-usage.js
================
import TestDataGenerator from '../helpers/TestDataGenerator.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateTestData() {
    // Create generator instance
    const generator = new TestDataGenerator(
        path.join(__dirname, '../../src/applications/test_markmap/data')
    );

    try {
        // Initialize directories
        await generator.init();

        // Generate basic test files
        const files = await generator.generateMarkdownFiles(3);
        console.log('Generated basic test files:', files);

        // Generate nested structure
        await generator.generateNestedStructure();
        console.log('Generated nested structure');

        // Generate edge cases
        await generator.generateEdgeCases();
        console.log('Generated edge cases');

        // Generate required outputs
        await generator.generateRequiredOutputs(
            path.join(generator.baseDir, 'input')
        );
        console.log('Generated required outputs');

    } catch (error) {
        console.error('Error generating test data:', error);
    }
}

// Run generator
generateTestData().catch(console.error);

================
File: tests/tests-support/helpers/file-test-helper.js
================
import fs from 'fs/promises';
import path from 'path';
import logger from '../../src/utils/Logger.js';

class FileTestHelper {
    constructor(baseDir) {
        this.baseDir = baseDir;
    }

    async setup() {
        await fs.mkdir(this.baseDir, { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'input'), { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'output'), { recursive: true });
    }

    async cleanup() {
        try {
            await fs.rm(this.baseDir, { recursive: true, force: true });
        } catch (error) {
            logger.error('Cleanup error:', error);
        }
    }

    async createTestFile(subPath, content) {
        const filePath = path.join(this.baseDir, subPath);
        await fs.mkdir(path.dirname(filePath), { recursive: true });
        await fs.writeFile(filePath, content);
        return filePath;
    }

    async compareFiles(actualPath, expectedPath) {
        try {
            const actual = await fs.readFile(actualPath, 'utf8');
            const expected = await fs.readFile(expectedPath, 'utf8');
            return {
                match: actual.trim() === expected.trim(),
                actual: actual.trim(),
                expected: expected.trim()
            };
        } catch (error) {
            logger.error('File comparison error:', error);
            return {
                match: false,
                error: error.message
            };
        }
    }

    async clearOutputFiles(pattern = 'output-*') {
        const outputDir = path.join(this.baseDir, 'output');
        const files = await fs.readdir(outputDir);
        for (const file of files) {
            if (file.match(pattern)) {
                await fs.unlink(path.join(outputDir, file));
            }
        }
    }

    async fileExists(filePath) {
        try {
            await fs.access(path.join(this.baseDir, filePath));
            return true;
        } catch {
            return false;
        }
    }
}

export default FileTestHelper;

================
File: tests/tests-support/helpers/reporter.js
================
import { SpecReporter } from 'jasmine-spec-reporter';

class CustomReporter {
    constructor() {
        this.specReporter = new SpecReporter({
            spec: {
                displayPending: true // Display pending (not fully implemented) specs
            }
        });
    }

    jasmineStarted() {
        this.specReporter.jasmineStarted.apply(this.specReporter, arguments);
    }

    suiteStarted() {
        this.specReporter.suiteStarted.apply(this.specReporter, arguments);
    }

    specStarted() {
        this.specReporter.specStarted.apply(this.specReporter, arguments);
    }

    specDone() {
        this.specReporter.specDone.apply(this.specReporter, arguments);
    }

    suiteDone() {
        this.specReporter.suiteDone.apply(this.specReporter, arguments);
    }

    jasmineDone() {
        this.specReporter.jasmineDone.apply(this.specReporter, arguments);
    }
}

export default CustomReporter;

/*
import { SpecReporter } from 'jasmine-spec-reporter';

jasmine.getEnv().clearReporters(); // Clear default console reporter
jasmine.getEnv().addReporter(new SpecReporter({
    spec: {
        displayPending: true // Display pending (not fully implemented) specs
    }
}));
*/

================
File: tests/tests-support/helpers/test-data-generator.js
================
import path from 'path';
import fs from 'fs/promises';
import logger from '../../src/utils/Logger.js';

class TestDataGenerator {
    constructor(baseDir) {
        this.baseDir = baseDir;
    }

    async init() {
        await fs.mkdir(this.baseDir, { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'input'), { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'output'), { recursive: true });
    }

    async generateMarkdownFiles(count = 5) {
        const files = [];
        for (let i = 1; i <= count; i++) {
            const content = this.generateMarkdownContent(i);
            const filename = `test-${String(i).padStart(2, '0')}.md`;
            const filepath = path.join(this.baseDir, 'input', filename);
            
            await fs.writeFile(filepath, content);
            files.push(filepath);
        }
        return files;
    }

    generateMarkdownContent(depth = 3) {
        const content = [];
        content.push(`# Test Document ${depth}`);
        
        for (let i = 1; i <= depth; i++) {
            content.push(`\n${'#'.repeat(i + 1)} Section ${i}`);
            content.push(this.generateListItems(i));
            
            if (i < depth) {
                content.push(this.generateParagraph(i));
            }
        }
        
        return content.join('\n');
    }

    generateListItems(count) {
        const items = [];
        for (let i = 1; i <= count; i++) {
            items.push(`* List item ${i}`);
            if (Math.random() > 0.5) {
                for (let j = 1; j <= 2; j++) {
                    items.push(`  * Nested item ${i}.${j}`);
                }
            }
        }
        return items.join('\n');
    }

    generateParagraph(seed) {
        const sentences = [
            "Lorem ipsum dolor sit amet.",
            "Consectetur adipiscing elit.",
            "Sed do eiusmod tempor incididunt.",
            "Ut labore et dolore magna aliqua.",
            "Ut enim ad minim veniam."
        ];
        
        return sentences.slice(0, seed + 1).join(' ');
    }

    async generateNestedStructure(depth = 3) {
        for (let i = 1; i <= depth; i++) {
            const dirPath = path.join(this.baseDir, 'input', 'nested', 
                ...Array(i).fill(0).map((_, idx) => `level-${idx + 1}`));
            
            await fs.mkdir(dirPath, { recursive: true });
            
            const content = this.generateMarkdownContent(i);
            const filepath = path.join(dirPath, `nested-${i}.md`);
            await fs.writeFile(filepath, content);
        }
    }

    async generateEdgeCases() {
        const cases = {
            'empty.md': '',
            'only-title.md': '# Solo Title',
            'special-chars.md': '# Test & < > " \' Document',
            'very-deep.md': this.generateDeepStructure(10),
            'wide.md': this.generateWideStructure(10)
        };

        const edgeCaseDir = path.join(this.baseDir, 'input', 'edge-cases');
        await fs.mkdir(edgeCaseDir, { recursive: true });

        for (const [filename, content] of Object.entries(cases)) {
            await fs.writeFile(path.join(edgeCaseDir, filename), content);
        }
    }

    generateDeepStructure(depth) {
        return Array(depth)
            .fill(0)
            .map((_, i) => `${'#'.repeat(i + 1)} Level ${i + 1}`)
            .join('\n');
    }

    generateWideStructure(width) {
        const content = ['# Wide Document'];
        for (let i = 1; i <= width; i++) {
            content.push(`## Section ${i}`);
            for (let j = 1; j <= width; j++) {
                content.push(`* Item ${i}.${j}`);
            }
        }
        return content.join('\n');
    }

    async generateRequiredOutputs(sourceDir) {
        const files = await fs.readdir(sourceDir);
        for (const file of files) {
            if (file.endsWith('.md')) {
                const content = await fs.readFile(path.join(sourceDir, file));
                
                // Generate HTML required output
                await fs.writeFile(
                    path.join(this.baseDir, 'output', `required-${file.replace('.md', '.mm.html')}`),
                    this.wrapHTML(content.toString())
                );
                
                // Generate SVG required output
                await fs.writeFile(
                    path.join(this.baseDir, 'output', `required-${file.replace('.md', '.mm.svg')}`),
                    this.generateSVG(content.toString())
                );
            }
        }
    }

    wrapHTML(content) {
        return `<!DOCTYPE html>
<html>
<head>
    <title>Markmap</title>
</head>
<body>
    <div class="markmap">
        ${content}
    </div>
</body>
</html>`;
    }

    generateSVG(content) {
        // Simple SVG wrapper for test purposes
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
    <text x="10" y="20">Test SVG for: ${content.split('\n')[0]}</text>
</svg>`;
    }

    async cleanup() {
        try {
            await fs.rm(this.baseDir, { recursive: true, force: true });
        } catch (error) {
            logger.error('Cleanup error:', error);
        }
    }
}

export default TestDataGenerator;

================
File: tests/tests-support/jasmine-browser.json
================
{
  "srcDir": "src",
  "srcFiles": [
    "**/*.js"
  ],
  "specDir": "spec",
  "specFiles": [
    "**/*[sS]pec.js"
  ],
  "helpers": [
    "helpers/**/*.js"
  ],
  "env": {
    "stopSpecOnExpectationFailure": false,
    "stopOnSpecFailure": false,
    "random": true
  },
  "browser": {
    "name": "firefox"
  }
}

================
File: tests/about.md
================
```sh
cd ~/github-danny/transmissions # my local dir

npm test -- tests/unit/ProcessorSettings.spec.js

npm test -- tests/integration/string-filter.spec.js


npm test -- tests/unit/Application.spec.js

npm test -- tests/integration/application-manager.spec.js


```

================
File: types/grapoi.d.ts
================
import { DatasetCore, Quad, Term } from "@rdfjs/types";

// Grapoi interface
interface Grapoi extends PathList {
    addList(predicates: Term | Term[], items: Term | Term[]): Grapoi;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): Grapoi;
    base(base: Term | Term[]): Grapoi;
}

// Edge interface
interface Edge {
    dataset: DatasetCore;
    end: string;
    quad: Quad;
    start: string;
    term: Term;
    graph: Term;
    startTerm: Term;
}

// Instruction interface
interface Instruction {
    operation?: string;
    quantifier?: string;
    start?: string;
    end?: string;
    subjects?: Term[];
    predicates?: Term[];
    objects?: Term[];
    graphs?: DatasetCore[];
    items?: Term[];
    callback?: (edge: Edge, ptr: Path | PathList) => Path | PathList;
}

// Path interface
interface Path {
    addList(predicates: Term | Term[], items: Term | Term[]): Path;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): Path;
    deleteIn(predicates: Term | Term[], subjects: Term | Term[]): Path;
    deleteList(predicates: Term | Term[]): Path;
    deleteOut(predicates: Term | Term[], objects: Term | Term[]): Path;
    extend(edge: Edge): Path;
    execute(instruction: Instruction): Path;
}

// PathList interface
interface PathList {
    addList(predicates: Term | Term[], items: Term | Term[]): PathList;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): PathList;
    deleteIn(predicates: Term | Term[], subjects: Term | Term[]): PathList;
    deleteList(predicates: Term | Term[]): PathList;
    deleteOut(predicates: Term | Term[], objects: Term | Term[]): PathList;
    distinct(): PathList;
    in(predicates: Term | Term[], subjects: Term | Term[]): PathList;
    isAny(): boolean;
    isList(): boolean;
    list(): Iterator<Term> | undefined;
    map(callback: Function): PathList[];
    out(predicates: Term | Term[], objects: Term | Term[]): PathList;
    quads(): Iterator<Quad>;
    execute(instruction: Instruction): PathList[];
}

================
File: types/processor.d.ts
================
import { Term, Dataset, NamedNode } from '@rdfjs/types';
import { EventEmitter } from 'events';

export interface ProcessorConfig {
    dataset?: Dataset;
    [key: string]: any;
}

export interface ProcessorMessage {
    content?: any;
    filepath?: string;
    done?: boolean;
    tags?: string;
    [key: string]: any;
}

export interface ProcessorSettings {
    config: ProcessorConfig;
    settingsNode: Term | null;
    getValues(property: Term, fallback?: any): string[];
    getValue(property: Term, fallback?: any): string | undefined;
}

export interface IProcessor {
    config: ProcessorConfig;
    settings: ProcessorSettings;
    messageQueue: { message: ProcessorMessage }[];
    processing: boolean;
    outputs: any[];
    settingsNode?: Term;
    message?: ProcessorMessage;

    getValues(property: Term, fallback?: any): string[];
    getProperty(property: Term, fallback?: any): string | undefined;
    preProcess(message: ProcessorMessage): Promise<void>;
    postProcess(message: ProcessorMessage): Promise<void>;
    process(message: ProcessorMessage): Promise<void>;
    receive(message: ProcessorMessage): Promise<void>;
    enqueue(message: ProcessorMessage): Promise<void>;
    executeQueue(): Promise<void>;
    emit(event: string, message: ProcessorMessage): Promise<ProcessorMessage>;
    getOutputs(): any[];
}

export interface StringFilterConfig extends ProcessorConfig {
    includePatterns?: string[];
    excludePatterns?: string[];
}

export interface IStringFilter extends IProcessor {
    initialized: boolean;
    includePatterns: string[];
    excludePatterns: string[];
    initialize(): Promise<void>;
    matchPattern(filePath: string, pattern: string): boolean;
    isAccepted(filePath: string): boolean;
}

================
File: _README.md
================
# transmissions

After _No Code_ and _Lo Code_ comes _Marginally Less Code_

**Transmissions** is a micro-framework intended to simplify construction of small pipeliney data processing applications in JavaScript (assuming you are already familiar with JavaScript and RDF).

The code is in active development, ie. **not stable**, subject to arbitrary changes.

A bit like `make` or a `package.json` builder. But much harder work (and fun).

Applications are defined in several places, the bits of interest are eg. Postcraft's [transmissions.ttl](https://github.com/danja/transmissions/blob/main/src/applications/postcraft/transmissions.ttl) and [services.ttl](https://github.com/danja/transmissions/blob/main/src/applications/postcraft/services.ttl).
The former defines the flow, the latter config of the services (under [src/services](https://github.com/danja/transmissions/tree/main/src/services)). The runtime instance of the application is given in the target [manifest.ttl](https://github.com/danja/postcraft/blob/main/danny.ayers.name/manifest.ttl).

### Installation etc.

This is not ready yet. But if you really must...

Make a fresh dir. Clone this repo and [Postcraft](https://github.com/danja/postcraft) into it.

```
cd transmissions
npm i
```

This may or may not work :

```
npm run test
```

Then if you do :

```
./trans postcraft /home/danny/github-danny/postcraft/danny.ayers.name
```

it may build a site (my blog - this is dogfooding to the max) under `public/home`

```
./trans
```

on its own should list the applications available. Most of these won't work, the code has been shapeshifting a lot.

### Status

**2024-09-02** Getting used as a serrrrriously over-engineered, feature-lacking static site builder, proof of concept is [Postcraft](https://github.com/danja/postcraft), as evinced by my [blog](https://danny.ayers.name/) (where, for now at least you will find update on this). But it mostly works as intended. Docs lagging. But now I have a documentation engine...

Documentation will be lagging behind code, be incomplete and out of date.

**2024-03-24** : a couple of simple data processing pipelines working and wired up as Jasmine e2e tests in place; started to develop actually useful pipelines for [foaf-archive](https://github.com/danja/foaf-archive) project

## Motivation

This was prompted by something of a ~~perfect storm~~ serendipitous convergence of ideas, requirements and environment.

- I had the realization that much of the software I want to write in the near future has the same basic high level **architecture** : pipeline-like, ie. a series of steps each of which transform data from one form into another ([Wikipedia](<https://en.wikipedia.org/wiki/Pipeline_(software)>)).
- **Pipelines** are approachable using concepts from Design Patterns like [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection), [Inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) etc. A key benefit of such patterns is that, because the components are loosely coupled, they can largely be developed in isolation as small standalone units before integration into a larger application.
- **Large Language Models** currently struggle with large codebases and complex architectures (mostly due to [context window](https://en.wikipedia.org/wiki/Large_language_model#Prompt_engineering,_attention_mechanism,_and_context_window) limitations). But they are very good at building small, simple, self-contained units of code.

reused in different contexts.

_I'm writing this with GitHub Copilot enabled for markdown, which can be helpful, but sometimes it goes off on one... After the first point above it offered :_

```
This is true of a blog engine, a personal knowledge management system, a chatbot, a mail archive miner, a web scraper, a data visualizer, a data importer/exporter, a data transformer, a data validator, a data filter, a data aggregator, a data splitter, a data joiner, a data normalizer, a data summarizer, a data classifier, a data indexer, a data search engine, a data storage system, a data retrieval system, a data synchronization system, a data backup system, a data migration system, a data versioning system, a data sharing system, a data access control system, a data privacy system, a data security system, a data integrity system, a data quality system, a data governance system, a data provenance system, a data lineage system, a data lifecycle system, a data archiving system, a data retention system, a data deletion system, a data recovery system, a data discovery system, a data exploration system, a data analysis system, a data visualization system, a data reporting system, a data monitoring system, a data alerting system, a data forecasting system, a data prediction system, a data recommendation system, a data personalization system, a data optimization system, a data simulation system, a data modeling system, a data inference system, a data learning system, a data reasoning system, a data decision system, a data planning system, a data execution system, a data monitoring system, a data feedback system, a data control system, a data automation system, a data orchestration system, a data integration system, a data federation system, a data interoperability system, a data exchange system, a data transformation system, a data migration system, a data synchronization system, a data replication system, a data federation system, a data virtualization system, a data streaming system, a data batch system, a data real-time system, a data near-real-time system, a data historical system, a data temporal system, a data spatial system, a data geospatial system, a data network system, a data graph system, a data tree system, a data list system, a data set system, a data table system, a data document system, a data record system, a data entity system, a data attribute system, a data value system, a data type system, a data format system, a data encoding system, a data serialization
```

_... which is a little over the top, but it's a fair list of things that might be helped by a micro-framework like this. Remarkably the first 5 are pretty much my immediate intended uses for this._

**Docs below need updating**

for later :

The [Community Solid Server](https://github.com/CommunitySolidServer/CommunitySolidServer) uses [Components.js](https://componentsjs.readthedocs.io/en/latest/) to specify how modules and components need to be wired together at runtime. Components.js is a dependency injection framework for JavaScript applications.

## What it is

A low-level system for data processing pipelines/networks. Wherever convenient functionality will be defined declaratively with JSON-LD configuration files.

Dependency injection is used internally to allow loose coupling of components.

## What it isn't

There are several sophisticated frameworks for building interfaces between software applications and creating data processing networks. NodeRed, NoFlo etc. This is not one of them. This is much more basic and bare bones, down in the details.

See also [David Booth](https://github.com/dbooth-boston)'s [RDF Pipeline Framework](https://github.com/rdf-pipeline)

_I do eventually want to use this with NodeRed or whatever, but the entities created by transmissions will be at the level of nodes in such networks, not the network itself._

## Motivation

I'm in the process of writing yet another blog engine (Postcraft). I've also started working on a playground for interconnecting intelligent agents in an XMPP multiuser chat environment (Kia). I'm also revising a system for managing a personal knowledge base in the world of LLMs (HKMS). These all share functionality around connectivity to external data/messaging systems and internal data transformation. Might as well write this bit once only, and avoid thinking about software architecture more than I have to.

### Goals

To facilate :

- rapid development of small applications
- reuse of components in a loosely-couple environment
- versatility

### Soft Goals

- performance - low on the list
- scalability - ditto
- security - ditto

================
File: _transmissions.config.json
================
{
    "paths": {
        "applications": {
            "include":
        }
        [
            "applications"
        ]
    }
}

================
File: .babelrc
================
{
  "plugins": ["@babel/syntax-dynamic-import"],
  "presets": [
    [
      "@babel/preset-env",
      {
        "modules": false
      }
    ]
  ]
}

================
File: .gitignore
================
**/src-old
**/*\ copy.js

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "allowSyntheticDefaultImports": true,
    "baseUrl": "./",
    "paths": {
      "*": ["node_modules/*", "types/*"]
    }
  },
  "include": [
    "src/**/*",
    "src/api/cli/run.js",
    "../trans-apps/applications/git-apps/github_",
    "src-old/CommandUtilsNO.js",
    "../trans-apps/applications/markmap"
  ],
  "exclude": ["node_modules", "**/node_modules/*"],
  "typeAcquisition": {
    "include": ["@rdfjs/types", "grapoi"]
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "type": "module",
  "version": "1.0.0",
  "description": "Transmissions",
  "name": "transmissions",
  "scripts": {
    "test": "jasmine --config=config/jasmine.json --reporter=tests/tests-support/helpers/reporter.js",
    "cov": "nyc -a --include=src --reporter=lcov npm run test",
    "docs": "jsdoc -c config/jsdoc.json",
    "build": "webpack --mode=production --node-env=production",
    "build:dev": "webpack --mode=development",
    "build:prod": "webpack --mode=production --node-env=production",
    "rp-no": "node --no-warnings $(which repomix) -c config/repomix.config-small.json . && node --no-warnings $(which repomix) -c config/repomix.config-large.json . && node --no-warnings $(which repomix) -c config/repomix.config-docs.json .",
    "rp": "repomix -c config/repomix.config-large.json .",
    "watch": "webpack --watch",
    "serve": "webpack serve"
  },
  "nyc": {
    "report-dir": "spec/coverage",
    "exclude": [
      "spec/**/*"
    ]
  },
  "devDependencies": {
    "@babel/core": "^7.23.7",
    "@babel/preset-env": "^7.23.8",
    "autoprefixer": "^10.4.17",
    "babel-loader": "^9.1.3",
    "chai": "^5.0.3",
    "css-loader": "^6.9.1",
    "html-webpack-plugin": "^5.6.0",
    "jasmine": "^5.1.0",
    "jasmine-browser-runner": "^2.3.0",
    "jasmine-core": "^5.1.1",
    "jasmine-spec-reporter": "^7.0.0",
    "jsdoc": "^4.0.2",
    "mini-css-extract-plugin": "^2.7.7",
    "nyc": "^17.1.0",
    "postcss": "^8.4.33",
    "postcss-loader": "^8.0.0",
    "prettier": "^3.2.4",
    "style-loader": "^3.3.4",
    "webpack": "^5.90.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1",
    "workbox-webpack-plugin": "^7.0.0"
  },
  "dependencies": {
    "@dotenvx/dotenvx": "^1.14.2",
    "@rdfjs/formats": "^4.0.0",
    "@rdfjs/parser-n3": "^2.0.2",
    "axios": "^1.6.8",
    "cheerio": "^1.0.0-rc.12",
    "cors": "^2.8.5",
    "d3": "^7.9.0",
    "ignore": "^7.0.0",
    "jsdom": "^25.0.0",
    "lodash": "^4.17.21",
    "loglevel": "^1.9.2",
    "marked": "^12.0.1",
    "marked-code-format": "^1.1.6",
    "marked-custom-heading-id": "^2.0.10",
    "marked-footnote": "^1.2.4",
    "markmap-lib": "^0.18.9",
    "markmap-render": "^0.17.0",
    "markmap-toolbar": "^0.17.0",
    "markmap-view": "^0.17.0",
    "node-mime-types": "^1.1.2",
    "nunjucks": "^3.2.4",
    "queue": "^7.0.0",
    "rdf-ext": "^2.5.2",
    "rdf-utils-fs": "^3.0.0",
    "repomix": "^0.2.12",
    "string-to-stream": "^3.0.1",
    "yargs": "^17.7.2"
  }
}

================
File: README.md
================
# Transmissions

**2025-02-09** fixing up, aiming for a release (that works away from my own desktop) soon

================
File: trans
================
#!/bin/bash

# use 'chmod +x run' to make this executable

# Execute the Node.js script with Node
node src/api/cli/run.js "$@"



================================================================
End of Codebase
================================================================
