This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T18:47:15.720Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
Transmissions source code

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
output/
  output-01.md
src/
  api/
    cli/
      about.md
      run.js
    common/
      CommandUtils.js
    http/
      client/
        css/
          client.css
        js/
          client.js
          TransmissionsClient.js
        test-client.html
      server/
        WebRunner.js
      about.md
      openapi-spec.yaml
    about.md
  applications/
    _app-template/
      about.md
      config.ttl
      transmissions.ttl
    _old-postcrafts/
      postcraft/
        about.md
        config.ttl
        transmissions.ttl
      postcraft-clear-cache/
        about.md
        config.ttl
        transmissions.ttl
      postcraft-previous/
        about.md
        config.ttl
        transmissions.ttl
      postcraft-render1/
        data/
          cache/
            2023-10-27_hello.md
            2025-01-08_hello-again.md
        sparql/
          diamonds/
            select-blogposting.njk
            update-blogposting.njk
          endpoint.json
        about.md
        config.ttl
        transmissions.ttl
      postcraft-render2/
        data/
          cache/
            2023-10-27_hello.md
            2025-01-08_hello-again.md
        about.md
        config.ttl
        transmissions.ttl
    claude-json-converter/
      data/
        input/
          input-01.json
          users.json
      about.md
      config.ttl
      transmissions copy.ttl
      transmissions.ttl
    echo/
      about.md
      config.ttl
      transmissions.ttl
    example-application/
      about.md
      config.ttl
      transmissions.ttl
    file-pipeline/
      config.ttl
      transmissions.ttl
    globbo/
      about.md
      config.ttl
      transmissions.ttl
    html-to-md/
      about.md
      config.ttl
      transmissions.ttl
    link-lister/
      about.md
      config.ttl
      transmissions.ttl
    md-to-sparqlstore/
      data/
        input/
          about.ttl
          ignore-me.txt
          turtle-example.ttl
      sparql/
        endpoint.json
        example-article.ttl
      templates/
        turtle-template.html
      about.md
      config.ttl
      transmissions.ttl
    pdf-to-html/
      about.md
      config.ttl
      transmissions.ttl
    selfie/
      about.md
      config.ttl
      transmissions.ttl
    string-pipeline/
      config.ttl
      transmissions.ttl
    terrapack/
      _old/
        code-comment-stripper.js
        terrapack-about.md
        terrapack-handover.md
        test-file-container-about.md
        test-file-container-config.txt
        test-file-container-transmissions.txt
      data/
        input/
          subdir/
            subby.md
          2023-10-27_hello.md
          2025-01-08_hello-again.md
          exclude.me
      about.md
      config.ttl
      file-container-test-application.txt
      terrapack-flow.md
      terrapack-sources.md
      transmissions.ttl
    test_blanker/
      data/
        input/
          input-01.json
        output/
          output-01.json
          required-01.json
      about.md
      config.ttl
      transmissions.ttl
    test_config-settings/
      about.md
      config.ttl
      test-settings-simple.js
      transmissions.ttl
    test_config-settings copy/
      about.md
      config.ttl
      transmissions.ttl
    test_configmap/
      data/
        input/
          input-01.md
        output/
          output-01.md
          required-01.md
      about.md
      config.ttl
      manifest.ttl
      simple.js
      test-config.json
      transmissions.ttl
    test_dirwalker/
      about.md
      config.ttl
      transmissions.ttl
    test_env-loader/
      about.md
      config.ttl
      transmissions.ttl
    test_file-copy-remove/
      data/
        several-full/
          one.txt
          two.txt
        single-full/
          one.txt
        start/
          one.txt
          two.txt
      about.md
      config.ttl
      init.sh
      transmissions.ttl
    test_file-to-sparqlstore/
      data/
        input/
          input.md
      diamonds/
        select-blogposting.njk
        update-blogposting.njk
      docs/
        handover-doc.md
        handover.ttl
        sparql-processors-docs.md
        test-app-docs.md
      examples/
        blog-post-rdf.txt
        sparql-queries.md
      about.md
      config.ttl
      endpoint.json
      python-test.py
      test-queries.sh
      transmissions.ttl
    test_filename-mapper/
      data/
        input/
          input-01.txt
        output/
          required-01.txt
      about.md
      config.ttl
      filename-mapper-simple.js
      transmissions.ttl
    test_filereader/
      data/
        input/
          input.md
      about.md
      config.ttl
      transmissions.ttl
    test_foreach/
      about.md
      transmissions.ttl
    test_fork/
      about.md
      config.ttl
      transmissions.ttl
    test_fork-unfork/
      about.md
      config.ttl
      transmissions.ttl
    test_fs-rw/
      data/
        input/
          input-01.md
        output/
          required-01.md
      about.md
      config.ttl
      simple.js
      test-config.json
      transmissions.ttl
    test_http-server/
      data/
        input/
          index.html
          metrics.js
      about.md
      config.ttl
      shutdown-client-auth.js
      test-shutdown.js
      transmissions.ttl
    test_multi-pipe/
      config.ttl
      transmissions.ttl
    test_nop/
      about.md
      config.ttl
      transmissions.ttl
    test_ping/
      config.ttl
      transmissions.ttl
    test_restructure/
      data/
        input/
          input-01.json
        output/
          required-01.json
      about.md
      config.ttl
      simple.js
      transmissions.ttl
    test_two-transmissions/
      config.ttl
      transmissions.ttl
  engine/
    ApplicationManager.js
    ModuleLoader.js
    ModuleLoaderFactory.js
    Procurer.js
    TransmissionBuilder.js
    WorkerPool.js
  model/
    Application.js
    Connector.js
    Transmission.js
  processors/
    base/
      AbstractProcessorFactory.js
      Processor.js
      ProcessorSettings.js
    example-group/
      ExampleProcessor.js
      ExampleProcessorsFactory.js
    flow/
      DeadEnd.js
      FlowProcessorsFactory.js
      ForEach.js
      Fork.js
      Halt.js
      NOP.js
      Ping.js
      Unfork.js
    fs/
      DirWalker.js
      FileCopy.js
      FilenameMapper.js
      FileReader.js
      FileRemove.js
      FileWriter.js
      FsProcessorsFactory.js
    github/
      GitHubList_no-pag.js
      GitHubList.js
      GitHubProcessorsFactory.js
    http/
      services/
        MetricsService.js
        ShutdownService.js
      HttpClient.js
      HttpProcessorsFactory.js
      HttpProxy.js
      HttpServer.js
      HttpServerWorker.js
    json/
      Blanker.js
      JSONProcessorsFactory.js
      JsonRestructurer.js
      JSONWalker.js
      Restructure.js
      ValueConcat.js
    markup/
      LinkFinder.js
      MarkdownToHTML.js
      MarkupProcessorsFactory.js
      MetadataExtractor.js
    mcp/
      McpClient.js
      McpProcessorsFactory.js
      McpServer.js
    postcraft/
      AtomFeedPrep.js
      EntryContentToPagePrep.js
      FrontPagePrep.js
      PostcraftDispatcher.js
      PostcraftPrep.js
      PostcraftProcessorsFactory.js
    protocols/
      HttpGet.js
      ProtocolsProcessorsFactory.js
    rdf/
      ConfigMap.js
      DatasetReader.js
      RDFConfig.js
      RDFProcessorsFactory.js
    sparql/
      component-interaction.mermaid
      config.js
      custom-predicates.js
      handover-doc (1).md
      handover-doc.md
      handover-metadata.txt
      language-processing.mermaid
      message-processing-flow.mermaid
      SessionEnvironment.js
      SPARQLProcessorsFactory.js
      SPARQLSelect.js
      SPARQLUpdate.js
      system-architecture.mermaid
      validator.js
    staging/
      MarkdownFormatter.js
      StagingProcessorsFactory.js
      TurtleFormatter.js
    system/
      EnvLoader.js
      SystemProcessorsFactory.js
    terrapack/
      comment-stripper.js
      CommentStripper.js
      file-container.js
      FileContainer.js
      terrapack-factory.js
      TerrapackProcessorsFactory.js
    test/
      _old/
        AppendProcess.js
        FileSink.js
        FileSource.js
        StringSink.js
        StringSource.js
        TestProcessorsFactory.js
      TestProcessorsFactory.js
      TestSettings.js
    text/
      LineReader.js
      StringFilter.js
      StringMerger.js
      StringReplace.js
      Templater.js
      TextProcessorsFactory.js
    unsafe/
      ExampleProcessor.js
      RunCommand.js
      UnsafeProcessorsFactory.js
    util/
      CaptureAll.js
      SetMessage.js
      ShowConfig.js
      ShowMessage.js
      ShowSettings.js
      ShowTransmission.js
      Stash.js
      UtilProcessorsFactory.js
      WhiteboardToMessage.js
    xmpp/
      XmppClient.js
      XmppProcessorsFactory.js
    about.md
  simples/
    env-loader/
      about.md
      env-loader.js
    nop/
      nop.js
      simple-runner.js
    set-message/
      set-message.js
  utils/
    cache.js
    footpath.js
    GrapoiHelpers.js
    Logger.js
    MockApplicationManager.js
    ns.js
    RDFUtils.js
    StringUtils.js
    t2j.js
    test_runner.js
    text-utils.js
  terrapack.config.json
  terrapack.config.json_done.txt
staging/
  schema-documentation.md
  template-cli.js
  template-generator.js
  template-tool-docs.md
  transmissions-prompt-template.md
  transmissions-template-schema.json
  transmissions-template-turtle.txt
  transmissions-testing-template.md
test-failures/
  test_env-loader/
    2024-11-28T17-44-11.419Z/
      test-output.json
    2024-11-28T17-46-20.677Z/
      test-output.json
    2024-11-28T18-31-38.300Z/
      test-output.json
    2024-11-28T18-34-16.177Z/
      test-output.json
  test_http-server/
    2024-11-30T12-30-16.673Z/
      test-output.json
tests/
  examples/
    test-data-usage.js
  helpers/
    file-test-helper.js
    reporter.js
    test-data-generator.js
  integration/
    app-context.spec.js
    application-manager.spec.js
    configmap.spec.js
    file-container-integration-test.js
    filename-mapper.spec.js
    fork.spec.js
    fs-rw_simple.spec.js
    fs-rw.spec.js
    http-server.spec.js
    markmap.spec.js
    restructure_simple.spec.js
    restructure.spec.js
    run-command.spec.js
    string-filter.spec.js
    test_apps.spec.js
    test-data-generator_string-filter.js
    test-settings-integration.js
  support/
    jasmine-browser.json
  unit/
    _old/
      ProcessorSettings.sp_ec.js
    Application.spec.js
    file-container-unit-test.js
    filename-mapper.spec.js
    http-server_MetricsService.spec.js
    http-server_ShutdownService.spec.js
    markmap.spec..js
    NOP.spec.js
    PostcraftPrep.spec.js
    ProcessorSettings.spec.js
    RunCommand.spec.js
    StringFilter.spec.js
    StringReplace.spec.js
    test.settings.spec.js
    updated-shutdown-test.js
  about.md
types/
  grapoi.d.ts
  processor.d.ts
.babelrc
.gitignore
jasmine.json
jsconfig.json
jsdoc.json
LICENSE
package.json
postcss.config.js
README.md
rename-script.sh
terrapack.config.json
trans
users.json
webpack.config.js

================================================================
Files
================================================================

================
File: output/output-01.md
================
Hello!

================
File: src/api/cli/about.md
================
# About : CLI

`src/api/cli/*`

The CLI entry point `./trans` calls `src/api/cli/run.js` which uses [yargs](https://yargs.js.org/) - _tee hee_, they say it best :

> Yargs be a node.js library fer hearties tryin' ter parse optstrings.

`src/api/cli/run.js` then calls `src/api/common/CommandUtils.js`. That does a little bit of path-splitting and simple logic, calling on `src/core/ApplicationManager.js` to get things going.

================
File: src/api/cli/run.js
================
import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
import CommandUtils from '../common/CommandUtils.js'
import WebRunner from '../http/server/WebRunner.js'
import chalk from 'chalk'
import { readFileSync } from 'fs'
import { dirname, join } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const packageJson = JSON.parse(readFileSync(join(__dirname, '../../../package.json')))
const buildInfo = process.env.BUILD_INFO || 'dev'
const version = `${packageJson.version} (${buildInfo})`

const banner = `
  _____
 |_   _| __ __ _ _ __  ___
   | || '__/ _\` | '_ \\/ __|
   | || | | (_| | | | \\__ \\
   |_||_|  \\__,_|_| |_|___/
             ${version.padStart(10).padEnd(20)}
         ${new Date().toISOString().split('T')[0]}
`

async function main() {
    console.log(chalk.cyan(banner))
    const commandUtils = new CommandUtils()

    const yargsInstance = yargs(hideBin(process.argv))
        .usage(chalk.cyan('Usage: ./trans [application][.subtask] [options] [target]\n  Run without arguments to list available applications.'))
        .option('verbose', {
            alias: 'v',
            describe: chalk.yellow('Enable verbose output'),
            type: 'boolean'
        })
        .option('silent', {
            alias: 's',
            describe: chalk.yellow('Suppress all output'),
            type: 'boolean'
        })
        .option('message', {
            alias: 'm',
            describe: chalk.yellow('Input message as JSON'),
            type: 'string',
            coerce: JSON.parse
        })
        .option('test', {
            alias: 't',
            describe: chalk.yellow('Run in test mode'),
            type: 'boolean',
            default: false
        })
        .option('web', {
            alias: 'w',
            describe: chalk.yellow('Start web interface'),
            type: 'boolean'
        })
        .option('port', {
            alias: 'p',
            describe: chalk.yellow('Port for web interface'),
            type: 'number',
            default: 4200
        })

    yargsInstance.command('$0 [application] [target]', chalk.green('runs the specified application\n'), (yargs) => {
        return yargs
            .positional('application', {
                describe: chalk.yellow('the application to run')
            })
            .positional('target', {
                describe: chalk.yellow('the target of the application')
            })
    }, async (argv) => {


        if (!argv.application) {
            console.log(chalk.cyan('Available applications:'))
            const apps = await commandUtils.listApplications()
            console.log(chalk.green(apps.join('\n')))
            yargsInstance.showHelp()
            return
        }
        const flags = { "web": argv.web, "port": argv.port, "verbose": argv.verbose, "silent": argv.silent, "test": argv.test }
        await commandUtils.begin(argv.application, argv.target, argv.message, flags)
    })

    await yargsInstance.argv
}

main().catch(console.error)

================
File: src/api/common/CommandUtils.js
================
import path from 'path'
import fs from 'fs/promises'
import logger from '../../utils/Logger.js'

import ApplicationManager from '../../engine/ApplicationManager.js'
import WebRunner from '../http/server/WebRunner.js'

class CommandUtils {

    #appManager

    constructor() {
        this.#appManager = new ApplicationManager()
    }



    async begin(application, target, message = {}, flags = {}) {



        var debugLevel = (flags.verbose || flags.test) ? "debug" : "info"
        if (!flags.verbose) logger.silent = flags.silent
        logger.setLogLevel(debugLevel)

        logger.debug('\nCommandUtils.begin()')
        logger.debug('CommandUtils.begin, process.cwd() = ' + process.cwd())
        logger.debug('CommandUtils.begin, flags = ' + flags)
        logger.reveal(flags)
        logger.debug('CommandUtils.begin, application = ' + application)
        logger.debug('CommandUtils.begin, target = ' + target)
        logger.debug(`CommandUtils.begin, message = ${message}`)


        if (target && !target.startsWith('/')) {
            target = path.join(process.cwd(), target)
        }

        var { appName, appPath, subtask } = CommandUtils.splitName(application)


        logger.debug(`\n
    after split :
    appName = ${appName}
    appPath = ${appPath}
    subtask = ${subtask}
    target = ${target}`)

        this.#appManager = await this.#appManager.initialize(appName, appPath, subtask, target, flags)

        if (flags.web) {
            const webRunner = new WebRunner(this.#appManager, flags.port)
            await webRunner.start()
            return
        }

        return await this.#appManager.start(message)
    }

    static splitName(fullPath) {
        logger.debug(`\nCommandUtils.splitName, fullPath  = ${fullPath}`)
        const parts = fullPath.split(path.sep)
        logger.debug(`\nCommandUtils.splitName, parts  = ${parts}`)
        var lastPart = parts[parts.length - 1]

        var task = false
        if (lastPart.includes('.')) {
            const split = lastPart.split('.')
            task = split[1]
            lastPart = split[0]
        }
        var appPath = parts.slice(0, parts.length - 1).join(path.sep)
        appPath = path.join(appPath, lastPart)



        logger.debug(`CommandUtils.splitName, appName:${lastPart}, appPath:${appPath}, task:${task},`)

        return { appName: lastPart, appPath: appPath, task: task }
    }

    async listApplications() {
        return await this.#appManager.listApplications()
    }


    static async parseOrLoadContext(contextArg) {
        logger.debug(`CommandUtils.parseOrLoadContext(), contextArg = ${contextArg}`)
        let message = {}
        try {
            message.payload = JSON.parse(contextArg)
        } catch (err) {
            logger.debug('*** Loading JSON from file...')
            const filePath = path.resolve(contextArg)
            const fileContent = await fs.readFile(filePath, 'utf8')
            message.payload = JSON.parse(fileContent)
        }
        return message
    }
}

export default CommandUtils

================
File: src/api/http/client/css/client.css
================
body {
    font-family: system-ui, -apple-system, sans-serif;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
    line-height: 1.5;
}

.container {
    display: grid;
    gap: 1rem;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

label {
    font-weight: 500;
}

input,
textarea {
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    font-family: monospace;
}

textarea {
    min-height: 120px;
    resize: vertical;
}

button {
    padding: 0.75rem 1rem;
    background: #0066cc;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
}

button:hover:not(:disabled) {
    background: #0052a3;
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

pre {
    background: #f5f5f5;
    padding: 1rem;
    overflow-x: auto;
    border-radius: 4px;
    margin: 0;
    font-size: 14px;
}

.status {
    padding: 1rem;
    margin: 0;
    border-radius: 4px;
    font-size: 14px;
}

.status.error {
    background: #fff5f5;
    color: #c53030;
    border: 1px solid #feb2b2;
}

.status.success {
    background: #f0fff4;
    color: #276749;
    border: 1px solid #9ae6b4;
}

.status.info {
    background: #ebf8ff;
    color: #2c5282;
    border: 1px solid #90cdf4;
}

.metrics {
    display: grid;
    grid-template-columns

================
File: src/api/http/client/js/client.js
================
import TransmissionsClient from './TransmissionsClient.js'

class TestClientUI {
    constructor() {
        this.elements = {
            baseUrl: document.getElementById('baseUrl'),
            application: document.getElementById('application'),
            message: document.getElementById('message'),
            sendButton: document.getElementById('sendButton'),
            status: document.getElementById('status'),
            response: document.getElementById('response'),
            metrics: document.getElementById('metrics')
        }


        if (!this.elements.baseUrl.value) {
            this.elements.baseUrl.value = 'http://localhost:4200/api'
        }

        this.initialize()
        this.bindEvents()
    }

    initialize() {
        try {
            this.client = new TransmissionsClient(this.elements.baseUrl.value)
            this.updateStatus(true)
            this.startMetricsUpdate()
        } catch (err) {
            console.error('Initialization error:', err)
            this.handleError(err)
        }
    }

    bindEvents() {
        this.elements.sendButton.addEventListener('click', () => this.sendRequest())
        this.elements.baseUrl.addEventListener('change', () => {
            try {
                this.client.setBaseUrl(this.elements.baseUrl.value)
                this.updateStatus(true)
            } catch (err) {
                this.handleError(err)
            }
        })
    }

    updateStatus(isOnline) {
        const { status: statusEl, sendButton } = this.elements
        if (isOnline) {
            statusEl.className = 'status success'
            statusEl.textContent = 'Server online'
            sendButton.disabled = false
        } else {
            statusEl.className = 'status error'
            statusEl.textContent = 'Server offline'
            sendButton.disabled = true
        }
    }

    handleError(error) {
        const { status: statusEl } = this.elements
        statusEl.className = 'status error'
        statusEl.textContent = `Error: ${error.message}`
        console.error('Client error:', error)
    }

    startMetricsUpdate() {
        setInterval(() => {
            if (this.client) {
                const metrics = this.client.getMetrics()
                this.updateMetricsDisplay(metrics)
            }
        }, 1000)
    }

    updateMetricsDisplay(metrics) {
        if (!metrics) return

        this.elements.metrics.innerHTML = `
            <div class="metric-card">
                <div>Requests</div>
                <div class="metric-value">${metrics.requests}</div>
            </div>
            <div class="metric-card">
                <div>Errors</div>
                <div class="metric-value">${metrics.errors}</div>
            </div>
            <div class="metric-card">
                <div>Uptime</div>
                <div class="metric-value">${metrics.uptime}s</div>
            </div>
        `
    }

    async sendRequest() {
        const { application, message, response: responseEl, status: statusEl, sendButton } = this.elements

        try {
            let messageData
            try {
                messageData = JSON.parse(message.value)
            } catch (err) {
                throw new Error('Invalid JSON in message field')
            }

            statusEl.className = 'status info'
            statusEl.textContent = 'Sending request...'
            sendButton.disabled = true

            const result = await this.client.runApplication(application.value, messageData)

            if (result.success) {
                statusEl.className = 'status success'
                statusEl.textContent = 'Request successful'
                responseEl.textContent = JSON.stringify(result.data, null, 2)
            } else {
                throw new Error(result.error || 'Request failed')
            }
        } catch (err) {
            statusEl.className = 'status error'
            statusEl.textContent = `Error: ${err.message}`
            responseEl.textContent = ''
            console.error('Request error:', err)
        } finally {
            sendButton.disabled = false
        }
    }
}

// Initialize the UI when the page loads
const ui = new TestClientUI()

// Handle global errors
window.addEventListener('unhandledrejection', event => {
    console.error('Unhandled promise rejection:', event.reason)
    if (ui) {
        ui.handleError({
            message: 'Unhandled error: ' + event.reason.message
        })
    }
})

================
File: src/api/http/client/js/TransmissionsClient.js
================
class TransmissionsClient {
    constructor(baseUrl) {
        if (!baseUrl) {
            throw new Error('Base URL is required')
        }
        this.baseUrl = baseUrl
        this.metrics = {
            requests: 0,
            errors: 0,
            startTime: Date.now()
        }
    }

    async runApplication(application, message = {}) {
        if (!application) {
            throw new Error('Application name is required')
        }

        try {
            this.metrics.requests++
            console.log('Sending request:', {
                url: `${this.baseUrl}/${application}`,
                body: message
            })

            const response = await fetch(`${this.baseUrl}/${application}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(message)
            })

            if (!response.ok) {
                this.metrics.errors++
                const error = await response.json()
                throw new Error(error.message || 'Request failed')
            }

            return await response.json()
        } catch (err) {
            this.metrics.errors++
            throw err
        }
    }

    getMetrics() {
        return {
            requests: this.metrics.requests,
            errors: this.metrics.errors,
            uptime: Math.floor((Date.now() - this.metrics.startTime) / 1000)
        }
    }

    setBaseUrl(url) {
        if (!url) {
            throw new Error('Base URL is required')
        }
        this.baseUrl = url
    }
}

export default TransmissionsClient

================
File: src/api/http/client/test-client.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Transmissions API Test Client</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="css/client.css">
</head>

<body>
    <h1>Transmissions API Test Client</h1>

    <div class="container">
        <div class="form-group">
            <label for="baseUrl">Base URL:</label>
            <input type="url" id="baseUrl" />
        </div>

        <div class="form-group">
            <label for="application">Application:</label>
            <input type="text" id="application" value="echo" />
        </div>

        <div class="form-group">
            <label for="message">Message (JSON):</label>
            <textarea id="message">{
    "message": "Hello from test client"
}</textarea>
        </div>

        <button id="sendButton">Send Request</button>

        <div id="status" class="status info">Initializing client...</div>

        <div class="metrics" id="metrics">
        </div>

        <div class="form-group">
            <label>Response:</label>
            <pre id="response"></pre>
        </div>
    </div>

    <script type="module" src="js/client.js"></script>
</body>

</html>

================
File: src/api/http/server/WebRunner.js
================
import express from 'express'
import cors from 'cors'
import path from 'path'
import ApplicationManager from '../../../engine/ApplicationManager.js'
import logger from '../../../utils/Logger.js'

class WebRunner {
    constructor(appManager, port = 4000, basePath = '/api') {
        this.appManager = appManager
        this.app = express()
        this.port = port
        this.basePath = basePath
        this.setupMiddleware()
        this.setupRoutes()
        this.requestCount = 0
    }

    setupMiddleware() {

        const corsOptions = {
            origin: (origin, callback) => {
                if (!origin || origin.startsWith('http://localhost')) {
                    callback(null, true)
                } else {
                    callback(new Error('Not allowed by CORS'))
                }
            },
            methods: ['GET', 'POST', 'OPTIONS'],
            allowedHeaders: ['Content-Type'],
            credentials: true
        }
        this.app.use(cors(corsOptions))


        this.app.use(express.json({
            limit: '10mb',
            strict: false,
            verify: (req, res, buf) => {
                try {
                    JSON.parse(buf)
                } catch (e) {
                    logger.error('Invalid JSON:', e)
                }
            }
        }))
    }

    setupRoutes() {
        const router = express.Router()

        router.post('/:application', async (req, res) => {
            logger.log(`AAAA`)
            const requestId = Math.random().toString(36).substring(7)
            const { application } = req.params
            const message = req.body || {}

            logger.info(`[${requestId}] Running application: ${application}`)
            logger.debug(`[${requestId}] Message payload:`, message)

            try {
                logger.log(`BBBB`)
                if (!this.appManager) {
                    throw new Error('Application manager not initialized')
                }
                logger.log(`CCCC`)
                logger.debug(`[${requestId}] Initializing application ${application}`)
                await this.appManager.initialize(application)
                logger.log(`DDDD`)
                message.requestId = requestId
                logger.debug(`[${requestId}] Starting application with message:`, message)
                const result = await this.appManager.start(message)
                logger.log(`EEEE`)
                if (!result) {
                    throw new Error('Application returned no result')
                }
                logger.log(`FFFF`)
                logger.debug(`[${requestId}] Application result:`, result)
                const response = {
                    success: true,
                    requestId: requestId,
                    data: result.whiteboard ?
                        result.whiteboard[result.whiteboard.length - 1] :
                        { message: "Echo response" }
                }
                logger.log(`GGGG`)
                logger.info(`[${requestId}] Application ${application} completed successfully`)
                res.json(response)

            } catch (error) {
                const errorResponse = {
                    success: false,
                    requestId: requestId,
                    error: error.message,
                    details: error.stack,
                    application: application
                }
                logger.log(`error = `)
                logger.reveal(error)
                logger.log(`errorResponse = `)
                logger.reveal(errorResponse)
                logger.error(`[${requestId}] Error running application ${application}:`, error)
                logger.error(`[${requestId}] Stack:`, error.stack)
                logger.debug(`[${requestId}] Context:`, {
                    application,
                    message,
                    headers: req.headers
                })

                res.status(500).json(errorResponse)
            }
        })

        this.app.use(this.basePath, router)
    }

    async start() {
        return new Promise((resolve, reject) => {
            try {
                this.server = this.app.listen(this.port, () => {
                    const endpoint = `http://localhost:${this.port}${this.basePath}`
                    const msg = `Transmissions API server running at ${endpoint}`
                    logger.info('\n' + '='.repeat(msg.length))
                    logger.info(msg)
                    logger.info('='.repeat(msg.length) + '\n')
                    resolve()
                })

                this.server.on('error', (error) => {
                    logger.error('Server error:', error)
                    reject(error)
                })
            } catch (error) {
                logger.error('Failed to start server:', error)
                reject(error)
            }
        })
    }

    async stop() {
        return new Promise((resolve, reject) => {
            if (this.server) {
                logger.info('Shutting down server...')
                this.server.close((err) => {
                    if (err) {
                        logger.error('Error shutting down server:', err)
                        reject(err)
                    } else {
                        logger.info('Server shutdown complete')
                        resolve()
                    }
                })
            } else {
                resolve()
            }
        })
    }
}

export default WebRunner

================
File: src/api/http/about.md
================
```sh
cd ~/github-danny/transmissions/
./trans --verbose --web --port 4200 echo

./trans -v -w -t -p 4200 echo
```

compare with :

```sh
./trans  -v echo
```

#:todo move echo and all the test\_ to applications/system

================
File: src/api/http/openapi-spec.yaml
================
openapi: 3.0.0
info:
  title: Transmissions API
  version: '1.0.0'
  description: API for running Transmissions applications

servers:
  - url: http://localhost:4200/api
    description: Local development server

paths:
  /:
    get:
      summary: Get server status
      responses:
        '200':
          description: Server status information
          content:
            application/json:
              schema:
                type: object
                properties:
                  service:
                    type: string
                    example: 'Transmissions API'
                  version:
                    type: string
                    example: '1.0.0'
                  status:
                    type: string
                    example: 'running'

  /applications:
    get:
      summary: List available applications
      responses:
        '200':
          description: List of available applications
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  applications:
                    type: array
                    items:
                      type: string
                example:
                  success: true
                  applications: ['system/echo', 'test/example']
        '500':
          $ref: '#/components/responses/Error'

  /{application}:
    post:
      summary: Run a Transmissions application
      parameters:
        - name: application
          in: path
          required: true
          schema:
            type: string
          description: Application identifier
          example: 'system/echo'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              description: Application-specific message payload
      responses:
        '200':
          description: Successful application execution
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    type: object
                    description: Application-specific response data
                example:
                  success: true
                  data:
                    message: "Echo response"
        '400':
          description: Invalid request
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                    example: false
                  error:
                    type: string
                    example: 'Invalid JSON payload'
        '500':
          $ref: '#/components/responses/Error'

components:
  responses:
    Error:
      description: Server error
      content:
        application/json:
          schema:
            type: object
            properties:
              success:
                type: boolean
                example: false
              error:
                type: string
                example: 'Internal server error'

================
File: src/api/about.md
================
# transmissions/src/api/

Interfaces for running transmissions.

================
File: src/applications/_app-template/about.md
================
# App Template

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans app-template
```

## Description

---

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/_app-template/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:setDemo a trn:ConfigSet ;
    trn:setValue (trn:sv0)  . # consider using blank nodes
    trn:sv0   trn:key    "demo" ;
            trn:value    "a test value"  .

================
File: src/applications/_app-template/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:mini a trn:Transmission ;
    trn:pipe (:p10 :p20) .

:p10 a :SetMessage ;
     trn:settings :setDemo .

:p20 a :ShowMessage .

================
File: src/applications/_old-postcrafts/postcraft/about.md
================
```sh
cd ~/github-danny/transmissions

./trans postcraft ../postcraft/danny.ayers.name
```

================
File: src/applications/_old-postcrafts/postcraft/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances
@prefix trn: <http://purl.org/stuff/transmissions/> .

### ConfigMap
trn:PostcraftMap a trn:ConfigSet ;
    trn:key trn:postcraftMap ;
    trn:group trn:ContentGroup .

### clean

trn:cacheRemove a trn:ConfigSet ;
    trn:key trn:removeCache ;
    trn:target "cache/" .

trn:articlesRemove a trn:ConfigSet ;
    trn:key trn:removeArticles ;
    trn:target "public/home/articles" .

trn:entriesRemove a trn:ConfigSet ;
    trn:key trn:removeEntries ;
    trn:target "public/home/entries" .

trn:journalRemove a trn:ConfigSet ;
    trn:key trn:removeJournal ;
    trn:target "public/home/journal" .

trn:todoRemove a trn:ConfigSet ;
    trn:key trn:removeTodo ;
    trn:target "public/home/todo" .

trn:indexRemove a trn:ConfigSet ;
    trn:key trn:removeIndex ;
    trn:target "public/home/index.html" .

### copy #####################################

trn:copyStatic a trn:ConfigSet ;
    trn:key trn:staticCopy ;
    trn:source "content-static" ;
    trn:destination "public/home/static" .
    # trn:destination "../../danny.ayers.name/static" .

trn:copyMedia a trn:ConfigSet ;
    trn:key trn:mediaCopy ;
    trn:source "media" ;
    trn:destination "public/home/media" .

trn:copyCSS a trn:ConfigSet ;
    trn:key trn:cssCopy ;
    trn:source "layouts/middlin/css" ;
    trn:destination "public/home/css" .

trn:copyFonts a trn:ConfigSet ;
    trn:key trn:fontsCopy ;
    trn:source "layouts/middlin/fonts" ;
    trn:destination "public/home/fonts" .

trn:copyJS a trn:ConfigSet ;
    trn:key trn:jsCopy ;
    trn:source "layouts/middlin/js" ;
    trn:destination "public/home/js" .

### render ##################################

# trn:atomTemplate a trn:ConfigSet ;
#    trn:templateFile "layouts/middlin/templates/atom_template.njk" .

trn:Describe  a trn:ConfigSet ;
 trn:key trn:describe .

trn:phaseOne a trn:ConfigSet ;
    trn:key trn:markdownToRawPosts ;
    trn:marker "Phase One" .

# TODO IS COPY, not rename!!
trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "contentGroup.PostContent.sourceDir" ;
            trn:post    "sourceDir" .
  #  trn:pp2   trn:pre     "filename" ;
   #         trn:post    "filename"  .

trn:entryRawPrep a trn:ReMap ;
    trn:rename (trn:er1 trn:er2 trn:er3) .
   trn:er1   trn:pre     "targetFilename" ;
            trn:post    "filepath" .
    trn:er2   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .
    trn:er3   trn:pre     "contentGroup.PostContent.templateFile" ;
            trn:post    "templateFilename" .

trn:entryPagePrep a trn:ReMap ;
    trn:rename (trn:ppp1) .
    trn:ppp1   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .

================
File: src/applications/_old-postcrafts/postcraft/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:
@prefix trn: <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################


## POSTCRAFT.CLEAN ##########################################

:clean a trn:Transmission ;
    rdfs:label "clean" ;
    rdfs:comment "directory cleaner" ;
    trn:pipe (:r10 :r20 :r30 :r40 :r50 :r60) .

:r10 a :FileRemove ;
    trn:settings :removeCache .

:r20 a :FileRemove ;
    trn:settings  :removeArticles .

:r30 a :FileRemove ;
    trn:settings  :removeJournal .

:r40 a :FileRemove ;
    trn:settings  :removeEntries .

:r50 a :FileRemove ;
    trn:settings  :removeTodo .

:r60 a :FileRemove ;
    trn:settings  :removeIndex .

## POSTCRAFT.COPY ##################################################################

#:copy a trn:Transmission ;
 #   rdfs:label "copy" ;
  #  rdfs:comment "dir/file copier" ;
   # trn:pipe (:cp10 :cp20 :cp30 :cp40 :cp50) .

### static dirs
:cp10 a :FileCopy ;
    trn:settings :staticCopy .

### media dirs
:cp20 a :FileCopy ;
    trn:settings :mediaCopy .

### layout dirs
:cp30 a :FileCopy ;
    trn:settings :cssCopy .

:cp40 a :FileCopy ;
    trn:settings :jsCopy .

:cp50 a :FileCopy ;
    trn:settings :fontsCopy .

#####################

## POSTCRAFT.RENDER ###############################################################

:render a trn:Transmission ;
    rdfs:label "render" ;
    rdfs:comment "render the pages" ;
                 trn:pipe (:s20 :s30 :s40  :s50 :s60 :s70   :s80 :s90  :s100
              :s110  :s120  :s130 :s140 :s150 :s160 :s170 :s180 :s190 :s200 :s210) .
tweak

#:s10 a :DatasetReader ; # read the manifest NO done in system
# trn:settings trn:describe .

:s20 a :ConfigMap ;
    trn:settings :postcraftMap .

:s30 a :FileReader ; # the template for raw entry content
    trn:describe trn:all .

:s40 a :Restructure ;
    trn:settings :walkPrep .

:s50 a :DirWalker . # automatically forks

:s60 a :FileReader . # the markdown content

:s70 a :PostcraftPrep . # set up title, filenames etc

:s80 a :MarkdownToHTML .

:s90 a :Restructure ;
   trn:settings :entryRawPrep .

:s100 a :Templater .

:s110 a :FileWriter .

############### entryContentToEntryPage
:s120 a :EntryContentToPagePrep .
#:s12 a :Restructure ;
 #  trn:settings :entryPagePrep .

:s130 a :Templater .

:s140 a :FileWriter .

####################### index.html
:s150  a :Unfork .

:s160 a :FrontPagePrep .

:s170 a :Templater .

:s180 a :FileWriter .

###################### index.xml

:s190 a :AtomFeedPrep .

:s200 a :Templater .
 #   trn:settings :atomTemplate .

:s210 a :FileWriter .

================
File: src/applications/_old-postcrafts/postcraft-clear-cache/about.md
================
```sh
cd ~/github-danny/transmissions

./trans postcraft-clear-cache ../postcraft/danny.ayers.name
```

================
File: src/applications/_old-postcrafts/postcraft-clear-cache/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances
@prefix trn: <http://purl.org/stuff/transmissions/> .

### ConfigMap
trn:PostcraftMap a trn:ConfigSet ;
    trn:key trn:postcraftMap ;
    trn:group trn:ContentGroup .

### clean

trn:cacheRemove a trn:ConfigSet ;
    trn:key trn:removeCache ;
    trn:target "cache/" .

trn:articlesRemove a trn:ConfigSet ;
    trn:key trn:removeArticles ;
    trn:target "public/home/articles" .

trn:entriesRemove a trn:ConfigSet ;
    trn:key trn:removeEntries ;
    trn:target "public/home/entries" .

trn:journalRemove a trn:ConfigSet ;
    trn:key trn:removeJournal ;
    trn:target "public/home/journal" .

trn:todoRemove a trn:ConfigSet ;
    trn:key trn:removeTodo ;
    trn:target "public/home/todo" .

trn:indexRemove a trn:ConfigSet ;
    trn:key trn:removeIndex ;
    trn:target "public/home/index.html" .

### copy #####################################

trn:copyStatic a trn:ConfigSet ;
    trn:key trn:staticCopy ;
    trn:source "content-static" ;
    trn:destination "public/home/static" .
    # trn:destination "../../danny.ayers.name/static" .

trn:copyMedia a trn:ConfigSet ;
    trn:key trn:mediaCopy ;
    trn:source "media" ;
    trn:destination "public/home/media" .

trn:copyCSS a trn:ConfigSet ;
    trn:key trn:cssCopy ;
    trn:source "layouts/middlin/css" ;
    trn:destination "public/home/css" .

trn:copyFonts a trn:ConfigSet ;
    trn:key trn:fontsCopy ;
    trn:source "layouts/middlin/fonts" ;
    trn:destination "public/home/fonts" .

trn:copyJS a trn:ConfigSet ;
    trn:key trn:jsCopy ;
    trn:source "layouts/middlin/js" ;
    trn:destination "public/home/js" .

### render ##################################

# trn:atomTemplate a trn:ConfigSet ;
#    trn:templateFile "layouts/middlin/templates/atom_template.njk" .

trn:Describe  a trn:ConfigSet ;
 trn:key trn:describe .

trn:phaseOne a trn:ConfigSet ;
    trn:key trn:markdownToRawPosts ;
    trn:marker "Phase One" .

# TODO IS COPY, not rename!!

trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "entryContentMeta.sourceDir" ;
            trn:post    "sourceDir" .
  #  trn:pp2   trn:pre     "filename" ;
   #         trn:post    "filename"  .

trn:entryRawPrep a trn:ReMap ;
    trn:rename (trn:er1 trn:er3) .
   trn:er1   trn:pre     "targetFilename" ;
            trn:post    "filepath" .
    trn:er3   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .

trn:entryPagePrep a trn:ReMap ;
    trn:rename (trn:ppp1) .
    trn:ppp1   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .

================
File: src/applications/_old-postcrafts/postcraft-clear-cache/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:
@prefix trn: <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################


## POSTCRAFT.CLEAN ##########################################

:clearCache a trn:Transmission ;
    rdfs:label "clear cache" ;
    rdfs:comment "directory cleaner" ;
    trn:pipe (:r10) .

:r10 a :FileRemove ;
    trn:settings :removeCache .

================
File: src/applications/_old-postcrafts/postcraft-previous/about.md
================
```sh
cd ~/github-danny/transmissions

./trans postcraft ../postcraft/danny.ayers.name
```

================
File: src/applications/_old-postcrafts/postcraft-previous/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances
@prefix trn: <http://purl.org/stuff/transmissions/> .

### ConfigMap
trn:PostcraftMap a trn:ConfigSet ;
    trn:key trn:postcraftMap ;
    trn:group trn:ContentGroup .

### clean

trn:cacheRemove a trn:ConfigSet ;
    trn:key trn:removeCache ;
    trn:target "cache/" .

trn:articlesRemove a trn:ConfigSet ;
    trn:key trn:removeArticles ;
    trn:target "public/home/articles" .

trn:entriesRemove a trn:ConfigSet ;
    trn:key trn:removeEntries ;
    trn:target "public/home/entries" .

trn:journalRemove a trn:ConfigSet ;
    trn:key trn:removeJournal ;
    trn:target "public/home/journal" .

trn:todoRemove a trn:ConfigSet ;
    trn:key trn:removeTodo ;
    trn:target "public/home/todo" .

trn:indexRemove a trn:ConfigSet ;
    trn:key trn:removeIndex ;
    trn:target "public/home/index.html" .

### copy #####################################

trn:copyStatic a trn:ConfigSet ;
    trn:key trn:staticCopy ;
    trn:source "content-static" ;
    trn:destination "public/home/static" .
    # trn:destination "../../danny.ayers.name/static" .

trn:copyMedia a trn:ConfigSet ;
    trn:key trn:mediaCopy ;
    trn:source "media" ;
    trn:destination "public/home/media" .

trn:copyCSS a trn:ConfigSet ;
    trn:key trn:cssCopy ;
    trn:source "layouts/middlin/css" ;
    trn:destination "public/home/css" .

trn:copyFonts a trn:ConfigSet ;
    trn:key trn:fontsCopy ;
    trn:source "layouts/middlin/fonts" ;
    trn:destination "public/home/fonts" .

trn:copyJS a trn:ConfigSet ;
    trn:key trn:jsCopy ;
    trn:source "layouts/middlin/js" ;
    trn:destination "public/home/js" .

### render ##################################

trn:Describe  a trn:ConfigSet ;
 trn:key trn:describe .

trn:phaseOne a trn:ConfigSet ;
    trn:key trn:markdownToRawPosts ;
    trn:marker "Phase One" .

# TODO IS COPY, not rename!!

trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "entryContentMeta.sourceDir" ;
            trn:post    "sourceDir" .
  #  trn:pp2   trn:pre     "filename" ;
   #         trn:post    "filename"  .

trn:entryRawPrep a trn:ReMap ;
    trn:rename (trn:er1 trn:er3) .
   trn:er1   trn:pre     "targetFilename" ;
            trn:post    "filepath" .
    trn:er3   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .

trn:entryPagePrep a trn:ReMap ;
    trn:rename (trn:ppp1) .
    trn:ppp1   trn:pre     "content" ;
            trn:post    "contentBlocks.content" .

================
File: src/applications/_old-postcrafts/postcraft-previous/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:
@prefix trn: <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################


## POSTCRAFT.CLEAN ##########################################

:clean a trn:Transmission ;
    rdfs:label "clean" ;
    rdfs:comment "directory cleaner" ;
    trn:pipe (:r10 :r20 :r30 :r40 :r50 :r60) .

:r10 a :FileRemove ;
    trn:settings :removeCache .

:r20 a :FileRemove ;
    trn:settings  :removeArticles .

:r30 a :FileRemove ;
    trn:settings  :removeJournal .

:r40 a :FileRemove ;
    trn:settings  :removeEntries .

:r50 a :FileRemove ;
    trn:settings  :removeTodo .

:r60 a :FileRemove ;
    trn:settings  :removeIndex .

## POSTCRAFT.COPY ##################################################################

:copy a trn:Transmission ;
    rdfs:label "copy" ;
    rdfs:comment "dir/file copier" ;
    trn:pipe (:cp10 :cp20 :cp30 :cp40 :cp50) .

### static dirs
:cp10 a :FileCopy ;
    trn:settings :staticCopy .

### media dirs
:cp20 a :FileCopy ;
    trn:settings :mediaCopy .

### layout dirs
:cp30 a :FileCopy ;
    trn:settings :cssCopy .

:cp40 a :FileCopy ;
    trn:settings :jsCopy .

:cp50 a :FileCopy ;
    trn:settings :fontsCopy .

#####################

## POSTCRAFT.RENDER ###############################################################

:render a trn:Transmission ;
    rdfs:label "render" ;
    rdfs:comment "render the pages" ;
   trn:pipe (:s20  :s30 :s40  :s50 :s60 :s70   :s80 :s90  :s100
              :s110  :s120  :s130 :s140 :s150 :s160 :s170 :s180) .
 #  trn:pipe (:s10 :SM :s20 :SM2 :DE  :s30 :s40  :s50 :s60 :s70 :s80 :s90 :s100
  #               :s110 :s120 :s130 :s140 :s150  :s160 :s170 :s180) .

:s10 a :DatasetReader . # read the manifest NO done in system
# trn:settings trn:describe .

:s20 a :ConfigMap ;
    trn:settings :postcraftMap .

:s30 a :FileReader ; # the template for raw entry content
    trn:describe trn:all .

:s40 a :Restructure ;
    trn:settings :walkPrep .

:s50 a :DirWalker . # automatically forks

:s60 a :FileReader . # the markdown content

:s70 a :PostcraftPrep . # set up title, filenames etc

:s80 a :MarkdownToHTML .

:s90 a :Restructure ;
   trn:settings :entryRawPrep .

:s100 a :Templater .

:s110 a :FileWriter .

############### entryContentToEntryPage
:s120 a :EntryContentToPagePrep .
#:s12 a :Restructure ;
 #  trn:settings :entryPagePrep .

:s130 a :Templater .

:s140 a :FileWriter .

#######################
:s150  a :Unfork .

:s160 a :FrontPagePrep .

:s170 a :Templater .

:s180 a :FileWriter .

================
File: src/applications/_old-postcrafts/postcraft-render1/data/cache/2023-10-27_hello.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/_old-postcrafts/postcraft-render1/data/cache/2025-01-08_hello-again.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/_old-postcrafts/postcraft-render1/sparql/diamonds/select-blogposting.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?post ?headline ?content ?published ?modified ?author
WHERE {
  ?post a schema:Article ;
        schema:headline ?headline ;
        schema:articleBody ?content ;
        schema:datePublished ?published ;
        schema:dateModified ?modified ;
        schema:author/schema:name ?author .
  FILTER(?published >= "{{startDate}}"^^xsd:dateTime)
}
ORDER BY DESC(?published)
LIMIT 5

================
File: src/applications/_old-postcrafts/postcraft-render1/sparql/diamonds/update-blogposting.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

INSERT DATA {
  <http://example.com/posts/{{id}}> a schema:Article ;
    schema:headline "{{title}}" ;
    schema:url <http://example.com/posts/{{id}}> ;
    schema:articleBody """{{content}}""" ;
    schema:datePublished "{{published}}"^^xsd:dateTime ;
    schema:dateModified "{{modified}}"^^xsd:dateTime ;
    schema:author [
      a schema:Person ;
      schema:name "{{author.name}}" ;
      schema:email "{{author.email}}"
    ] .
}

================
File: src/applications/_old-postcrafts/postcraft-render1/sparql/endpoint.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:3030/test/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:3030/test/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: src/applications/_old-postcrafts/postcraft-render1/about.md
================
# Postcraft Render 1

walk source dirs for `.md`, render to `.html` in cache

```sh
cd ~/github-danny/transmissions

./trans postcraft-render1 ../postcraft/test-site

./trans postcraft-render1 ../postcraft/danny.ayers.name
```

```sparql
PREFIX schema: <http://schema.org/>
SELECT ?post ?title ?content ?date ?author WHERE {
  ?post a schema:Article ;
        schema:headline ?title ;
        schema:articleBody ?content ;
        schema:datePublished ?date ;
        schema:author/schema:name ?author .
} ORDER BY DESC(?date)
```

================
File: src/applications/_old-postcrafts/postcraft-render1/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix schema: <http://schema.org/> .

@prefix : <http://purl.org/stuff/transmissions/> .

:dirWalker a :ConfigSet ;
  :sourceDir "content-raw" ;
  :messageType schema:BlogPosting .

:templatePrep a :ReMap ;
    :rename (:tp1 ).
    :tp1  :pre     "content" ;
          :post    "contentBlocks.content" .

:contentTemplater a :ConfigSet ;
  :templateFilename "layouts/middlin/templates/entry-content_template.njk" .

:filesRename a :ConfigSet ;
  :inputField "filename" ;
  :outputField "filepath" ;
  :match ".md";
  :replace ".html".

:fileWriter a :ConfigSet ;
  :targetDir "cache" .

########################
:sparqlUpdate a :ConfigSet ;
    :templateFilename "sparql/diamonds/update-blogposting.njk" ;
    :endpointSettings "sparql/endpoint.json" .

:sparqlSelect a :ConfigSet ;
    :templateFilename "sparql/diamonds/select-blogposting.njk" ;
    :endpointSettings "sparql/endpoint.json" .

================
File: src/applications/_old-postcrafts/postcraft-render1/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:
@prefix trn: <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################


## ###############################################################

:render1 a trn:Transmission ;
    rdfs:label "render1" ;
    rdfs:comment "render raw entry pages" ;
   trn:pipe (:r110 :r120 :r130 :r140 :r150 :r160 :r170 :r180) .

:r110 a :DirWalker ; # automatically forks
    trn:settings :dirWalker .

:r120 a :FileReader . # the markdown content

:r130 a :MarkdownToHTML .

:r140 a :Restructure ; # moves content into  contentBlocks
   trn:settings :templatePrep .

:r150 a :Templater ; # section wrapper
    trn:settings :contentTemplater .

:r160 a :StringReplace ; # *.md -> *.html
    trn:settings :filesRename .

:r170 a :FileWriter ;
    trn:settings :fileWriter .

:r180 a :SPARQLUpdate ;
    trn:settings :sparqlUpdate .





#######################################################
# :s10 a :DatasetReader . # read the manifest NO done in system

:q10 a :ConfigMap ;
    trn:settings :renderEntries .

:rq20 a :Restructure ;
    trn:settings :walkPrep .

#######################################
:s50 a :DirWalker . # automatically forks

:s60 a :FileReader . # the markdown content

:s70 a :PostcraftPrep . # set up title, filenames etc

:s80 a :MarkdownToHTML .

:s90 a :Restructure ;
   trn:settings :entryRawPrep .

:s100 a :Templater .

:s110 a :FileWriter .

############### entryContentToEntryPage
:s120 a :EntryContentToPagePrep .

:s130 a :Templater .

:s140 a :FileWriter .

#######################
:s150  a :Unfork .

:s160 a :FrontPagePrep .

:s170 a :Templater .

:s180 a :FileWriter .

================
File: src/applications/_old-postcrafts/postcraft-render2/data/cache/2023-10-27_hello.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/_old-postcrafts/postcraft-render2/data/cache/2025-01-08_hello-again.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/_old-postcrafts/postcraft-render2/about.md
================
# Postcraft Render 2

walk cache dirs for `.html`, template to post pages

```sh
cd ~/github-danny/transmissions

./trans postcraft-render2 ../postcraft/test-site

./trans postcraft-render2 ../postcraft/danny.ayers.name
```

================
File: src/applications/_old-postcrafts/postcraft-render2/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .


:cacheWalker a :ConfigSet ;
  :sourceDir "cache" ;
  :includeExtensions "['.html', '.md', '.ttl', '.js', '.json', '.txt',  '.css']" .

:templatePrep a :ConfigSet  ;
    :rename (:tp1 ).
    :tp1   :pre     "content" ;
            :post    "contentBlocks.content" .

:pageTemplater a :ConfigSet ;
  :templateFilename "layouts/middlin/templates/entry-page_template.njk" .

:writePrep a :ConfigSet  ;
    :rename (:wp1 ).
    :wp1   :pre     "filename" ;
            :post    "filepath" .

:fileWriter a :ConfigSet ;
  :targetDir "public" .

  ################

:indexTemplater a :ConfigSet ;
  :templateFilename "layouts/middlin/templates/index-page_template.njk" .

:filesRename a :ConfigSet ;
  :inputField "filename" ;
  :outputField "filepath" ;
  :match ".md";
  :replace ".html".

#####################
########################
:sparqlUpdate a :ConfigSet ;
    :templateFilename "diamonds/update-blogposting.njk" ;
    :endpointSettings "endpoint.json" .

:sparqlSelect a :ConfigSet ;
    :templateFilename "diamonds/select-blogposting.njk" ;
    :endpointSettings "endpoint.json" .

================
File: src/applications/_old-postcrafts/postcraft-render2/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage .
:SM2 a :ShowMessage .
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
:ST a :ShowTransmission .
#############################################################


## ###############################################################

:render2 a :Transmission ;
    rdfs:label "render2" ;
    rdfs:comment "template entry html to pages" ;
   :pipe (:r210 :r220 :r230  :r240 :r250 :r260
             :r300 :SM2 :r310 :r320 :r330 :r340 :r350 :r360) .

:r210 a :DirWalker ; # automatically forks
    :settings :cacheWalker .

:r220 a :FileReader . # the markdown content

:r230 a :Restructure ; # moves content into  contentBlocks
   :settings :templatePrep .

:r240 a :Templater ; # for individual post pages
    :settings :pageTemplater . ###########################################################################


:r250 a :Restructure ; # moves content into  contentBlocks
   :settings :writePrep . # CONFIGKEY?

:r260 a :FileWriter ;
    :settings :fileWriter .


####################### index.html
:r300  a :Unfork .

:r310 a :FrontPagePrep .

:r320 a :Templater ;
    :settings :indexTemplater .

:r330 a :FileWriter .

###################### index.xml

:r340 a :AtomFeedPrep .

:r350 a :Templater .
 #   :settings :atomTemplate .

:r360 a :FileWriter .

================
File: src/applications/claude-json-converter/data/input/input-01.json
================
[
    {
        "uuid": "conversation 1 uuid",
        "name": "conversation 1 name",
        "created_at": "",
        "updated_at": "",
        "account": {
            "uuid": "account.uuid"
        },
        "chat_messages": [
            {
                "uuid": "c1 message 1 uuid",
                "text": "",
                "content": [
                    {
                        "type": "c1 message 1 type",
                        "text": "c1 message 1 text"
                    }
                ],
                "sender": "",
                "created_at": "",
                "updated_at": "",
                "attachments": [],
                "files": [
                    {
                        "file_name": ""
                    }
                ]
            },
            {
                "uuid": "c1 message 2 uuid",
                "text": "",
                "content": [
                    {
                        "type": "c1 message 2 type",
                        "text": "c1 message 2 text"
                    }
                ],
                "sender": "",
                "created_at": "",
                "updated_at": "",
                "attachments": [],
                "files": [
                    {
                        "file_name": ""
                    }
                ]
            }
        ]
    },
    {
        "uuid": "conversation 2 uuid",
        "name": "conversation 2 name",
        "created_at": "",
        "updated_at": "",
        "account": {
            "uuid": "account.uuid"
        },
        "chat_messages": [
            {
                "uuid": "c2 message 1 uuid",
                "text": "",
                "content": [
                    {
                        "type": "c2 message 1 type",
                        "text": "c2 message 1 text"
                    }
                ],
                "sender": "",
                "created_at": "",
                "updated_at": "",
                "attachments": [],
                "files": [
                    {
                        "file_name": ""
                    }
                ]
            },
            {
                "uuid": "c2 message 2 uuid",
                "text": "",
                "content": [
                    {
                        "type": "c2 message 2 type",
                        "text": "c2 message 2 text"
                    }
                ],
                "sender": "",
                "created_at": "",
                "updated_at": "",
                "attachments": [],
                "files": [
                    {
                        "file_name": ""
                    }
                ]
            }
        ]
    }
]

================
File: src/applications/claude-json-converter/data/input/users.json
================
[{"uuid": "dc67aa7d-f71f-4232-afb3-7f2688ac68f7", "full_name": "Danny Ayers", "email_address": "danny.ayers@gmail.com", "verified_phone_number": null}]

================
File: src/applications/claude-json-converter/about.md
================
```sh
cd ~/github-danny/transmissions/

./trans -v claude-json-converter -m '{"sourceFile":"/home/danny/github-danny/hyperdata/docs/chat-archives/data-2025-02-02-12-23-16/conversations.json"}'

./trans claude-json-converter
```

---

```turtle
####  testing only
:nop a trn:Transmission ;
    rdfs:label "nop" ;
    rdfs:comment "NOP for testing" ;
trn:pipe (:n10) .

:n10 a :NOP .

# testing only - FileWriter will save message
:cb a trn:Transmission ;
     rdfs:label "cb" ;
     rdfs:comment "Claude blanker" ;
     trn:pipe (:ccc10   :cb10 :cb20 :cb30) .

:cb10 a :SetMessage ;
     trn:settings :setDump .

:cb20 a :FileWriter .

:cb30 a :Blanker ; # clear values
     trn:settings :blankContent .

##################
##################### only for testing
:bContent a :ConfigSet ;
    rdfs:label "Root node in JSON object for blanker" ;
    :settings :blankContent  ;
    :pointer "content"  ;
    :preserve "content.payload.test.third" .

:setDump a :ConfigSet ;
    :setValue (:sv0)  . # consider using blank nodes
    :sv0   :key    "dump" ;
            :value  "true"  .
#########################################################################
```

#####################################

After `FileReader` (and `Blanker`):

```
{
    // system message bits,

    "content": [
        {
            "uuid": "",
            "name": "",
            "created_at": "",
            "updated_at": "",
            "account": {
                "uuid": ""
            },
            "chat_messages": [
                {
                    "uuid": "",
                    "text": "",
                    "content": [
                        {
                            "type": "",
                            "text": ""
                        }
                    ],
                    "sender": "",
                    "created_at": "",
                    "updated_at": "",
                    "attachments": [],
                    "files": [
                        {
                            "file_name": ""
                        }
                    ]
                },
                {
                    ...
                }
            ]
        }
}
```

`JSONWalker` fires off a message per-conversation.

These need `Restructure` to split off the common metadata as `message.content`, and move `chat_messages` to `message.content`, ready for -

`JSONWalker` fires off a message per-conversation.

================
File: src/applications/claude-json-converter/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .




# should really be in a manifest.ttl
:ReadFile a :ConfigSet ;
    rdfs:label "Read file" ;
    :settings :readFile ;
    :sourceFile "input/conversations.json" ;
  #  :sourceFile "input/input-01.json" ;
    :mediaType "application/json" .


:ConversationsWalker a :ConfigSet ;
# :die "true" ;
    :pointer "content" .


:retreeConvsssssssnot a :ConfigSet ;
    :rename (:pp100 :pp101 :pp102  :pp103) .
    :pp100     :pre     "content.uuid" ;
                :post    "meta.conv_uuid"  .
    :pp101     :pre     "content.name" ;
                :post    "meta.conv_name"  .
    :pp102     :pre     "content.updated_at" ;
                :post    "meta.updated_at"  .
    :pp103     :pre     "content.chat_messages" ;
                :post    "content"  .

:retreeConvs a :ConfigSet ;
    :rename (:pp100 :pp101 :pp102  :pp103) .
    :pp100     :pre     "content.uuid" ;
                :post    "meta.conv_uuid"  .
    :pp101     :pre     "content.name" ;
                :post    "meta.conv_name"  .
    :pp102     :pre     "content.updated_at" ;
                :post    "meta.updated_at"  .
    :pp103     :pre     "content.chat_messages" ;
                :post    "content"  .

  :MessagesWalker a :ConfigSet ;
      :pointer "content" .

# unused
:retreeMsgs a :ConfigSet ;
    :rename (:pp200 :pp201 :pp202) .

    :pp200     :pre     "content.item.chat_messages" ;
                :post    "channel"  .

    :pp201     :pre     "content.item.uuid" ;
                :post    "filename"  .

    :pp202     :pre     "content.item.name" ;
                :post    "title"  .

:Writer a :ConfigSet ;
    :destinationFile "DESTINATION" .

================
File: src/applications/claude-json-converter/transmissions copy.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one

# testing only - FileWriter will save message
:cb a trn:Transmission ;
     rdfs:label "cb" ;
     rdfs:comment "Claude blanker" ;
     trn:pipe (:cb10 :cb20 :cb30) .

:cb10 a :SetMessage ;
     trn:settings :setDump .

:cb20 a :FileWriter .

:cb30 a :Blanker ; # clear values
     trn:settings :blankContent .

# :UF :SD :FW :DE
####################################

:nop a trn:Transmission ;
    rdfs:label "nop" ;
    rdfs:comment "NOP for testing" ;
trn:pipe (:n10) .

:n10 a :NOP .

####### The thing

:ccc a trn:Transmission ;
    rdfs:label "ccc" ;
    rdfs:comment "Claude conversations.json converter" ;
     trn:pipe (:ccc10 :ccc20 :ccc30 :ccc40 :ccc50  :ccc60) .

# Start

:ccc10 a :FileReader ; # Claude conversations.json
       trn:settings :readFile .

# Separates into conversations
:ccc20 a :JSONWalker ;
     trn:settings :conversationsConfig .


:ccc30 a :Restructure ;
     trn:settings :retreeConvs .

# Separates into messages
:ccc40 a :JSONWalker ;
     trn:settings :messagesConfig .

#:p50 a :Restructure ;
 #    trn:settings :retreeMsgs .

:ccc50 a :MarkdownFormatter .

:ccc60 a :FileWriter .

================
File: src/applications/claude-json-converter/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one


####### The thing

:ccc a trn:Transmission ;
     rdfs:label "ccc" ;
     rdfs:comment "Claude conversations.json converter" ;
     trn:pipe (:ccc10 :ccc20 :ccc30 :ccc40 :ccc50 :ccc60) .

# Start

:ccc10 a :FileReader ; # Claude conversations.json
       trn:settings :readFile .

# Separates into conversations
:ccc20 a :JSONWalker ;
     trn:settings :ConversationsWalker .


:ccc30 a :Restructure ;
     trn:settings :retreeConvs .

# Separates into messages
  :ccc40 a :JSONWalker ;
       trn:settings :MessagesWalker .

#:p50 a :Restructure ;
 #    trn:settings :retreeMsgs .

:ccc50 a :MarkdownFormatter .

:ccc60 a :FileWriter ;
     trn:settings :Writer .

================
File: src/applications/echo/about.md
================
`src/applications/system/echo/about.md`

src/applications/system/echo

# Example Application `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans system/echo -m '{"message":"Hello, World!"}'
```

## Description

---

================
File: src/applications/echo/config.ttl
================
# src/applications/example-application/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:exampleSettings1 a :ConfigSet ;
    :me "exampleSettings1" ;
    :common "common from 1"  ;
    :something1 "something1 from config" .

:exampleSettings2 a :ConfigSet ;
    :me "exampleSettings2" ;
    :common "common from 2" ;
    :something2 "something2 from config" ;
    :added " added from exampleSettings2" .

================
File: src/applications/echo/transmissions.ttl
================
# src/applications/example-application/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:echo a :Transmission ;
    :pipe (:p10 :SC) .

:p10 a :ShowMessage .

================
File: src/applications/example-application/about.md
================
`src/applications/example-application/about.md`

# Example Application `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans example-application
```

## Description

---

================
File: src/applications/example-application/config.ttl
================
# src/applications/example-application/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:exampleSettings1 a :ConfigSet ;
    :me "exampleSettings1" ;
    :common "common from 1"  ;
    :something1 "something1 from config" .

:exampleSettings2 a :ConfigSet ;
    :me "exampleSettings2" ;
    :common "common from 2" ;
    :something2 "something2 from config" ;
    :added " added from exampleSettings2" .

================
File: src/applications/example-application/transmissions.ttl
================
# src/applications/example-application/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:example a :Transmission ;
    :pipe (:p10 :N :p20 :p30) .

:p10 a :ExampleProcessor ;
     :settings :exampleSettings1 .

:p20 a :ExampleProcessor ;
     :settings :exampleSettings2 .

:p30 a :ShowMessage .

================
File: src/applications/file-pipeline/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:FilePipelineMap a trn:DataMap ;
    trn:sourceFile "input.txt" ;
    trn:destinationFile "output.txt" .

================
File: src/applications/file-pipeline/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:file_pipeline a trn:Transmission ;
    trn:pipe (:s1 :s2 :s3 :s4) .

:s1 a :FileSource .
:s2 a :AppendProcess .
:s3 a :AppendProcess .
:s4 a :FileSink .

================
File: src/applications/globbo/about.md
================
# Globbo

```
./run globbo -c '{"rootDir": "./", "sourceDir":"docs"}'
```

there are more notes under

/home/danny/github-danny/transmissions/docs/postcraft-site/articles/new-application-walkthrough.md

/home/danny/github-danny/transmissions/docs/postcraft-site/articles/new-service-walkthrough.md

## Description

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/globbo/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "entryContentMeta.sourceDir" ;
            trn:post    "sourceDir" .

================
File: src/applications/globbo/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:globbo a trn:Transmission ;
    trn:pipe (:s10 :s20 :s30 :s40 :SM) .

#:s40 a :Restructure ;
 #   trn:settings :walkPrep .

:s10 a :DirWalker .
:s20 a :CaptureAll . # pushes all messages into config.whiteboard
:s30 a :Unfork .
:s40 a :WhiteboardToMessage .

================
File: src/applications/html-to-md/about.md
================
# HTML to Markdown

*a minimal application (that I need) which can also serve as an example in documentation*

```
./run html-to-md -c '{"rootDir": "./test-data/html-to-md", "filename":"webidl.html"}'
```

## Description

---

there are more notes under

/home/danny/github-danny/transmissions/docs/postcraft-site/articles/new-application-walkthrough.md

/home/danny/github-danny/transmissions/docs/postcraft-site/articles/new-service-walkthrough.md

## Description

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/html-to-md/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "entryContentMeta.sourceDir" ;
            trn:post    "sourceDir" .

================
File: src/applications/html-to-md/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:h2m a trn:Transmission ;
    trn:pipe (:s10 :s20 :s30 :s40 :SM) .

#:s40 a :Restructure ;
 #   trn:settings :walkPrep .

:s10 a :FileReader .
:s20 a :CaptureAll . # pushes all messages into config.whiteboard
:s30 a :Unfork .
:s40 a :WhiteboardToMessage .

================
File: src/applications/link-lister/about.md
================
run.js had

const here = import.meta.url
const message = { runScript: here }

transmission.process('', message)

================
File: src/applications/link-lister/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:linklister trn:hasDataMap trn:llSourceMap .
trn:linklister trn:hasDataMap trn:llGotMap .
trn:linklister trn:hasDataMap trn:llLinkMap .

trn:llSourceMap a trn:DataMap ;
    trn:key trn:sourceFile ;
    trn:value "starter-links.md" .

trn:llGotMap a trn:DataMap ;
    trn:key trn:gotFile ;
    trn:value "got.html" .

trn:llLinkMap a trn:DataMap ;
    trn:key trn:linkFile ;
    trn:value "links.md" .

trn:htmlMap a trn:DataMap ;
    trn:key trn:htmlFile ;
    trn:value "links.html" .

================
File: src/applications/link-lister/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:linklister a trn:Transmission ;
    trn:pipe (:s1 :s2 :s3 :s4 :s5 :s6 :s7 :s8) .

:s1 a :FileReader ;
    trn:settings :sourceFile .

:s2 a :LineReader .
:s3 a :HttpGet .

:s4 a :LinkFinder .

:s5 a :StringMerger .

:s6 a :FileWriter ;
    trn:settings :linkFile .
# :s6 a :NOP .
:s7 a :MarkdownToHTML .

:s8 a :FileWriter ;
    trn:settings :htmlFile .

#:s8 a :StringFilter .
#:s9 a :StringMerger .
#:s10 a :FileWriter
#        trn:settings :linkFile .
# :s4 a :NOP .
# :s4 a :FileWriter ;
#     trn:settings :gotFile .

# :s5 a :NOP .

================
File: src/applications/md-to-sparqlstore/data/input/about.ttl
================
@prefix : <http://example.org/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

:currentDirectory a foaf:Document ;
    dcterms:title "Current Directory" ;
    dcterms:hasPart :aboutTTL .

:aboutTTL a foaf:Document ;
    dcterms:title "about.ttl" ;
    dcterms:format "text/turtle" ;
    dcterms:creator "Danny" ;
    dcterms:created "2023-10-05" .

================
File: src/applications/md-to-sparqlstore/data/input/ignore-me.txt
================
THIS SHOULD BE IGNORED

================
File: src/applications/md-to-sparqlstore/data/input/turtle-example.ttl
================
@prefix : <http://purl.org/stuff/transmissions/> .

:md-to-sparqlstore
a :Application ;
:runner [
:description "Should default to `data` dir" ;
:path "~/github-danny/transmissions"
]
.

================
File: src/applications/md-to-sparqlstore/sparql/endpoint.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:3030/test/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:3030/test/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: src/applications/md-to-sparqlstore/sparql/example-article.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <http://schema.org/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix agents: <http://purl.org/stuff/agents/> .

<http://example.com/posts-one> a schema:Article ;
    trn:sourceFile "src/applications/md-to-sparqlstore/about.md" ;

    rdfs:label "Post one" ;
    rdfs:summary "Post one summary." ;

    schema:headline "Post one" ;
    schema:url <http://example.com/posts-one> ;
    schema:articleBody "Post one content." ;
    schema:datePublished "2023-05-22T13:00:00Z"^^xsd:dateTime ;
    schema:dateModified "2023-05-22T15:00:00Z"^^xsd:dateTime ;
    schema:author agents:danja .
        a schema:Person ;
        a foaf:Person ;
        schema:name "Danny Ayers" ;
        foaf:name "Danny Ayers" ;
        foaf:nick "danja" ;
        foaf:homepage <https://danny.ayers.name>
    ] .

================
File: src/applications/md-to-sparqlstore/templates/turtle-template.html
================
{% raw %}
{# Import dependencies #}
{% set TextUtils = require('./TextUtils.js') %}
{% set config = require('./config.js').config %}
{% set langConfig = require('./languageConfig.js').languageConfig %}

{# Helper function for literal formatting #}
{% macro formatLiteral(value, field) %}
    {%- if value.lang and TextUtils.isValidLanguageTag(value.lang) -%}
        {{- TextUtils.escapeStringLiteral(value.value, { language: value.lang }) -}}
    {%- elif not langConfig.nonLanguageFields.has(field) and langConfig.defaultLanguage -%}
        {{- TextUtils.escapeStringLiteral(value, { language: langConfig.defaultLanguage }) -}}
    {%- else -%}
        {{- TextUtils.escapeStringLiteral(value) -}}
    {%- endif -%}
{% endmacro %}

{# Common RDF prefixes #}
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <http://schema.org/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix agents: <http://purl.org/stuff/agents/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

{% if config.requiredFields.every(field => message[field]) %}
<{{ config.baseUrl }}/{{ TextUtils.createSlug(message.slug) }}> a schema:Article
    {%- if message.title -%}
    ;
    schema:headline {{ formatLiteral(message.title, 'title') }}
    {%- endif -%}

    {%- if message.summary -%}
    ;
    rdfs:summary {{ formatLiteral(message.summary, 'summary') }}
    {%- endif -%}

    {%- if message.content -%}
    ;
    schema:articleBody {{ formatLiteral(message.content, 'articleBody') }}
    {%- endif -%}

    {%- if message.author -%}
    ;
    schema:author [
        a schema:Person ;
        a foaf:Person
        {%- if message.author.name -%}
        ;
        schema:name {{ formatLiteral(message.author.name, 'author.name') }}
        {%- endif -%}
        {%- if message.author.homepage -%}
        ;
        foaf:homepage <{{ TextUtils.escapeIRI(message.author.homepage) }}>
        {%- endif -%}
    ]
    {%- endif -%}

    {# Handle multilingual values #}
    {%- if message.translations -%}
        {%- for field, translations in message.translations -%}
            {%- for lang, value in translations -%}
                {%- if TextUtils.isValidLanguageTag(lang) -%}
                ;
                schema:{{ field }} {{ TextUtils.escapeStringLiteral(value, { language: lang }) }}
                {%- endif -%}
            {%- endfor -%}
        {%- endfor -%}
    {%- endif -%}
.
{% endif %}{% endraw %}

================
File: src/applications/md-to-sparqlstore/about.md
================
`src/applications/md-to-sparqlstore/about.md`

# Application md-to-sparqlstore `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans md-to-sparqlstore
```

## Description

Should default to `data` dir

================
File: src/applications/md-to-sparqlstore/config.ttl
================
# src/applications/test_stuff-to-sparql/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <http://schema.org/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:dirWalker a :ConfigSet ;
#  :sourceDir "content-raw" ;
  :messageType schema:Article .

:sparqlUpdate a :ConfigSet ;
    :templateFilename "sparql/diamonds/update-article.njk" ;
    :endpointSettings "sparql/endpoint.json" .

:sparqlSelect a :ConfigSet ;
    :templateFilename "sparql/diamonds/select-article.njk" ;
    :endpointSettings "sparql/endpoint.json" .

================
File: src/applications/md-to-sparqlstore/transmissions.ttl
================
# src/applications/example-application/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################


:test_stuff-to-sparql a :Transmission ;
    rdfs:label "test_stuff-to-sparq" ;
    rdfs:comment "render raw entry pages" ;
   :pipe (:SM :r10 :r20 :r30 ) .

:r10 a :DirWalker ; # where is the default dir?
    :settings :dirWalker .

:r20 a :FileReader . # the markdown content


:r30 a :SPARQLUpdate ;
    :settings :sparqlUpdate .

================
File: src/applications/pdf-to-html/about.md
================
`src/applications/example-application/about.md`

# Example Application `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans example-application
```

## Description

---

================
File: src/applications/pdf-to-html/config.ttl
================
# src/applications/example-application/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:exampleSettings1 a :ConfigSet ;
    :me "exampleSettings1" ;
    :common "common from 1"  ;
    :something1 "something1 from config" .

:exampleSettings2 a :ConfigSet ;
    :me "exampleSettings2" ;
    :common "common from 2" ;
    :something2 "something2 from config" ;
    :added " added from exampleSettings2" .

================
File: src/applications/pdf-to-html/transmissions.ttl
================
# src/applications/example-application/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:example a :Transmission ;
    :pipe (:p10 :N :p20 :p30) .

:p10 a :ExampleProcessor ;
     :settings :exampleSettings1 .

:p20 a :ExampleProcessor ;
     :settings :exampleSettings2 .

:p30 a :ShowMessage .

================
File: src/applications/selfie/about.md
================
# Selfie

Scan `transmissions`, generate self-descriptions - per-dir about.md, about.ttl

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans app-template
```

## Description

---

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/selfie/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:setDemo a trn:ConfigSet ;
    trn:setValue (trn:sv0)  . # consider using blank nodes
    trn:sv0   trn:key    "demo" ;
            trn:value    "a test value"  .

================
File: src/applications/selfie/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:mini a trn:Transmission ;
    trn:pipe (:p10 :p20) .

:p10 a :SetMessage ;
     trn:settings :setDemo .

:p20 a :ShowMessage .

================
File: src/applications/string-pipeline/config.ttl
================
### NOT USED

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dc: <http://purl.org/dc/terms/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:StringPipeline dc:title "Hello" .

================
File: src/applications/string-pipeline/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:stringpipe a trn:Transmission ;
    trn:pipe (:s1 :s2 :s3 :s4) .

:s1 a :StringSource .
:s2 a :AppendProcess .
:s3 a :AppendProcess .
:s4 a :StringSink .

================
File: src/applications/terrapack/_old/code-comment-stripper.js
================
import path from 'path';

const LANGUAGE_PATTERNS = {
    js: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    jsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    ts: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    tsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    py: {
        single: '#',
        multi: { start: '"""', end: '"""' }
    },
    java: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    cpp: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    c: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    h: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    }
};

export function commentStripper(content, filepath) {
    const ext = path.extname(filepath).toLowerCase().slice(1);
    const patterns = LANGUAGE_PATTERNS[ext];

    if (!patterns) {
        return content;
    }

    let lines = content.split('\n');
    let inMultiLineComment = false;
    let result = [];

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();

        if (inMultiLineComment) {
            if (line.includes(patterns.multi.end)) {
                inMultiLineComment = false;
                line = line.split(patterns.multi.end)[1];
            } else {
                continue;
            }
        }

        if (patterns.multi && line.includes(patterns.multi.start)) {
            const parts = line.split(patterns.multi.start);
            if (!parts[1].includes(patterns.multi.end)) {
                inMultiLineComment = true;
                line = parts[0];
            } else {
                line = parts[0] + parts[1].split(patterns.multi.end)[1];
            }
        }

        if (patterns.single && line.startsWith(patterns.single)) {
            continue;
        }

        if (patterns.single) {
            const commentIndex = line.indexOf(patterns.single);
            if (commentIndex >= 0) {
                line = line.substring(0, commentIndex).trim();
            }
        }

        if (line.trim()) {
            result.push(line);
        }
    }

    return result.join('\n');
}

================
File: src/applications/terrapack/_old/terrapack-about.md
================
# terrapack Application

_repopack/repomix equiv_

```sh
./trans terrapack path/to/repo

./trans terrapack ./

./trans terrapack
```

Walks repository directory according to configured patterns, combines files into single AI-friendly document with:

- Directory structure outline
- File content with metadata
- Comment stripping option
- Configurable include/exclude patterns
- Output format optimized for LLMs

## Flow

1. DirWalker scans repository with filters
2. FileReader loads content and metadata
3. FileContainer accumulates and formats data
4. FileWriter generates single combined output

================
File: src/applications/terrapack/_old/terrapack-handover.md
================
# terrapack Project Handover Document

## Project Overview

The terrapack project is designed to consolidate repository content into AI-friendly formats, similar to repomix. It processes source code and other text files into a single document optimized for large language model analysis.

## Core Components

### FileContainer (src/processors/terrapack/FileContainer.js)

The FileContainer processor serves as the central aggregation component. It accumulates file contents and metadata into a structured format, maintaining a summary of file types and counts. The container tracks file paths relative to the project root and preserves file metadata like timestamps and types.

### CommentStripper (src/processors/terrapack/CommentStripper.js)

This utility removes comments from source code files while preserving the actual code. It supports multiple programming languages including JavaScript, Python, Java, and C-family languages. The processor handles both single-line and multi-line comments appropriately for each language.

### PackerProcessorsFactory (src/processors/terrapack/PackerProcessorsFactory.js)

The factory class manages processor instantiation, integrating the terrapack components into the Transmissions framework. It currently handles creation of the FileContainer processor and may be extended for additional processors.

## Integration Tests

The test suite includes integration tests verifying the full pipeline functionality, focusing on file reading, processing, and output generation. Test files are located in tests/integration/file-container.spec.js.

## Configuration

The application uses a TTL-based configuration system defining:

- File inclusion/exclusion patterns
- Output file settings
- Processing options like comment stripping

## Future Development Areas

1. Token counting functionality
2. Security scanning for sensitive data
3. Binary file handling
4. Additional output format templating

## Test Applications

### FileContainer Test (src/applications/test_file-container/)

A standalone test application demonstrating the FileContainer processor's functionality. It processes test files through the container and generates JSON output, useful for verification and development.

## Critical Notes

- The system expects text files as input; binary files are currently excluded
- File paths are processed relative to the project root
- Comment stripping is language-aware but conservative to prevent code removal

## Dependencies

- Standard Node.js fs/promises for file operations
- RDF components for configuration
- Transmissions framework core classes

================
File: src/applications/terrapack/_old/test-file-container-about.md
================
# Test FileContainer

Tests the FileContainer processor functionality in isolation.

```sh
./trans test_file-container
```

Reads test files from data/input, processes them through FileContainer, and writes JSON output to data/output/container-output.json.

================
File: src/applications/terrapack/_old/test-file-container-config.txt
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:readConfig a trn:ConfigSet ;
    rdfs:label "Read file" ;
    trn:settings trn:readConfig ;
    trn:mediaType "text/plain" .

trn:containerConfig a trn:ConfigSet ;
    trn:settings trn:containerConfig ;
    trn:destination "container-output.json" .

trn:writeConfig a trn:ConfigSet ;
    rdfs:label "Write file" ;
    trn:settings trn:writeConfig ;
    trn:destinationFile "output/container-output.json" .

================
File: src/applications/terrapack/_old/test-file-container-transmissions.txt
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

:test_file-container a trn:Transmission ;
    rdfs:label "FileContainer Test" ;
    trn:pipe (:p10 :p20 :p30 :p40 :SM) .

:p10 a :FileReader ;
    trn:settings :readConfig .

:p20 a :FileContainer ;
    trn:settings :containerConfig .

:p30 a :FileWriter ;
    trn:settings :writeConfig .

:p40 a :ShowMessage .

================
File: src/applications/terrapack/data/input/subdir/subby.md
================
this is src/applications/terrapack/data/input/subdir/subby.md

================
File: src/applications/terrapack/data/input/2023-10-27_hello.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/terrapack/data/input/2025-01-08_hello-again.md
================
<h1>Hello World! (again)</h1>
<p>lorem etc.</p>

================
File: src/applications/terrapack/data/input/exclude.me
================
this is src/applications/packer/data/input/exclude.me

================
File: src/applications/terrapack/about.md
================
# terrapack Application

**Packs sets of text/code content into a single file to provide grounding for AI**

_repopack/repomix equiv_

```sh
cd ~/github-danny/transmissions # my local dir

./trans terrapack ./src/applications/terrapack/data


./trans terrapack path/to/repo

./trans terrapack ./


./trans terrapack
```

from Claude

# terrapack Application

_repopack/repomix equiv_

```sh
./trans terrapack path/to/repo

./trans terrapack ./

./trans terrapack
```

Walks repository directory according to configured patterns, combines files into single AI-friendly document with:

- Directory structure outline
- File content with metadata
- Comment stripping option
- Configurable include/exclude patterns
- Output format optimized for LLMs

## Flow

1. DirWalker scans repository with filters
2. FileReader loads content and metadata
3. FileContainer accumulates and formats data
4. FileWriter generates single combined output

================
File: src/applications/terrapack/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .

:dirWalker a :ConfigSet ;
    :sourceDir "." ;
    :includeExtension ".md", ".js", ".ttl" .

:filterConfig a :ConfigSet ;
    :settings :filterDefaults ;
    :includePattern "*.txt", "*.md", "*.js", "*.jsx", "*.ts", "*.tsx", "*.json", "*.html", "*.css" ;
    :excludePattern
        "node_modules/*",
        "dist/*",
        "build/*",
        ".git/*"
    .

:readConfig a :ConfigSet ;
    :mediaType "text/plain" .

:containerConfig a :ConfigSet ;
    :destination "terrapack.config.json" .

:writeConfig a :ConfigSet ;
    :destinationFile "terrapack-output.txt" .

================
File: src/applications/terrapack/file-container-test-application.txt
================
import fs from 'fs/promises';
import path from 'path';
import FileContainer from '../../processors/terrapack/FileContainer.js';

const config = {
    whiteboard: [],
    destination: "container-output.json"
};

async function testFileContainer() {
    const container = new FileContainer(config);

    // Test with multiple files
    const message1 = {
        filepath: "/test/file1.js",
        content: "console.log('test1')",
        rootDir: "/test"
    };

    const message2 = {
        filepath: "/test/dir/file2.js",
        content: "console.log('test2')",
        rootDir: "/test"
    };

    await container.process(message1);
    await container.process(message2);

    // Send done message to get output
    const finalMessage = { done: true };
    await container.process(finalMessage);

    console.log('Container test complete');
}

testFileContainer().catch(console.error);

================
File: src/applications/terrapack/terrapack-flow.md
================
# terrapack Pipeline Flow

## Command Processing

1. `./trans terrapack ./src` initiates with:
   - application = "terrapack"
   - target = "./src"
   - Command utils resolves target to absolute path
   - Sets targetPath in message object

## Pipeline Components

### 1. DirWalker (p10)

- Input: message with targetPath = resolved "./src" path
- Config:
  ```turtle
  trn:dirWalker a trn:ConfigSet ;
    trn:sourceDir "." ;
    trn:includeExtensions "['.md','.js','.ttl']"
  ```
- Process:
  - Walks target directory recursively
  - Filters files by includeExtensions
  - For each matching file emits message with:
    ```javascript
    {
      filepath: relative path,
      fullPath: absolute path,
      filename: basename,
      content: undefined // filled by FileReader
    }
    ```

### 2. StringFilter (p20)

- Input: individual file messages from DirWalker
- Config:
  ```turtle
  trn:filterConfig a trn:ConfigSet ;
    trn:includePatterns "*.txt,*.md,*.js..." ;
    trn:excludePatterns "node_modules/*,dist/*..."
  ```
- Process:
  - Filters files based on include/exclude patterns
  - Passes matching files downstream
  - Drops non-matching files

### 3. FileReader (p30)

- Input: filtered file messages
- Config:
  ```turtle
  trn:readConfig a trn:ConfigSet ;
    trn:mediaType "text/plain"
  ```
- Process:
  - Reads file content
  - Adds content to message.content
  - Preserves file metadata

### 4. FileContainer (p40)

- Input: messages with file content
- Config:
  ```turtle
  trn:containerConfig a trn:ConfigSet ;
    trn:destination "repomix.json"
  ```
- Process:
  - Accumulates files and metadata
  - Builds container structure:
    ```javascript
    {
      files: {
        [relativePath]: {
          content: string,
          type: string,
          timestamp: string
        }
      },
      summary: {
        totalFiles: number,
        fileTypes: Record<string, number>
      }
    }
    ```

### 5. CaptureAll (p50)

- Stores all messages in whiteboard array
- Preserves message flow

### 6. WhiteboardToMessage (p60)

- Transforms whiteboard array into structured message
- Groups similar properties

### 7. Unfork (p70)

- Collapses forked message paths
- Ensures single output path

### 8. FileWriter (p80)

- Input: final container message
- Config:
  ```turtle
  trn:writeConfig a trn:ConfigSet ;
    trn:destinationFile "repomix-output.txt"
  ```
- Process:
  - Writes formatted container to output file
  - Returns success message

## Expected Output

- repomix-output.txt containing:
  - Directory structure of src/
  - File contents
  - File metadata
  - Summary statistics

## Key Message Properties Throughout Pipeline

```javascript
{
  targetPath: "/absolute/path/to/src",
  rootDir: "/path/to/terrapack/app",
  filepath: "relative/path/to/file",
  content: "file contents",
  done: boolean // indicates completion
}
```

## Error Handling

1. DirWalker handles missing/invalid directories
2. StringFilter validates patterns before use
3. FileReader checks file accessibility
4. FileContainer validates content structure
5. FileWriter ensures directory exists

## Debug Points

- Check message.targetPath in DirWalker
- Verify pattern loading in StringFilter
- Monitor content preservation in FileReader
- Validate container structure before write

================
File: src/applications/terrapack/terrapack-sources.md
================
# terrapack Application Source Files

## Core Processing

```
src/api/cli/run.js                          # Entry point, command line processing
src/api/common/CommandUtils.js              # Command parsing and routing
src/core/ApplicationManager.js              # Application lifecycle management
src/core/TransmissionBuilder.js             # Pipeline construction from configs
src/core/ModuleLoader.js                    # Dynamic processor loading
src/core/ModuleLoaderFactory.js             # Processor module instantiation
```

## Pipeline Processors

```
src/processors/fs/DirWalker.js              # Directory traversal
src/processors/text/StringFilter.js         # File pattern matching
src/processors/fs/FileReader.js             # File content loading
src/processors/terrapack/FileContainer.js      # Content aggregation
src/processors/util/CaptureAll.js           # Message capture
src/processors/util/WhiteboardToMessage.js  # Message transformation
src/processors/flow/Unfork.js               # Pipeline convergence
src/processors/fs/FileWriter.js             # Output generation
```

## Configuration

```
src/applications/terrapack/transmissions.ttl   # Pipeline definition
src/applications/terrapack/config.ttl          # Processor configuration
src/applications/terrapack/about.md            # Application documentation
```

## Base Classes & Support

```
src/engine/Transmission.js                  # Pipeline execution engine
src/processors/base/Processor.js            # Base processor functionality
src/processors/base/ProcessorSettings.js    # Configuration management
```

## Factories

```
src/processors/fs/FsProcessorsFactory.js           # File system processors
src/processors/text/TextProcessorsFactory.js       # Text processing
src/processors/terrapack/PackerProcessorsFactory.js   # terrapack-specific processors
src/processors/util/UtilProcessorsFactory.js       # Utility processors
src/processors/flow/FlowProcessorsFactory.js       # Flow control processors
```

## Utilities

```
src/utils/ns.js                            # RDF namespace management
src/utils/Logger.js                        # Logging infrastructure
src/utils/footpath.js                      # Path resolution
src/utils/GrapoiHelpers.js                 # RDF graph utilities
```

================
File: src/applications/terrapack/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging - one instance only like this
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:terrapack a trn:Transmission ;
    rdfs:label "Repository terrapack" ;
    trn:pipe (:p10 :p20 :p30 :p40 :p50 :p60 :p70 :p80) .

:p10 a :DirWalker ;
    trn:settings :dirWalker .

:p20 a :StringFilter ;
    trn:settings :filterConfig .

:p30 a :FileReader ;
    trn:settings :readConfig .

:p40 a :FileContainer ;
    trn:settings :containerConfig .

:p50 a :CaptureAll .

:p60 a :WhiteboardToMessage .

:p70 a :Unfork .

:p80 a :FileWriter ;
    trn:settings :writeConfig .

================
File: src/applications/test_blanker/data/input/input-01.json
================
{
    "notpayload": "keep",
    "payload": {
        "nottest": "also keep",
        "test": {
            "first": "firststuff",
            "second": {
                "two": "twotwo"
            },
            "third": [
                "keep1",
                "keep2",
                "keep3"
            ],
            "fourth": [
                "31",
                "32",
                "33"
            ]
        }
    }
}

================
File: src/applications/test_blanker/data/output/output-01.json
================
{
    "notpayload": "keep",
    "payload": {
        "nottest": "also keep",
        "test": {
            "first": "",
            "second": {
                "two": ""
            },
            "third": [
                "keep1",
                "keep2",
                "keep3"
            ],
            "fourth": [
                "",
                "",
                ""
            ]
        }
    }
}

================
File: src/applications/test_blanker/data/output/required-01.json
================
{
    "notpayload": "keep",
    "payload": {
        "nottest": "also keep",
        "test": {
            "first": "",
            "second": {
                "two": ""
            },
            "third": [
                "keep1",
                "keep2",
                "keep3"
            ],
            "fourth": [
                "",
                "",
                ""
            ]
        }
    }
}

================
File: src/applications/test_blanker/about.md
================
# App Template

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_blanker
```

## Description

================
File: src/applications/test_blanker/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances


trn:r a trn:ConfigSet ;
    rdfs:label "Read file" ;
    trn:settings trn:readFile ;
    trn:sourceFile "input/input-01.json" ;
    trn:mediaType "application/json" .

trn:blanko a trn:ConfigSet ;
    rdfs:label "Root node in JSON object" ;
    trn:settings trn:blankin ;
    trn:pointer "content.payload.test"  ; # "Root node in JSON object" ;
    trn:preserve "content.payload.test.third" .

trn:w a trn:ConfigSet ;
    rdfs:label "Write file" ;
    trn:settings trn:writeFile ;
    trn:destinationFile "output/output-01.json"  .

================
File: src/applications/test_blanker/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:testBlanker a trn:Transmission ;
    trn:pipe (:p10 :p20 :p30 ) .

:p10 a :FileReader ; # JSON test file
       trn:settings :readFile .

:p20 a :Blanker ; # clear values
     trn:settings :blankin .

:p30 a :FileWriter ; # save result
       trn:settings :writeFile .

================
File: src/applications/test_config-settings/about.md
================
# App Template

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_config-settings
```

================
File: src/applications/test_config-settings/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .
@base <http://purl.org/stuff/path/> .

:settingsUseMessage a :ConfigSet ;
    :me ":settingsUseMessage" .

:settingsSingle a :ConfigSet ;
    :me ":settingsSingle" ;
    :name "Alice" .  # string literal

:settingsURI a :ConfigSet ;
    :me ":settingsURI" ;
    :uri <http://example.org> .  # regular URI

[] :todo "need to check ontology for this" .
# #:todo needs something like :path a :Path .
:settingsPath a :ConfigSet ;
    :me ":settingsPath" ;
    :path <dirA> .  # subdirectory path

:settingsMulti a :ConfigSet ;
    :me ":settingsMulti" ;
    :name "Bob" ;
    :uri <dirB> .

:settingsLists a :ConfigSet ;
  # :loglevel 'debug' ; TODO #:todo MOVE TO TRANSMISSION
    :me ":settingsLists" ;
    :aSetting  "settingA1", "settingA2", "settingA3" ;
    :bSetting  "settingB1", "settingB2", "settingB3" .

:settingsKeyValue a :ConfigSet ;
    :me ":settingsKeyValue" ;
    :setters (:setter1)  . # consider using blank nodes
        :setter1    :key    "myKey" ;
                    :value  "myValue"  .

================
File: src/applications/test_config-settings/test-settings-simple.js
================
import TestSettings from '../../processors/test/TestSettings.js'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'


const dataset = rdf.dataset()
const settingsNode = rdf.namedNode('http://example.org/settings')
const config = { dataset }


dataset.add(rdf.quad(
    settingsNode,
    ns.rdf.type,
    ns.trn.ConfigSet
))

dataset.add(rdf.quad(
    settingsNode,
    ns.trn.name,
    rdf.literal('Test Name')
))

dataset.add(rdf.quad(
    settingsNode,
    ns.trn.path,
    rdf.namedNode('http://example.org/test/path')
))


const testSettings = new TestSettings(config)
testSettings.settingsNode = settingsNode


const message = { value: '42' }

async function runTest() {

    const result = await testSettings.process(message)
    logger.log('Name from config:', testSettings.getProperty(ns.trn.name))
    logger.log('Path from config:', testSettings.getProperty(ns.trn.path))
    logger.reveal(result)
}

runTest().catch(console.error)

================
File: src/applications/test_config-settings/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:testSettings a :Transmission ;
    :pipe (:SC :ts0 :ts10 :ts20 :ts30 :ts40 :ts50 :ts60 :ts70 :SM) .


:ts0 a :TestSettings  .

:ts10 a :TestSettings ;
     :settings :settingsNotAValue .

:ts20 a :TestSettings ;
     :settings :settingsUseMessage .

:ts30 a :TestSettings ;
     :settings :settingsSingle .

:ts40 a :TestSettings ;
     :settings :settingsURI .

:ts50 a :TestSettings ;
     :settings :settingsMulti .

:ts60 a :TestSettings ;
     :settings :settingsLists .

:ts70 a :SetMessage ;
     :settings :settingsKeyValue .

================
File: src/applications/test_config-settings copy/about.md
================
# App Template

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_config-settings
```

================
File: src/applications/test_config-settings copy/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .
@base <http://purl.org/stuff/path/> .

:settings1 a :ConfigSet ;
    :name "Alice" .  # string literal

:settings2 a :ConfigSet ;
    :path <dirA> .  # subdirectory path

:settings3 a :ConfigSet ;
    :name "Bob" ;
    :path <dirB> .

:settings4 a :ConfigSet ;
    :setters (:setter1)  . # consider using blank nodes
        :setter1    :key    "s4s1" ;
                    :value  "value4"  .

:settings5 a :ConfigSet ;
    :name "Constantine" ;
    :path <dirC> ;
    :setters (:setter2 :setter3)  . # consider using blank nodes
        :setter2    :key    "s5s2" ;
                    :value   "value52"  .
        :setter3    :key    "s5s3" ;
                    :value    "value53"  .

================
File: src/applications/test_config-settings copy/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:testConfig a :Transmission ;
    :pipe (:tc10) .

:tc10 a :ShowSettings ;
     :settings :settings1 .

###############################
:p10 a :SetMessage ;
     :settings :set1 .

:p20 a :ShowMessage .

:p30 a :SetMessage ;
    :settings :set2 .

:p40 a :ShowMessage .

================
File: src/applications/test_configmap/data/input/input-01.md
================
Hello!

================
File: src/applications/test_configmap/data/output/output-01.md
================
Hello!

================
File: src/applications/test_configmap/data/output/required-01.md
================
Hello!

================
File: src/applications/test_configmap/about.md
================
# Application : test_fs-rw

```sh
cd ~/github-danny/transmissions/ # my local path

# run as application
./trans test_configmap
```

================
File: src/applications/test_configmap/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:readDataset a trn:ConfigSet ;
    trn:settings trn:readDataset ;
    trn:datasetFile "manifest.ttl" .

trn:configMapper a trn:ConfigSet ;
    trn:settings trn:configMapper ;
    trn:pathMappings (
        trn:postContent
    ) .

================
File: src/applications/test_configmap/manifest.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

<https://danny.ayers.name> a trn:Site ;
    rdfs:label "danny.ayers.name" ;
    dcterms:title "Rawer" ;
    trn:contains <https://danny.ayers.name/home> ;  # maybe
    trn:includes trn:PostContent . # maybe

# this should maybe give the contentgroup a renderType, indirect with template etc

# ENTRIES CONTENT
trn:PostContent a trn:ContentGroup ;
    rdfs:label "entries" ;
    trn:site <https://danny.ayers.name> ;
    trn:subdir "home" ; # better property name?
    trn:sourceDirectory "content-raw/entries" ; # SOURCE DIR HERE journal, entries
    trn:targetDirectory "cache/entries" ;
    trn:template "layouts/middlin/templates/entry-content_template.njk" .

================
File: src/applications/test_configmap/simple.js
================
import FileReader from '../../processors/fs/FileReader.js'
import FileWriter from '../../processors/fs/FileWriter.js'

const config = {
    "simples": "true",
    "sourceFile": "input/input-01.md",
    "destinationFile": "output/output-01.md"
}

var message = { "dataDir": "src/applications/test_fs-rw/data" }

const read = new FileReader(config)

message = await read.process(message)

const write = new FileWriter(config)

message = await write.process(message)

================
File: src/applications/test_configmap/test-config.json
================
{
    "transmissions": [
        {
            "name": "test_fs-rw",
            "message": {
                "content": "Hello World"
            },
            "requiredFiles": [
                "output-01.md"
            ]
        }
    ]
}

================
File: src/applications/test_configmap/transmissions.ttl
================
# src/applications/test_configmap/transmissions.ttl
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:

:configtest a trn:Transmission ;
    trn:pipe (:s10 :s20 :s30) .

:s10 a :DatasetReader ;
    trn:settings :readDataset .

:s20 a :ConfigMap ;
    trn:settings :configMapper .

:s30 a :ShowMessage .

================
File: src/applications/test_dirwalker/about.md
================
# DirWalker

## Runner

```sh
cd ~/github-danny/transmissions  # my local path

./trans test_dirwalker
```

## Description

---

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/test_dirwalker/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .



:dirWalker a :ConfigSet ;
    :sourceDir "." .  # subdirectory path

================
File: src/applications/test_dirwalker/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage .
:SM2 a :ShowMessage .
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:dirwalk a :Transmission ;
    :pipe (:SM1 :s1 :s2 :SM2) .

:s1 a :DirWalker ;
 :settings :dirWalker . # specify in config.ttl

:s2 a :NOP .

================
File: src/applications/test_env-loader/about.md
================
```sh
cd ~/github-danny/transmissions
./trans env-loader-test
```

================
File: src/applications/test_env-loader/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:walkPrep a trn:ReMap ;
    trn:rename (trn:pp1 trn:pp2) . # consider using blank nodes
    trn:pp1   trn:pre     "content" ;
            trn:post    "template"  .
    trn:pp2   trn:pre     "entryContentMeta.sourceDir" ;
            trn:post    "sourceDir" .

================
File: src/applications/test_env-loader/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:envy a trn:Transmission ;
    trn:pipe (:s10 :s20 :SM) .
# trn:pipe (:SC) .
:s10 a :EnvLoader .
:s20 a :WhiteboardToMessage .

================
File: src/applications/test_file-copy-remove/data/several-full/one.txt
================
Hello from One

================
File: src/applications/test_file-copy-remove/data/several-full/two.txt
================
Hello from Two

================
File: src/applications/test_file-copy-remove/data/single-full/one.txt
================
Hello from One

================
File: src/applications/test_file-copy-remove/data/start/one.txt
================
Hello from One

================
File: src/applications/test_file-copy-remove/data/start/two.txt
================
Hello from Two

================
File: src/applications/test_file-copy-remove/about.md
================
# file-copy-remove-test

run with :

```
# in transmissions dir

./run file-copy-remove-test
```

or

```
npm test -- tests/integration/file-copy-remove-test.spec.js
```

this should :

- copy `start/one.txt` into `single-empty/`
- copy `single-empty/one.txt` into `single-full/`
- remove `single-empty/one.txt`

- copy everything in `start/` into `several-empty/`
- copy everything in `several-empty/` into `several-full/`
- remove everything in `several-empty/`

Hmm, test services would be helpful to check before and after - or maybe just use regular test runner script from npm?

================
File: src/applications/test_file-copy-remove/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

#trn:copyOneToSingleEmpty a trn:ConfigSet ;
 #   trn:key trn:copyOneToSingleEmpty ;
  #  trn:source "data/start/one.txt" ;
   # trn:destination "data/single-empty/one.txt" .

trn:copyOneToSingleEmpty a trn:ConfigSet ;
    trn:key trn:copyOneToSingleEmpty ;
    trn:source "data/start/one.txt" ;
    trn:destination "data/single-empty/one.txt" .

trn:copySingleEmptyToSingleFull a trn:ConfigSet ;
    trn:key trn:copySingleEmptyToSingleFull ;
    trn:source "data/single-empty/one.txt" ;
    trn:destination "data/single-full/one.txt" .

trn:removeSingleEmpty a trn:ConfigSet ;
    trn:key trn:removeSingleEmpty ;
    trn:target "data/single-empty/one.txt" .

trn:copyStartToSeveralEmpty a trn:ConfigSet ;
    trn:key trn:copyStartToSeveralEmpty ;
    trn:source "data/start" ;
    trn:destination "data/several-empty" .

trn:copySeveralEmptyToSeveralFull a trn:ConfigSet ;
    trn:key trn:copySeveralEmptyToSeveralFull ;
    trn:source "data/several-empty" ;
    trn:destination "data/several-full" .

trn:removeSeveralEmpty a trn:ConfigSet ;
    trn:key trn:removeSeveralEmpty ;
    trn:target "data/several-empty" .

================
File: src/applications/test_file-copy-remove/init.sh
================
rm -rf data/start
rm -rf data/single-empty
rm -rf data/single-full
rm -rf data/several-empty
rm -rf data/several-full



mkdir -p data/start






echo 'Hello from One' > data/start/one.txt


echo 'Hello from Two' > data/start/two.txt

tree data

================
File: src/applications/test_file-copy-remove/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:file_copy_remove_test a trn:Transmission ;
    trn:pipe (:s1 :s2 :s3 :s4 :s5 :s6) .

:s1 a :FileCopy ;
    trn:settings :copyOneToSingleEmpty .

:s2 a :FileCopy ;
    trn:settings :copySingleEmptyToSingleFull .

:s3 a :FileRemove ;
    trn:settings :removeSingleEmpty .

:s4 a :FileCopy ;
    trn:settings :copyStartToSeveralEmpty .

:s5 a :FileCopy ;
    trn:settings :copySeveralEmptyToSeveralFull .

:s6 a :FileRemove ;
    trn:settings :removeSeveralEmpty .

================
File: src/applications/test_file-to-sparqlstore/data/input/input.md
================
# Test Blog Post

This is a test blog post that will be converted to RDF and stored in the SPARQL database.

## Metadata

- Title: Test Blog Post
- Author: Test User
- Email: test@example.com

## Content

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis
nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

================
File: src/applications/test_file-to-sparqlstore/diamonds/select-blogposting.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?post ?headline ?content ?published ?modified ?author
WHERE {
  ?post a schema:BlogPosting ;
        schema:headline ?headline ;
        schema:description ?content ;
        schema:datePublished ?published ;
        schema:dateModified ?modified ;
        schema:author/schema:name ?author .
  FILTER(?published >= "{{startDate}}"^^xsd:dateTime)
}
ORDER BY DESC(?published)
LIMIT 1

================
File: src/applications/test_file-to-sparqlstore/diamonds/update-blogposting.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

INSERT DATA {
  <http://example.com/posts/{{id}}> a schema:BlogPosting ;
    schema:headline "{{title}}" ;
    schema:url <http://example.com/posts/{{id}}> ;
    schema:description """{{content}}""" ;
    schema:datePublished "{{published}}"^^xsd:dateTime ;
    schema:dateModified "{{modified}}"^^xsd:dateTime ;
    schema:author [
      a schema:Person ;
      schema:name "{{author.name}}" ;
      schema:email "{{author.email}}"
    ] .
}

================
File: src/applications/test_file-to-sparqlstore/docs/handover-doc.md
================
# SPARQL Integration Handover Document

## New Components Added

### 1. SPARQL Processors
- **SPARQLSelect.js**: Query processor with template support
- **SPARQLUpdate.js**: Update processor with template support
- **SPARQLProcessorsFactory.js**: Factory for processor instantiation

### 2. Test Application
- Location: src/applications/test_file-to-sparqlstore/
- Purpose: End-to-end testing of SPARQL integration
- Integration with FileReader for markdown processing

### 3. Configuration Files
- endpoint.json: SPARQL endpoint configuration
- Test data and templates under diamonds/
- SPARQL query/update templates

## Key Technical Details

### Authentication
- Uses Basic Auth
- Credentials in endpoint.json
- Separate configs for query/update endpoints

### Data Model
- Uses schema.org vocabulary
- BlogPosting as primary type
- Nested author information
- Timestamps for created/modified

### Error Handling
- Network failures
- Authentication errors
- Query validation
- Template rendering errors

## Testing

### Automated Tests
- Unit tests for processors
- Integration tests for pipeline
- Template validation

### Manual Testing
- Test scripts in bash/Python
- Example queries
- Curl commands for direct testing

## Dependencies
- axios for HTTP
- nunjucks for templates
- rdf-ext for RDF handling

## Known Issues/TODOs
1. Template caching not implemented
2. Bulk operations not optimized
3. Add transaction support
4. Enhance error reporting

================
File: src/applications/test_file-to-sparqlstore/docs/handover.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix prj: <http://purl.org/stuff/project/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix code: <http://purl.org/stuff/code/> .

# Project Component Description
trn:SPARQLIntegration a prj:Component ;
    dcterms:title "SPARQL Integration for Transmissions" ;
    dcterms:description "SPARQL query and update processors with test application" ;
    dcterms:created "2024-01-16"^^xsd:date ;
    prj:status "Testing" ;
    prj:version "1.0.0" ;
    prj:maintainer <http://danny.ayers.name> ;
    prj:documentation trn:SPARQLDocs .

# Documentation
trn:SPARQLDocs a prj:Documentation ;
    prj:hasSection trn:ProcessorDocs, trn:TestAppDocs, trn:ConfigDocs .

trn:ProcessorDocs a prj:DocumentationSection ;
    dcterms:title "SPARQL Processors" ;
    prj:covers trn:SPARQLSelect, trn:SPARQLUpdate ;
    prj:location "/src/processors/sparql/" .

# Components
trn:SPARQLSelect a code:Processor ;
    dcterms:title "SPARQL Select Processor" ;
    code:implements trn:QueryExecution ;
    code:dependsOn trn:EndpointConfig ;
    code:hasTest trn:SelectTests .

trn:SPARQLUpdate a code:Processor ;
    dcterms:title "SPARQL Update Processor" ;
    code:implements trn:UpdateExecution ;
    code:dependsOn trn:EndpointConfig ;
    code:hasTest trn:UpdateTests .

# Test Application
trn:TestApp a code:Application ;
    dcterms:title "SPARQL Store Test" ;
    code:location "/src/applications/test_file-to-sparqlstore/" ;
    code:uses trn:SPARQLSelect, trn:SPARQLUpdate ;
    code:hasConfig trn:EndpointConfig .

# Configuration
trn:EndpointConfig a code:Configuration ;
    dcterms:title "SPARQL Endpoint Configuration" ;
    code:format "JSON" ;
    code:location "endpoint.json" ;
    code:template [
        code:field "type" ;
        code:required true ;
        code:allowedValues "query", "update"
    ], [
        code:field "url" ;
        code:required true ;
        rdfs:comment "SPARQL endpoint URL"
    ] .

# Known Issues
trn:Issues a prj:IssueList ;
    prj:hasIssue [
        a prj:TODO ;
        dcterms:title "Template Caching" ;
        prj:priority "Medium"
    ], [
        a prj:TODO ;
        dcterms:title "Transaction Support" ;
        prj:priority "High"
    ] .

================
File: src/applications/test_file-to-sparqlstore/docs/sparql-processors-docs.md
================
# SPARQL Processors Documentation

## Overview
The SPARQL processors provide functionality for interacting with SPARQL endpoints through the Transmissions pipeline framework. Two main processors are provided:
- SPARQLSelect: Executes SELECT queries
- SPARQLUpdate: Executes UPDATE operations

## Configuration
Configuration is managed through endpoint.json:
```json
{
    "name": "local query",
    "type": "query|update",
    "url": "http://localhost:3030/dataset/query",
    "credentials": {
        "user": "username",
        "password": "password"
    }
}
```

## SPARQLSelect Processor
Executes templated SELECT queries against a SPARQL endpoint.

### Usage
```turtle
:query a :Transmission ;
    :pipe (:p10) .

:p10 a :SPARQLSelect ;
    :settings [
        :templateFilename "queries/select.njk" ;
        :endpointSettings "endpoint.json"
    ] .
```

### Template Variables
- startDate: ISO datetime for filtering
- Additional variables from message object

## SPARQLUpdate Processor
Executes templated UPDATE operations against a SPARQL endpoint.

### Usage
```turtle
:update a :Transmission ;
    :pipe (:p10) .

:p10 a :SPARQLUpdate ;
    :settings [
        :templateFilename "queries/update.njk" ;
        :endpointSettings "endpoint.json"
    ] .
```

### Template Variables
- id: Auto-generated UUID
- title: From message.meta.title
- content: From message.content
- published/modified: Current timestamp
- author: From message.meta.author

## Error Handling
- Connection failures throw network errors
- Authentication failures throw 401/403 errors
- Invalid queries throw 400 errors
- All errors include detailed messages in logs

================
File: src/applications/test_file-to-sparqlstore/docs/test-app-docs.md
================
# SPARQL Store Test Application

## Purpose
Tests complete pipeline functionality for reading files, converting to RDF, storing in a SPARQL database, and verifying storage through queries.

## Quick Start
1. Configure SPARQL endpoint in endpoint.json
2. Place test markdown in data/input/input.md
3. Run application:
```bash
./trans test_file-to-sparqlstore
```

## Components
1. FileReader processor:
   - Reads input markdown
   - Extracts metadata and content

2. SPARQLUpdate processor:
   - Converts markdown to RDF using schema.org vocabulary
   - Stores in SPARQL database

3. SPARQLSelect processor:
   - Queries stored data
   - Verifies successful storage

## Testing
### Manual Testing
Use provided test scripts:
```bash
# Using bash script
./test-queries.sh

# Using Python script
python3 test-queries.py
```

### Example Queries
```sparql
# Find recently added posts
SELECT ?post ?title WHERE {
  ?post a schema:BlogPosting ;
        schema:headline ?title ;
        schema:datePublished ?date .
  FILTER(?date >= "2024-01-01T00:00:00Z"^^xsd:dateTime)
}
```

## Configuration
1. endpoint.json: SPARQL endpoint details
2. config.ttl: Transmission configuration
3. transmissions.ttl: Pipeline definition
4. diamonds/*.njk: Query templates

## Error Cases Handled
- Missing input files
- SPARQL endpoint connection failures
- Authentication errors
- Invalid markdown format
- Failed data verification

================
File: src/applications/test_file-to-sparqlstore/examples/blog-post-rdf.txt
================
@prefix schema: <http://schema.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://example.com/posts/fb5e0595-2e98-4c5c-9876-7f402c6439a2> 
    a schema:BlogPosting ;
    schema:headline "Test Blog Post" ;
    schema:description """Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor 
incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis 
nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.""" ;
    schema:datePublished "2024-01-16T15:55:43.049Z"^^xsd:dateTime ;
    schema:dateModified "2024-01-16T15:55:43.049Z"^^xsd:dateTime ;
    schema:author [
        a schema:Person ;
        schema:name "Test User" ;
        schema:email "test@example.com"
    ] ;
    schema:articleBody """# Test Blog Post

This is a test blog post that will be converted to RDF and stored in the SPARQL database.

## Metadata
- Title: Test Blog Post  
- Author: Test User
- Email: test@example.com

## Content
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor 
incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis 
nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.""" .

================
File: src/applications/test_file-to-sparqlstore/examples/sparql-queries.md
================
# Query all blog posts
PREFIX schema: <http://schema.org/>
SELECT ?post ?title ?date ?author WHERE {
  ?post a schema:BlogPosting ;
        schema:headline ?title ;
        schema:datePublished ?date ;
        schema:author/schema:name ?author .
} ORDER BY DESC(?date)

# Query posts by specific author
PREFIX schema: <http://schema.org/>
SELECT ?post ?title ?date WHERE {
  ?post a schema:BlogPosting ;
        schema:headline ?title ;
        schema:datePublished ?date ;
        schema:author [ schema:name "Test User" ] .
} ORDER BY DESC(?date)

# Query posts in date range
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
SELECT ?post ?title ?date WHERE {
  ?post a schema:BlogPosting ;
        schema:headline ?title ;
        schema:datePublished ?date .
  FILTER(?date >= "2024-01-01T00:00:00Z"^^xsd:dateTime && 
         ?date <= "2024-12-31T23:59:59Z"^^xsd:dateTime)
} ORDER BY DESC(?date)

# Update/Insert new blog post
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
INSERT DATA {
  <http://example.com/posts/test-123> a schema:BlogPosting ;
    schema:headline "Test Post" ;
    schema:description "Test content" ;
    schema:datePublished "2024-01-16T10:00:00Z"^^xsd:dateTime ;
    schema:dateModified "2024-01-16T10:00:00Z"^^xsd:dateTime ;
    schema:author [
      a schema:Person ;
      schema:name "Test User" ;
      schema:email "test@example.com"
    ] .
}

# Delete a blog post
PREFIX schema: <http://schema.org/>
DELETE WHERE {
  <http://example.com/posts/test-123> ?p ?o .
  OPTIONAL { ?o ?p2 ?o2 }
}

================
File: src/applications/test_file-to-sparqlstore/about.md
================
`src/applications/test_file-to-sparqlstore/about.md`

# Application 'test_file-to-sparqlstore'

**Checks interaction with SPARQL store**

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_file-to-sparqlstore
```

## Description

1. Reads a file from fs
2. Templates it using nunjucks into a SPARQL UPDATE query
3. POSTs this to the specified endpoint
4. Does a SPARQL SELECT query (based on date) to retrieve data
5. Compares this with the original content to ensure it is in the store

Data looks something like :

```turtle
@prefix schema: <http://schema.org/> .

<http://example.com/posts-one> a schema:BlogPosting ;
    schema:headline "Post one" ;
    schema:url <http://example.com/posts-one> ;
    schema:description "Post one content." ;
    schema:datePublished "2023-05-22T13:00:00Z"^^xsd:dateTime ;
    schema:dateModified "2023-05-22T15:00:00Z"^^xsd:dateTime ;
    schema:author [
        a schema:Person ;
        schema:name "John Doe" ;
        schema:email "johndoe@example.com"
    ] .
```

## Notes

TODO complete -

src/applications/test_file-to-sparqlstore
 about.md
 config.ttl
 data
  input
   input.md
  output
 diamonds
  select-blogposting.njk
  update-blogposting.njk
 endpoint.json
 transmissions.ttl

src/processors/sparql
 about.md
 SPARQLProcessorsFactory.js
 SPARQLSelect.js
 SPARQLUpdate.js

================
File: src/applications/test_file-to-sparqlstore/config.ttl
================
# src/applications/test_file-to-sparqlstore/config.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:readerSet a :ConfigSet ;
    :sourceFile  "input/input.md" ;
    :metaField "meta" .

:sparqlUpdate a :ConfigSet ;
    :templateFilename "diamonds/update-blogposting.njk" ;
    :endpointSettings "endpoint.json" .

:sparqlSelect a :ConfigSet ;
    :templateFilename "diamonds/select-blogposting.njk" ;
    :endpointSettings "endpoint.json" .

================
File: src/applications/test_file-to-sparqlstore/endpoint.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:3030/test/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:3030/test/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: src/applications/test_file-to-sparqlstore/python-test.py
================
import requests
import json
from base64 import b64encode
from datetime import datetime


ENDPOINT_QUERY = "http://localhost:3030/test/query"
ENDPOINT_UPDATE = "http://localhost:3030/test/update"
AUTH_USER = "admin"
AUTH_PASS = "admin123"


auth_string = b64encode(f"{AUTH_USER}:{AUTH_PASS}".encode()).decode()
HEADERS = {
    'Authorization': f'Basic {auth_string}',
    'Accept': 'application/json'
}

def run_query(query):

    headers = {**HEADERS, 'Content-Type': 'application/sparql-query'}
    response = requests.post(ENDPOINT_QUERY,
                           headers=headers,
                           data=query)
    response.raise_for_status()
    return response.json()

def run_update(update):

    headers = {**HEADERS, 'Content-Type': 'application/sparql-update'}
    response = requests.post(ENDPOINT_UPDATE,
                           headers=headers,
                           data=update)
    response.raise_for_status()
    return response.status_code

def test_queries():

    insert_query = """
    PREFIX schema: <http://schema.org/>
    PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
    INSERT DATA {
      <http://example.com/posts/test-123> a schema:BlogPosting ;
        schema:headline "Python Test Post" ;
        schema:description "Test content from Python" ;
        schema:datePublished "2024-01-16T10:00:00Z"^^xsd:dateTime ;
        schema:dateModified "2024-01-16T10:00:00Z"^^xsd:dateTime ;
        schema:author [
          a schema:Person ;
          schema:name "Python Test User" ;
          schema:email "python@example.com"
        ] .
    }
    """
    print("Inserting test data...")
    status = run_update(insert_query)
    print(f"Insert status: {status}")


    select_query = """
    PREFIX schema: <http://schema.org/>
    SELECT ?post ?title ?date ?author
    WHERE {
      ?post a schema:BlogPosting ;
            schema:headline ?title ;
            schema:datePublished ?date ;
            schema:author/schema:name ?author .
    } ORDER BY DESC(?date)
    """
    print("\nQuerying all posts...")
    results = run_query(select_query)
    print(json.dumps(results, indent=2))


    delete_query = """
    PREFIX schema: <http://schema.org/>
    DELETE WHERE {
      <http://example.com/posts/test-123> ?p ?o .
      OPTIONAL { ?o ?p2 ?o2 }
    }
    """
    print("\nDeleting test data...")
    status = run_update(delete_query)
    print(f"Delete status: {status}")

if __name__ == "__main__":
    try:
        test_queries()
    except requests.exceptions.RequestException as e:
        print(f"Error during SPARQL operations: {e}")

================
File: src/applications/test_file-to-sparqlstore/test-queries.sh
================
ENDPOINT_QUERY="http://localhost:3030/test/query"
ENDPOINT_UPDATE="http://localhost:3030/test/update"
AUTH_USER="admin"
AUTH_PASS="admin123"
AUTH_HEADER="Authorization: Basic $(echo -n ${AUTH_USER}:${AUTH_PASS} | base64)"


urlencode() {
  local string="${1}"
  echo "${string}" | curl -Gso /dev/null -w %{url_effective} --data-urlencode @- "" | cut -c 3-
}

# Test Query - Get all posts
echo "Testing: Get all posts"
curl -X POST $ENDPOINT_QUERY \
  -H "Content-Type: application/sparql-query" \
  -H "Accept: application/json" \
  -H "$AUTH_HEADER" \
  --data-raw 'PREFIX schema: <http://schema.org/>
  SELECT ?post ?title ?date ?author
  WHERE {
    ?post a schema:BlogPosting ;
          schema:headline ?title ;
          schema:datePublished ?date ;
          schema:author/schema:name ?author .
  } ORDER BY DESC(?date)'


echo -e "\nTesting: Get posts by author"
curl -X POST $ENDPOINT_QUERY \
  -H "Content-Type: application/sparql-query" \
  -H "Accept: application/json" \
  -H "$AUTH_HEADER" \
  --data-raw 'PREFIX schema: <http://schema.org/>
  SELECT ?post ?title ?date
  WHERE {
    ?post a schema:BlogPosting ;
          schema:headline ?title ;
          schema:datePublished ?date ;
          schema:author [ schema:name "Test User" ] .
  } ORDER BY DESC(?date)'


echo -e "\nTesting: Insert new post"
curl -X POST $ENDPOINT_UPDATE \
  -H "Content-Type: application/sparql-update" \
  -H "$AUTH_HEADER" \
  --data-raw 'PREFIX schema: <http://schema.org/>
  PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
  INSERT DATA {
    <http://example.com/posts/test-123> a schema:BlogPosting ;
      schema:headline "Test Post" ;
      schema:description "Test content" ;
      schema:datePublished "2024-01-16T10:00:00Z"^^xsd:dateTime ;
      schema:dateModified "2024-01-16T10:00:00Z"^^xsd:dateTime ;
      schema:author [
        a schema:Person ;
        schema:name "Test User" ;
        schema:email "test@example.com"
      ] .
  }'


echo -e "\nTesting: Delete post"
curl -X POST $ENDPOINT_UPDATE \
  -H "Content-Type: application/sparql-update" \
  -H "$AUTH_HEADER" \
  --data-raw 'PREFIX schema: <http://schema.org/>
  DELETE WHERE {
    <http://example.com/posts/test-123> ?p ?o .
    OPTIONAL { ?o ?p2 ?o2 }
  }'

================
File: src/applications/test_file-to-sparqlstore/transmissions.ttl
================
# src/applications/test_file-to-sparqlstore/transmissions.ttl

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:test_filereader a :Transmission ;
:pipe (:p10 :SM1 :p20 :p30 :SM2) .

:p10 a :FileReader ;
     :settings :readerSet .

:p20 a :SPARQLUpdate ;
     :settings :sparqlUpdate .

:p30 a :SPARQLSelect ;
     :settings :sparqlSelect .

================
File: src/applications/test_filename-mapper/data/input/input-01.txt
================
Test content for filename mapping

================
File: src/applications/test_filename-mapper/data/output/required-01.txt
================
Test content for filename mapping

================
File: src/applications/test_filename-mapper/about.md
================
# Test Filename Mapper

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_filename-mapper

npm test -- tests/unit/filename-mapper.spec.js
npm test -- tests/integration/filename-mapper.spec.js
```

## Description

Tests the FilenameMapper processor by:

1. Reading a file
2. Mapping its filename according to configuration
3. Writing the file with the new name

## Test Files

- Input: data/input/input-01.txt
- Expected: data/output/required-01.txt
- Output: data/output/output-01.txt

================
File: src/applications/test_filename-mapper/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:readFile a trn:ConfigSet ;
    rdfs:label "Read file" ;
    trn:settings trn:readConfig ;
    trn:sourceFile "input/input-01.txt" ;
    trn:mediaType "text/plain" .

trn:mapperConfig a trn:ConfigSet ;
    rdfs:label "Filename mapper config" ;
    trn:settings trn:filenameConfig ;
    trn:extensions (trn:ext1 trn:ext2) .

trn:ext1
    trn:format "html" ;
    trn:extension ".mm.html" .

trn:ext2
    trn:format "svg" ;
    trn:extension ".mm.svg" .

trn:writeFile a trn:ConfigSet ;
    rdfs:label "Write file" ;
    trn:settings trn:writeConfig ;
    trn:destinationFile "output/output-01.txt" .

================
File: src/applications/test_filename-mapper/filename-mapper-simple.js
================
import FilenameMapper from '../../processors/fs/FilenameMapper.js';
import FileReader from '../../processors/fs/FileReader.js';
import FileWriter from '../../processors/fs/FileWriter.js';

const config = {
    "simples": true,
    "sourceFile": "input/input-01.txt",
    "destinationFile": "output/output-01.txt",
    "extensions": {
        "html": ".mm.html",
        "svg": ".mm.svg"
    }
};

async function runPipeline() {
    var message = {
        "dataDir": "src/applications/test_filename-mapper/data",
        "format": "html"
    };


    const reader = new FileReader(config);
    message = await reader.process(message);


    const mapper = new FilenameMapper(config);
    message = await mapper.process(message);


    const writer = new FileWriter(config);
    message = await writer.process(message);

    return message;
}

runPipeline().catch(console.error);

================
File: src/applications/test_filename-mapper/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:test_filenameMapper a trn:Transmission ;
    trn:pipe (:p10 :SM :p20 :p30) .

:p10 a :FileReader ;
    trn:settings :readConfig .

:p20 a :FilenameMapper ;
    trn:settings :filenameConfig .

:p30 a :FileWriter ;
    trn:settings :writeConfig .

================
File: src/applications/test_filereader/data/input/input.md
================
This is the content of file input.md

================
File: src/applications/test_filereader/about.md
================
# Example Application `about.md`

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_filereader
```

## Description

---

================
File: src/applications/test_filereader/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:readerSet a :ConfigSet ;
    :sourceFile  "input/input.md" ;
    :metaField "meta" .

================
File: src/applications/test_filereader/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:test_filereader a trn:Transmission ;
trn:pipe (:SM :p10 :SM1) .

:p10 a :FileReader ;
     trn:settings :readerSet .

================
File: src/applications/test_foreach/about.md
================
# ForEach processor module for Transmissions

```sh
./trans test_fork
```

Your Goal is to write a processor module for Transmissions that will initiate multiple processing pipelines based on a list provided in the incoming message. First review these instructions as a whole, and then identify the subgoals. Then, taking each subgoal in turn, break it down into a concrete series of tasks. Carry out the sequence of tasks.  
You have plenty of time, so don't rush, try to be as careful in understanding and operation as possible.
Existing source code may be found in the Project Knowledge files.

Two modules are required -

1. `ForEach` located in :

```sh
./transmissions/src/processors/flow/ForEach.js
```

modeled on :

```sh
./transmissions/src/processors/templates/ProcessorTemplate.js
```

2. `FlowProcessorsFactory` located in

```sh
./transmissions/src/processors/flow/FlowProcessorsFactory.js
```

modeled on :

```sh
/transmissions/src/processors/templates/TemplateProcessorsFactory.js
```

The input message will contain the list to be processed in the form of this example :

```json
{
  "foreach": ["item1", "item2", "item3"]
}
```

The behavior will be to emit the message to a subsequent processor using the existing engine infrastructure, like a simpler version of :

```sh
transmissions/src/processors/fs/DirWalker.js
```

Each message emitted will be a structuredClone of the input message.

Once this code is completed, create application definitions in the form of these examples :

```sh
transmissions/src/applications/test_fork/transmissions.ttl
transmissions/src/applications/test_fork/processors-config.ttl
```

After you have finished all these, re-read the high level Goal and taking each of your derived subgoals in turn, review your code to ensure that it fulfils the requirements.
Show me the full source of the implementations.

---

/home/danny/github-danny/postcraft/danny.ayers.name/content-raw/entries/2024-09-27_lively-distractions.md

https://github.com/github/rest-api-description

================
File: src/applications/test_foreach/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

:foreach_test a trn:Transmission ;
    trn:pipe (:s1 :s2 :s3) .

:s1 a :ForEach .
:s2 a :ShowMessage .
:s3 a :DeadEnd .

================
File: src/applications/test_fork/about.md
================
# Test Fork/Unfork

```
./run test_fork | grep 's2 a NOP'
```

should show the number of forks + 1 (for `message.done`)

```
./run test_fork | grep s1.s2.s10.s11.s12.s13
```

should show just one

================
File: src/applications/test_fork/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

================
File: src/applications/test_fork/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:test_fork a :Transmission ;
   trn:contains :pipeA .

:pipeA a trn:Transmission ;
trn:pipe (:p10 :p20 :SM ) .

:p10 a :Fork .

# :s10 a :Unfork .
:p20 a :NOP .

================
File: src/applications/test_fork-unfork/about.md
================
# Test Fork/Unfork

## ./trans test_fork-unfork

```
./run test_fork | grep 's2 a NOP'
```

should show the number of forks + 1 (for `message.done`)

```
./run test_fork | grep s1.s2.s10.s11.s12.s13
```

should show just one

================
File: src/applications/test_fork-unfork/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

================
File: src/applications/test_fork-unfork/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:test_fork_unfork a :Transmission ;
#   trn:contains :pipeA .
# TODO
#:pipeA a trn:Transmission ;
trn:pipe (:p10 :p20 :p30 :p40) .

:p10 a :Fork .

:p20 a :NOP .

:p30 a :Unfork .

:p40 a :ShowMessage .

================
File: src/applications/test_fs-rw/data/input/input-01.md
================
Hello!

================
File: src/applications/test_fs-rw/data/output/required-01.md
================
Hello!

================
File: src/applications/test_fs-rw/about.md
================
# Application : test_fs-rw

```sh
cd ~/github-danny/transmissions/ # my local path

# run as application
./trans test_fs-rw
```

---

Copies

```sh
src/applications/test_fs-rw/data/output/input-01.md
```

to

```sh
src/applications/test_fs-rw/data/output/output-01.md
```

the tests compare the new file with :

```sh
src/applications/test_fs-rw/data/output/required-01.md
```

```sh
cd ~/github-danny/transmissions/ # my local path

# run as application
./trans test_fs-rw

# run as simples
node src/applications/test_fs-rw/simple.js

## Tests in tests/integration

# test as application
npm test -- --filter="fs-rw test"

# test as simples
npm test -- --filter="fs-rw simple test"
```

---

```sh
cd ~/github-danny/transmissions/
./trans test_restructure -P ./src/applications/test_restructure/input/input-01.json
```

---

./trans claude-json-converter -P ./conversations.json

```turtle
:s40 a :Restructure ;
    trm:configKey :walkPrep .

...

t:walkPrep a trm:ReMap ;
    trm:rename (t:pp1 t:pp2) . # consider using blank nodes
    t:pp1   trm:pre     "content" ;
            trm:post    "template"  .
    t:pp2   trm:pre     "entryContentMeta.sourceDir" ;
            trm:post    "sourceDir" .
```

================
File: src/applications/test_fs-rw/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .


trn:inputFile a trn:ConfigSet ; ;
    trn:key trn:input ;
    trn:sourceFile  "input/input-01.md" .

trn:outputFile a trn:ConfigSet ; ;
    trn:key trn:output ;
    trn:destinationFile "output/output-01.md" .

 # http://purl.org/stuff/transmissions/sourceFile

================
File: src/applications/test_fs-rw/simple.js
================
import FileReader from '../../processors/fs/FileReader.js'
import FileWriter from '../../processors/fs/FileWriter.js'

const config = {
    "simples": "true",
    "sourceFile": "input/input-01.md",
    "destinationFile": "output/output-01.md"
}

var message = { "dataDir": "src/applications/test_fs-rw/data" }

const read = new FileReader(config)

message = await read.process(message)

const write = new FileWriter(config)

message = await write.process(message)

================
File: src/applications/test_fs-rw/test-config.json
================
{
    "transmissions": [
        {
            "name": "test_fs-rw",
            "message": {
                "content": "Hello World"
            },
            "requiredFiles": [
                "output-01.md"
            ]
        }
    ]
}

================
File: src/applications/test_fs-rw/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:fsrw a trn:Transmission ;
trn:pipe (:SM :read :write ) .

:read a :FileReader ;
     trn:settings :input .

:write a :FileWriter ;
     trn:settings :output .

================
File: src/applications/test_http-server/data/input/index.html
================
<!DOCTYPE html>
<html>

<head>
    <title>HTTP Server Test</title>
    <style>
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }

        .online {
            background: #d4edda;
        }

        .offline {
            background: #f8d7da;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
    </style>
</head>

<body>
    <h1>HTTP Server Test Interface</h1>

    <div id="status" class="status"></div>

    <div class="metrics">
        <div>
            <h3>Server Metrics</h3>
            <div id="metrics"></div>
        </div>
        <div>
            <h3>Message Values</h3>
            <input type="text" id="key" placeholder="Key">
            <input type="text" id="value" placeholder="Value">
            <button onclick="addValue()">Add Value</button>
            <div id="currentValues"></div>
        </div>
    </div>

    <button onclick="shutdownServer()"
        style="background: #dc3545; color: white; padding: 10px; border: none; border-radius: 4px;">
        Shutdown Server
    </button>

    <script>
        let messageValues = {};
        let metrics = {
            startTime: Date.now(),
            requests: 0
        };

        function updateStatus(online) {
            const status = document.getElementById('status');
            status.textContent = online ? 'Server Online' : 'Server Offline';
            status.className = `status ${online ? 'online' : 'offline'}`;
        }

        function updateMetrics() {
            metrics.uptime = Math.floor((Date.now() - metrics.startTime) / 1000);
            metrics.requests++;

            document.getElementById('metrics').innerHTML = Object.entries(metrics)
                .map(([k, v]) => `<div>${k}: ${v}</div>`)
                .join('');
        }

        function addValue() {
            const key = document.getElementById('key').value;
            const value = document.getElementById('value').value;
            if (key && value) {
                messageValues[key] = value;
                updateValues();
            }
        }

        function updateValues() {
            document.getElementById('currentValues').innerHTML =
                Object.entries(messageValues)
                    .map(([k, v]) => `<div>${k}: ${v}</div>`)
                    .join('');
        }

        async function shutdownServer() {
            try {
                const response = await fetch('/shutdown', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(messageValues)
                });
                updateStatus(false);
            } catch (error) {
                console.error('Shutdown error:', error);
            }
        }

        // Initialize
        updateStatus(true);
        setInterval(updateMetrics, 1000);
    </script>
</body>

</html>

================
File: src/applications/test_http-server/data/input/metrics.js
================
class MetricsUI {
    constructor() {
        this.ws = null;
        this.token = null;
        this.setupWebSocket();
        this.setupAuth();
    }

    setupWebSocket() {
        this.ws = new WebSocket(`ws://${window.location.host}/metrics`);
        this.ws.onmessage = (event) => {
            const metrics = JSON.parse(event.data);
            this.updateMetricsDisplay(metrics);
        };
    }

    async setupAuth() {
        const response = await fetch('/admin/token');
        const { token } = await response.json();
        this.token = token;
    }

    updateMetricsDisplay(metrics) {
        const display = document.getElementById('metrics');
        display.innerHTML = `
            <div>Uptime: ${Math.floor(metrics.uptime)}s</div>
            <div>Connections: ${metrics.connections}</div>
            <div>Requests: ${metrics.requests}</div>
            <div>Memory Used: ${Math.floor(metrics.memory.used / 1024 / 1024)}MB</div>
            <div>CPU Load: ${metrics.cpu.load[0].toFixed(2)}</div>
        `;
    }

    async shutdown() {
        try {
            await fetch('/admin/shutdown', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.token}`
                }
            });
        } catch (error) {
            console.error('Shutdown failed:', error);
        }
    }
}

export default new MetricsUI();

================
File: src/applications/test_http-server/about.md
================
# App Template

## Runner

```sh
cd ~/github-danny/transmissions # my local path
./trans test_http-server

---
runs at :

http://localhost:4000/transmissions/test/

```

curl -X POST http://localhost:4000/shutdown

node src/applications/test_http-server/test-shutdown.js

npm test -- tests/unit/http-server_ShutdownService.spec.js

```

## Description

Test application for HttpServer processor that:

- Serves static files from data/input directory
- Listens on port 4000
- Shuts down on POST to /shutdown endpoint
- Base path: /transmissions/test/
```

================
File: src/applications/test_http-server/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:setDemo a trn:ConfigSet ;
    rdfs:label "HTTP Server configuration" ;
    trn:settings trn:httpServer ;
    trn:port 4000 ;
    trn:basePath "/transmissions/test/" ;
    trn:staticPath "src/applications/test_http-server/data/input" .

================
File: src/applications/test_http-server/shutdown-client-auth.js
================
async function shutdownServer(baseUrl, username, password) {
    const credentials = Buffer.from(`${username}:${password}`).toString('base64');

    try {
        const response = await fetch(`${baseUrl}/admin/shutdown`, {
            method: 'POST',
            headers: {
                'Authorization': `Basic ${credentials}`
            }
        });

        if (!response.ok) {
            throw new Error(`Shutdown failed: ${response.statusText}`);
        }

        return await response.text();
    } catch (error) {
        console.error('Shutdown error:', error);
        throw error;
    }
}


try {
    const baseUrl = 'http://localhost:4000';
    const response = await fetch(`${baseUrl}/admin/credentials`);
    const { username, password } = await response.json();
    await shutdownServer(baseUrl, username, password);
} catch (error) {
    console.error('Error:', error);
}

================
File: src/applications/test_http-server/test-shutdown.js
================
import fetch from 'node-fetch';

async function testShutdown() {
    try {
        const response = await fetch('http://localhost:4000/shutdown', {
            method: 'POST'
        });
        console.log('Server response:', await response.text());
    } catch (error) {
        console.error('Error:', error.message);
    }
}

testShutdown();

================
File: src/applications/test_http-server/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

:mini a trn:Transmission ;
    trn:pipe (:server :SM) .

:server a :HttpServer ;
    trn:settings :httpServer .

:SM a :ShowMessage .

================
File: src/applications/test_multi-pipe/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
# @prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

trn:dirWalkerPosts a trn:ConfigSet ;
    trn:key trn:files .

trn:postTemplateMap a trn:ReMap ;
   trn:rename (trn:rn1) . # consider using blank nodes
     trn:rn1    trn:pre     "content" ;
            trn:post    "template"  .

trn:postSaver a trn:ReMap ;
    trn:rename (trn:rn2) .
    trn:rn2   trn:pre     "targetFilename" ;
            trn:post    "filename" .

================
File: src/applications/test_multi-pipe/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # TODO make plural
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances - TODO make one @services s:

:test_multi-pipes a :Transmission ;
   trn:contains :pipeA, :pipeB, :pipeC .

:pipeA a trn:Transmission ;
trn:pipe (:s1 :s2 :s3 ) .

:pipeB  a trn:Transmission ;
 trn:pipe (:s3 :s104 :s105) .

:pipeC a trn:Transmission ;
trn:pipe (:s3 :s204 :s205) .

# :postcraft a trn:Transmission ;

:s1 a :NOP .
:s2 a :NOP .
:s3 a :NOP .

:s104 a :NOP .
:s105 a :NOP .

:s204 a :NOP .
:s205 a :ShowTransmission .

================
File: src/applications/test_nop/about.md
================
# nop

## Description

minimal for comparing with simple runner

---

- Goal : a tool to recursively read local filesystem directories, checking for files with the `.md` extension to identify collections of such
- Goal : documentation of the app creation process
- Implementation : a #Transmissions application
- SoftGoal : reusability
- _non-goal_ - efficiency

================
File: src/applications/test_nop/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> . # for custom terms & instances

================
File: src/applications/test_nop/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> . # for custom terms & instances

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:nope a trn:Transmission ;
    trn:pipe (:N :SC :SM) .

================
File: src/applications/test_ping/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:pingConfig a trn:ConfigSet ;
    trn:interval 2000 ;         # Ping every 2 seconds
    trn:count 5 ;               # Stop after 5 pings
    trn:payload "HEARTBEAT" ;   # Custom payload
    trn:killSignal "STOP" ;     # Kill signal value
    trn:retryAttempts 3 ;       # Number of retry attempts on error
    trn:retryDelay 1000 .      # Delay between retries in ms

trn:killConfig a trn:ConfigSet ;
    trn:setValue (trn:sv0) ;
    trn:sv0 trn:key "kill" ;
          trn:value "STOP" .

================
File: src/applications/test_ping/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

:test_ping a trn:Transmission ;
    trn:pipe (:p10 :p20 :p30) .

:p10 a :Ping ;
    trn:settings :pingConfig .

:p20 a :ShowMessage .

:p30 a :SetMessage ;
    trn:settings :killConfig .

================
File: src/applications/test_restructure/data/input/input-01.json
================
{
    "item": {
        "uuid": "convo1",
        "name": "Name of this convo",
        "created_at": "2024-10-29T17:57:50.229169Z",
        "chat_messages": [
            {
                "uuid": "id1",
                "text": "Text one"
            },
            {
                "uuid": "id2",
                "text": "Text two"
            }
        ]
    }
}

================
File: src/applications/test_restructure/data/output/required-01.json
================
{
    "channel": [
        {
            "uuid": "id1",
            "text": "Text one"
        },
        {
            "uuid": "id2",
            "text": "Text two"
        }
    ],
    "filename": "convo1",
    "title": "Name of this convo"
}

================
File: src/applications/test_restructure/about.md
================
# Application : test_restructure

Run with :

```sh
cd ~/github-danny/transmissions/ # local path of repo
./trans test_restructure
```

#:todo make this into something like processor signature
#:todo make Turtle version

## Description

Reads :

```sh
src/applications/test_restructure/data/output/input-01.json
```

as a message, restructures it according to config, then writes the result to :

```sh
src/applications/test_restructure/data/output/output-01.json
```

the tests compare the new file with :

```sh
src/applications/test_restructure/data/output/required-01.json
```

```sh
cd ~/github-danny/transmissions/ # my local path

# run as application
./trans test_restructure

# run as simples
node src/applications/test_restructure/simple.js

## Tests in tests/integration

# test as application
npm test -- --filter="restructure test"

# test as simples
npm test -- --filter="restructure_simple test"
```

---

```sh
cd ~/github-danny/transmissions/
./trans test_restructure -P ./src/applications/test_restructure/input/input-01.json
```

---

./trans claude-json-converter -P ./conversations.json

```turtle
:s40 a :Restructure ;
    trm:configKey :walkPrep .

...

t:walkPrep a trm:ReMap ;
    trm:rename (t:pp1 t:pp2) . # consider using blank nodes
    t:pp1   trm:pre     "content" ;
            trm:post    "template"  .
    t:pp2   trm:pre     "entryContentMeta.sourceDir" ;
            trm:post    "sourceDir" .
```

================
File: src/applications/test_restructure/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

trn:jsonFileIn a trn:ConfigSet ; ;
    trn:key trn:reader ;
    trn:sourceFile "input/input-01.json" ;
    trn:mediaType "application/json" .

trn:retree a trn:ConfigSet ;
    trn:rename (trn:pp1 trn:pp2 trn:pp3) . # consider using blank nodes
    trn:pp1   trn:pre     "content.item.chat_messages" ;
            trn:post    "content.channel"  .
    trn:pp2   trn:pre     "content.item.uuid" ;
            trn:post    "content.filename"  .
    trn:pp3   trn:pre     "content.item.name" ;
            trn:post    "content.title"  .


trn:jsonFileOut a trn:ConfigSet ; ;
    trn:key trn:writer ;
    trn:destinationFile "output/output-01.json" .

================
File: src/applications/test_restructure/simple.js
================
import FileReader from '../../processors/fs/FileReader.js'
import Restructure from '../../processors/json/Restructure.js'
import FileWriter from '../../processors/fs/FileWriter.js'

const config = {
    "simples": "true",
    "sourceFile": "input/input-01.json",
    "destinationFile": "output/output-01.json",
    "mediaType": "application/json",
    "rename": [{
        "pre": "content.item.chat_messages",
        "post": "content.channel"
    }, {
        "pre": "content.item.uuid",
        "post": "content.filename"
    }, {
        "pre": "content.item.name",
        "post": "content.title"
    }]
}

var message = { "dataDir": "src/applications/test_restructure/data" }

const read = new FileReader(config)
message = await read.process(message)

const restructure = new Restructure(config)
message = await restructure.process(message)

const write = new FileWriter(config)
await write.process(message)

================
File: src/applications/test_restructure/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SC a :ShowConfig . # verbose report, continues pipe
:SM a :ShowMessage . # verbose report, continues pipe
:SM1 a :ShowMessage . # verbose report, continues pipe
:SM2 a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:cjc a trn:Transmission ;


trn:pipe (:read :retree1 :SM :writer) .

:read a :FileReader ;
     trn:settings :reader .

:retree1 a :Restructure ;
     trn:settings :retree .

:writer a :FileWriter ;
     trn:settings :writer .

================
File: src/applications/test_two-transmissions/config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix trn: <http://purl.org/stuff/transmissions/> .

#trn:copyOneToSingleEmpty a trn:ConfigSet ;
 #   trn:key trn:copyOneToSingleEmpty ;
  #  trn:source "data/start/one.txt" ;
   # trn:destination "data/single-empty/one.txt" .

trn:copyOneToSingleEmpty a trn:ConfigSet ;
    trn:key trn:copyOneToSingleEmpty ;
    trn:source "data/start/one.txt" ;
    trn:destination "data/single-empty/one.txt" .

trn:copySingleEmptyToSingleFull a trn:ConfigSet ;
    trn:key trn:copySingleEmptyToSingleFull ;
    trn:source "data/single-empty/one.txt" ;
    trn:destination "data/single-full/one.txt" .

trn:removeSingleEmpty a trn:ConfigSet ;
    trn:key trn:removeSingleEmpty ;
    trn:target "data/single-empty/one.txt" .

trn:copyStartToSeveralEmpty a trn:ConfigSet ;
    trn:key trn:copyStartToSeveralEmpty ;
    trn:source "data/start" ;
    trn:destination "data/several-empty" .

trn:copySeveralEmptyToSeveralFull a trn:ConfigSet ;
    trn:key trn:copySeveralEmptyToSeveralFull ;
    trn:source "data/several-empty" ;
    trn:destination "data/several-full" .

trn:removeSeveralEmpty a trn:ConfigSet ;
    trn:key trn:removeSeveralEmpty ;
    trn:target "data/several-empty" .

================
File: src/applications/test_two-transmissions/transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trn: <http://purl.org/stuff/transmissions/> .
@prefix : <http://purl.org/stuff/transmissions/> .

#############################################################
# insert into pipe for debugging
:DE a :DeadEnd . # ends the current pipe quietly
:H  a :Halt . # kills everything
:SM a :ShowMessage . # verbose report, continues pipe
:N  a :NOP . # no operation (except for showing stage in pipe)
:UF a :Unfork . # collapses all pipes but one
#############################################################

:transmission_one a trn:Transmission ;
    trn:pipe (:a1 :a2) .

:a1 a :NOP .

:a2 a :NOP .

:transmission_two a trn:Transmission ;
    trn:pipe (:b1 :b2 :b3) .

:b1 a :NOP .

:b2 a :NOP .

:b3 a :NOP .

================
File: src/engine/ApplicationManager.js
================
import rdf from 'rdf-ext'
import ns from '../utils/ns.js'
import path from 'path'
import fs from 'fs/promises'
import _ from 'lodash'
import logger from '../utils/Logger.js'
import MockApplicationManager from '../utils/MockApplicationManager.js'
import TransmissionBuilder from './TransmissionBuilder.js'
import ModuleLoaderFactory from './ModuleLoaderFactory.js'
import Application from '../model/Application.js'

class ApplicationManager {
    constructor() {
        this.app = new Application()
        this.moduleLoader = null
        this.dataset = rdf.dataset()
    }

    async initialize(appName, appPath, subtask, target, flags) {
        logger.debug(`ApplicationManager.initialize, appName=${appName}, appPath=${appPath}, subtask=${subtask}, target=${target}`)

        if (flags && flags.test) {
            const mock = new MockApplicationManager()
            await mock.initialize(appName, appPath, subtask, target, flags)
            return mock
        }

        await this.app.initialize(appName, appPath, subtask, target)
        this.moduleLoader = ModuleLoaderFactory.createApplicationLoader(this.app.getModulePath())

        const appNode = rdf.namedNode(`http://purl.org/stuff/transmissions/${appName}`)
        const sessionNode = rdf.blankNode()

        this.dataset.add(rdf.quad(
            appNode,
            ns.rdf.type,
            ns.trn.Application
        ))

        this.dataset.add(rdf.quad(
            sessionNode,
            ns.rdf.type,
            ns.trn.ApplicationSession
        ))

        this.dataset.add(rdf.quad(
            sessionNode,
            ns.trn.application,
            appNode
        ))


        this.app.dataset = this.dataset
        this.app.sessionNode = sessionNode

        return this
    }


    async start(message = {}) {
        logger.debug(`ApplicationManager.start, transmissionsFile=${this.app.getTransmissionsPath()}, configFile=${this.app.getConfigPath()}, subtask=${this.app.subtask}`)

        const transmissions = await TransmissionBuilder.build(
            this.app.getTransmissionsPath(),
            this.app.getConfigPath(),
            this.moduleLoader,
            this.app
        )


        const contextMessage = this.app.toMessage()


        _.merge(message, contextMessage)

        logger.debug('Message with merged context:', message)

        for (const transmission of transmissions) {
            if (!this.app.subtask || this.app.subtask === transmission.label) {
                await transmission.process(message)
            }
        }

        message.app = this.app
        message.sessionNode = this.app.sessionNode

        for (const transmission of transmissions) {
            if (!this.app.subtask || this.app.subtask === transmission.label) {
                await transmission.process(message)
            }
        }

        return { success: true }
    }

    async listApplications() {
        try {
            const entries = await fs.readdir(this.app.appsDir, { withFileTypes: true })
            const subdirChecks = entries
                .filter(dirent => dirent.isDirectory())
                .map(async (dirent) => {
                    const subdirPath = path.join(this.app.appsDir, dirent.name)
                    const files = await fs.readdir(subdirPath)
                    return files.includes('about.md') ? dirent.name : null
                })

            const validApps = (await Promise.all(subdirChecks)).filter(Boolean)
            return validApps
        } catch (err) {
            logger.error('Error listing applications:', err)
            return []
        }
    }
}

export default ApplicationManager

================
File: src/engine/ModuleLoader.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import logger from '../utils/Logger.js'

class ModuleLoader {
    constructor(classpath) {
        this.classpath = classpath

        this.moduleCache = new Map()
        logger.debug(`ModuleLoader initialized with paths :\n${this.classpath}`)
    }

    async loadModule(moduleName) {

        logger.debug(`\n\nModuleLoader.loadModule, moduleName = ${moduleName}`)
        logger.debug(`ModuleLoader.loadModule looking for module in classpath ${this.classpath} `)


        if (this.moduleCache.has(moduleName)) {
            logger.debug(`Retrieved ${moduleName} from cache`)
            return this.moduleCache.get(moduleName)
        }


        for (const basePath of this.classpath) {
            try {
                const fullPath = path.join(basePath, `${moduleName}.js`)
                logger.debug(`Trying path: ${fullPath}`)

                const module = await import(fullPath)
                this.moduleCache.set(moduleName, module)
                logger.debug(`Successfully loaded ${moduleName} from ${fullPath}`)
                return module
            } catch (error) {
                logger.debug(`Failed to load from ${basePath}: ${error.message}`)
                continue
            }
        }

        throw new Error(`Module ${moduleName} not found in paths: ${this.classpath.join(', ')}`)
    }

    clearCache() {
        this.moduleCache.clear()
    }

    addPath(newPath) {
        if (typeof newPath !== 'string') {
            throw new TypeError('Path must be a string')
        }
        this.classpath.push(path.normalize(newPath))
    }
}
export default ModuleLoader

================
File: src/engine/ModuleLoaderFactory.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import logger from '../utils/Logger.js'
import ModuleLoader from './ModuleLoader.js'

class ModuleLoaderFactory {
    static instance = null;

    static createModuleLoader(classpath) {
        const __filename = fileURLToPath(import.meta.url)
        const __dirname = path.dirname(__filename)











        if (!ModuleLoaderFactory.instance) {
            ModuleLoaderFactory.instance = new ModuleLoader(classpath)
        }

        return ModuleLoaderFactory.instance
    }

    static createApplicationLoader(appPath) {
        logger.debug(`\nModuleLoaderFactory.createApplicationLoader called with ${appPath}`)
        if (!appPath) {
            throw new Error('Application path is required')
        }
        const __filename = fileURLToPath(import.meta.url)
        const __dirname = path.dirname(__filename)

        const normalizedPath = path.resolve(process.cwd(), appPath)

        const appProcessorsPath = normalizedPath
        const corePath = path.resolve(__dirname, '../processors')

        logger.debug(`ModuleLoaderFactory creating loader with paths:
      App: ${appProcessorsPath}
      Core: ${corePath}`)

        return this.createModuleLoader([appProcessorsPath, corePath])
    }

    static clearInstance() {
        ModuleLoaderFactory.instance = null
    }
}
export default ModuleLoaderFactory

================
File: src/engine/Procurer.js
================
class Procurer {
    constructor() {
        this.moduleLoader = ModuleLoaderFactory.createModuleLoader()
    }

    async loadResources(application, args) {
        const config = await this.loadConfig(args.configPath)
        const manifest = await this.loadManifest(args.target)
        application.config = config
        application.manifest = manifest
    }
}

export default Procurer

================
File: src/engine/TransmissionBuilder.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import { fromFile, toFile } from 'rdf-utils-fs'

import ns from '../utils/ns.js'
import GrapoiHelpers from '../utils/GrapoiHelpers.js'
import logger from '../utils/Logger.js'

import AbstractProcessorFactory from "../processors/base/AbstractProcessorFactory.js"
import Transmission from '../model/Transmission.js'


class TransmissionBuilder {
  constructor(moduleLoader, app) {
    this.moduleLoader = moduleLoader
    this.app = app
  }

  static async build(transmissionConfigFile, processorsConfigFile, moduleLoader, app) {
    const builder = new TransmissionBuilder(moduleLoader, app)
    const transmissionConfig = await TransmissionBuilder.readDataset(transmissionConfigFile)
    const processorsConfig = await TransmissionBuilder.readDataset(processorsConfigFile)


    for (const quad of app.dataset) {
      transmissionConfig.add(quad)
      processorsConfig.add(quad)
    }

    return builder.buildTransmissions(transmissionConfig, processorsConfig)
  }

  async buildTransmissions(transmissionConfig, processorsConfig) {
    const poi = grapoi({ dataset: transmissionConfig })
    const transmissions = []

    for (const q of poi.out(ns.rdf.type).quads()) {
      if (q.object.equals(ns.trn.Transmission)) {
        const transmissionID = q.subject

        transmissions.push(await this.constructTransmission(transmissionConfig, transmissionID, processorsConfig))
      }
    }
    return transmissions
  }

  async constructTransmission(transmissionConfig, transmissionID, processorsConfig) {
    const transmission = new Transmission()
    transmission.id = transmissionID.value
    transmission.app = this.app

    processorsConfig.whiteboard = {}

    transmission.label = ''

    const transPoi = grapoi({ dataset: transmissionConfig, term: transmissionID })

    // TODO has grapoi got a first/single property method?
    for (const quad of transPoi.out(ns.rdfs.label).quads()) {
      transmission.label = quad.object.value
    }
    logger.log('\n+ ***** Construct Transmission : ' + transmission.label + ' <' + transmission.id + '>')

    let previousName = "nothing"

    // grapoi probably has a built-in for all this
    const pipenodes = GrapoiHelpers.listToArray(transmissionConfig, transmissionID, ns.trn.pipe)
    await this.createNodes(transmission, pipenodes, transmissionConfig, processorsConfig) // was await, bad Claude
    //    this.createNodes(transmission, pipenodes, transmissionConfig, processorsConfig); // was await, bad Claude
    this.connectNodes(transmission, pipenodes)
    return transmission
  }

  async createNodes(transmission, pipenodes, transmissionConfig, processorsConfig) {
    for (let i = 0; i < pipenodes.length; i++) {
      let node = pipenodes[i]
      let processorName = node.value
      // if (transmissionConfig) {
      // logger.log(`TransmisionBuilder.createNodes, transmissionConfig = ${transmissionConfig}`)
      // }
      if (!transmission.get(processorName)) {
        let np = rdf.grapoi({ dataset: transmissionConfig, term: node })

        let processorType = np.out(ns.rdf.type).term
        let processorConfig = np.out(ns.trn.settings).term

        try {
          let name = ns.getShortname(processorName)
          let type = ns.getShortname(processorType.value)

          logger.log("| Create processor :" + name + " of type :" + type)
          let processor = await this.createProcessor(processorType, processorsConfig)

          processor.id = processorName
          processor.type = processorType
          processor.transmissionNode = node
          processor.transmission = transmission
          processor.settingsNode = processorConfig

          transmission.register(processorName, processor)

        } catch (err) {
          logger.error('-> Can\'t resolve ' + processorName + ' (check transmission.ttl for typos!)\n')
          logger.error(err)
        }
      }
    }
  }

  async connectNodes(transmission, pipenodes) {
    for (let i = 0; i < pipenodes.length - 1; i++) {
      let leftNode = pipenodes[i]
      let leftProcessorName = leftNode.value
      let rightNode = pipenodes[i + 1]
      let rightProcessorName = rightNode.value
      logger.log("  > Connect #" + i + " [" + ns.getShortname(leftProcessorName) + "] => [" + ns.getShortname(rightProcessorName) + "]")
      transmission.connect(leftProcessorName, rightProcessorName)
    }
  }

  async createProcessor(type, config) {
    logger.debug(`\n\nTransmissionBuilder.createProcessor, config = ${config}`)

    const coreProcessor = AbstractProcessorFactory.createProcessor(type, config)
    if (coreProcessor) {
      return coreProcessor
    }

    logger.debug(`TransmissionBuilder, core processor not found for ${type.value}. Trying remote module loader...`)

    try {
      const shortName = type.value.split('/').pop()
      logger.debug(`TransmissionBuilder, loading module: ${shortName}`)
      logger.log(this.moduleLoader)
      const ProcessorClass = await this.moduleLoader.loadModule(shortName)

      logger.debug(`Module loaded successfully: ${shortName}`)
      return new ProcessorClass.default(config)
    } catch (error) {
      logger.error(`TransmissionBuilder.createProcessor, failed to load ${type.value} : ${error.message}`)
      process.exit(1)
    }
  }


  static async readDataset(filename) {
    const stream = fromFile(filename)
    const dataset = await rdf.dataset().import(stream)
    return dataset
  }

  static async writeDataset(dataset, filename) {
    await toFile(dataset.toStream(), filename)
  }


}
export default TransmissionBuilder

================
File: src/engine/WorkerPool.js
================
import { Worker } from 'worker_threads'

class WorkerPool {
    constructor(module, size) {
        this.workers = [];
        this.queue = [];
        for (let i = 0; i < size; i++) {
            const worker = new Worker(module);
            worker.on('message', () => {

                this.markWorkerIdle(worker);
            });
            this.workers.push({ worker, busy: false });
        }
    }

    enqueueMessage(message) {
        this.queue.push(message);
        this.dispatch();
    }

    dispatch() {
        const idleWorkerWrapper = this.workers.find(wrapper => !wrapper.busy);
        if (idleWorkerWrapper && this.queue.length) {
            const message = this.queue.shift();
            idleWorkerWrapper.busy = true;
            idleWorkerWrapper.worker.postMessage(message);
        }
    }

    markWorkerIdle(workerWrapper) {
        workerWrapper.busy = false;
        this.dispatch();
    }
}

================
File: src/model/Application.js
================
import path from 'path'
import { fromFile } from 'rdf-utils-fs'
import rdf from 'rdf-ext'
import logger from '../utils/Logger.js'

class Application {
    constructor(options = {}) {

        this.appsDir = 'src/applications'
        this.transmissionFilename = 'transmissions.ttl'
        this.configFilename = 'config.ttl'
        this.moduleSubDir = 'processors'
        this.dataSubDir = 'data'
        this.manifestFilename = 'manifest.ttl'


        this.appName = options.appName || null
        this.appPath = options.appPath || null
        this.subtask = options.subtask || null


        this.rootDir = options.rootDir || null
        this.dataDir = options.dataDir || null
        this.targetPath = options.targetPath || null


        this.dataset = options.dataset || null
    }

    async initialize(appName, appPath, subtask, target, flags = {}) {
        this.appName = appName
        this.appPath = this.resolveApplicationPath(appPath)
        this.subtask = subtask
        this.targetPath = target

        if (target) {
            this.manifestFilename = path.join(target, this.manifestFilename)
            await this.loadManifest()
        }

        return this
    }

    resolveApplicationPath(appName) {
        if (!appName) {
            throw new Error('Application name is required')
        }

        if (appName.startsWith('/')) {
            return appName
        }

        if (appName.startsWith('..')) {
            return path.resolve(process.cwd(), appName)
        }

        return path.join(process.cwd(), this.appsDir, appName)
    }

    async loadManifest() {
        try {
            logger.debug(`Application.loadManifest, loading: ${this.manifestFilename}`)
            const stream = fromFile(this.manifestFilename)
            this.dataset = await rdf.dataset().import(stream)
            return this.dataset
        } catch (err) {
            logger.debug(`Application.loadManifest, ${this.manifestFilename} not found, creating empty dataset`)
            this.dataset = rdf.dataset()
            return this.dataset
        }
    }

    getTransmissionsPath() {
        return path.join(this.appPath, this.transmissionFilename)
    }

    getConfigPath() {
        return path.join(this.appPath, this.configFilename)
    }

    getModulePath() {
        return path.join(this.appPath, this.moduleSubDir)
    }

    resolveDataDir() {
        if (!this.dataDir) {
            this.dataDir = path.join(this.appPath, this.dataSubDir)
        }
        return this.dataDir
    }

    toMessage() {
        return {
            appName: this.appName,
            appPath: this.appPath,
            subtask: this.subtask,
            rootDir: this.rootDir || this.appPath,
            dataDir: this.resolveDataDir(),
            targetPath: this.targetPath,
            dataset: this.dataset
        }
    }
}

export default Application

================
File: src/model/Connector.js
================
import ns from '../utils/ns.js'
import { EventEmitter } from 'events'
import logger from '../utils/Logger.js'
import footpath from '../utils/footpath.js'

class Connector extends EventEmitter {


    constructor(fromName, toName) {
        super()
        this.fromName = fromName
        this.toName = toName
    }

    connect(processors) {
        logger.trace(`Connector.connect this.fromName = ${this.fromName} this.toName =  ${this.toName}`)
        let fromProcessor = processors[this.fromName]
        let toProcessor = processors[this.toName]

        if (!fromProcessor) {
            throw new Error(`\nMissing processor : ${this.fromName}, going to ${this.toName} \n(check for typos in transmissions.ttl)\n`)
        }



        fromProcessor.on('message', async (message) => {
            var tags = fromProcessor.message?.tags ? ` [${fromProcessor.message.tags}] ` : ''
            toProcessor.tags = tags
            logger.log(`|-> ${tags}-> ${ns.shortName(toProcessor.id)} a ${toProcessor.constructor.name}`)
            await toProcessor.receive(message)
        })

    }


}

export default Connector

================
File: src/model/Transmission.js
================
import logger from '../utils/Logger.js'
import Connector from './Connector.js'
import ns from '../utils/ns.js'

class Transmission {
  constructor() {
    this.processors = {}
    this.connectors = []

  }

  register(processorName, instance) {
    this.processors[processorName] = instance

  }

  get(processorName) {
    return this.processors[processorName]
  }

  connect(fromProcessorName, toProcessorName) {
    logger.trace(`Transmission.connect from ${fromProcessorName} to ${fromProcessorName}`)
    let connector = new Connector(fromProcessorName, toProcessorName)
    this.connectors.push(connector)
    connector.connect(this.processors)
  }

  async process(message) {
    logger.log(`\n+ Run Transmission : ${this.label} <${this.id}>`)
    const processorName = this.connectors[0]?.fromName || Object.keys(this.processors)[0]
    let processor = this.get(processorName)
    if (processor) {
      logger.log(`|-> ${ns.shortName(processorName)} a ${processor.constructor.name}`)
      await processor.receive(message)
    } else {
      logger.error("No valid processor found to execute")
    }
  }






  toString() {
    let description = 'Transmission Structure:\n'


    description += 'Processors:\n'
    Object.keys(this.processors).forEach((processorName) => {


      description += `  - ${ns.shortName(processorName)} a ${this.processors[processorName]} \n`

    })









    description += 'Connectors:\n'
    this.connectors.forEach((connector, index) => {
      description += `  - Connector ${index + 1}: ${ns.shortName(connector.fromName)} -> ${ns.shortName(connector.toName)} \n`
    })

    return description
  }
}

export default Transmission

================
File: src/processors/base/AbstractProcessorFactory.js
================
import logger from '../../utils/Logger.js'


import SystemProcessorsFactory from '../system/SystemProcessorsFactory.js'
import TestProcessorsFactory from '../test/TestProcessorsFactory.js'
import FsProcessorsFactory from '../fs/FsProcessorsFactory.js'
import MarkupProcessorsFactory from '../markup/MarkupProcessorsFactory.js'
import UtilProcessorsFactory from '../util/UtilProcessorsFactory.js'
import TextProcessorsFactory from '../text/TextProcessorsFactory.js'
import ProtocolsProcessorsFactory from '../protocols/ProtocolsProcessorsFactory.js'
import RDFProcessorsFactory from '../rdf/RDFProcessorsFactory.js'
import PostcraftProcessorsFactory from '../postcraft/PostcraftProcessorsFactory.js'
import FlowProcessorsFactory from '../flow/FlowProcessorsFactory.js'
import StagingProcessorsFactory from '../staging/StagingProcessorsFactory.js'
import GitHubProcessorsFactory from '../github/GitHubProcessorsFactory.js'
import JSONProcessorsFactory from '../json/JSONProcessorsFactory.js'
import TerrapackProcessorsFactory from '../terrapack/TerrapackProcessorsFactory.js'


import UnsafeProcessorsFactory from '../unsafe/UnsafeProcessorsFactory.js'
import HttpProcessorsFactory from '../http/HttpProcessorsFactory.js'
import McpProcessorsFactory from '../mcp/McpProcessorsFactory.js'
import XmppProcessorsFactory from '../xmpp/XmppProcessorsFactory.js'


import ExampleProcessorsFactory from '../example-group/ExampleProcessorsFactory.js'


import SPARQLProcessorsFactory from '../sparql/SPARQLProcessorsFactory.js'

class AbstractProcessorFactory {




    static createProcessor(type, config) {
        logger.trace(`\nAbstractProcessorFactory.createProcessor : type.value = ${type.value}`)


        var processor = ExampleProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = UnsafeProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = HttpProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = McpProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = XmppProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = TestProcessorsFactory.createProcessor(type, config)
        if (processor) return processor
        var processor = UtilProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = FsProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = MarkupProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = TextProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = ProtocolsProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = RDFProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = PostcraftProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = SystemProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = FlowProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = GitHubProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = StagingProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        processor = JSONProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = TerrapackProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

        var processor = SPARQLProcessorsFactory.createProcessor(type, config)
        if (processor) return processor

    }
}

export default AbstractProcessorFactory

================
File: src/processors/base/Processor.js
================
import { EventEmitter } from 'events'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import ProcessorSettings from './ProcessorSettings.js'

class Processor extends EventEmitter {
    constructor(config) {
        super()
        this.config = config
        this.settee = new ProcessorSettings(this.config)

        this.messageQueue = []
        this.processing = false
        this.outputs = []

        this.app = null
    }

    getAppPath(relativePath) {
        if (!this.app?.rootDir) {
            throw new Error('Application context not available')
        }
        return path.join(this.app.rootDir, relativePath)
    }

    getValues(property, fallback) {
        logger.debug(`Processor.getValues looking for ${property}`)

        const shortName = ns.getShortname(property)
        if (this.message && this.message[shortName]) {
            return [this.message[shortName]]
        }

        this.settee.settingsNode = this.settingsNode
        const values = this.settee.getValues(property, fallback)
        logger.debug(`Processor.getValues values = ${values}`)
        return values
    }

    getProperty(property, fallback = undefined) {

        logger.debug(`Processor.getProperty looking for ${property}`)
        const shortName = ns.getShortname(property)
        if (this.message && this.message[shortName]) {
            logger.debug(`Found in message: ${this.message[shortName]}`)
            return this.message[shortName]
        }
        logger.debug(`Processor.getProperty, property = ${property}`)


        this.settee.settingsNode = this.settingsNode
        const value = this.settee.getValue(property, fallback)
        logger.debug(`Processor.getProperty, value = ${value}`)
        return value
    }

    async preProcess(message) {
        this.app = message.app
        this.config.app = this.app

        if (message.onProcess) {
            message.onProcess(this, message)
        }

        this.previousLogLevel = logger.getLevel()








        const messageType = this.getProperty(ns.trn.messageType)
        if (messageType) {
            if (messageType.value) {
                message.messageType = messageType.value
            } else {
                message.messageType = messageType
            }
        }
        this.message = message
    }


    async process(message) {
        if (message.onProcess) {
            message.onProcess(this, message)
        }
        await this.emit('message', message)
    }



    async postProcess(message) {
        logger.setLogLevel(this.previousLogLevel)
        this.previousLogLevel = null
    }

    async receive(message) {
        await this.enqueue(message)
    }

    async enqueue(message) {
        this.messageQueue.push({ message })
        if (!this.processing) {
            this.executeQueue()
        }
    }

    async executeQueue() {
        this.processing = true
        while (this.messageQueue.length > 0) {
            let { message } = this.messageQueue.shift()
            message = structuredClone(message)
            this.addTag(message)

            await this.preProcess(message)
            await this.process(message)
            await this.postProcess(message)
        }
        this.processing = false
    }

    async process(message) {
        throw new Error('process method not implemented')
    }

    addTag(message) {
        const tag = this.getTag()
        if (!message.tags) {
            message.tags = tag
            return
        }
        message.tags = message.tags + '.' + tag
    }

    getTag() {
        return ns.shortName(this.id)
    }

    async emit(event, message) {
        await new Promise(resolve => {
            super.emit(event, message)
            resolve()
        })
        return message
    }

    getOutputs() {
        const results = this.outputs
        this.outputs = []
        return results
    }

    toString() {
        logger.reveal(this.settings)
        const settingsNodeValue = this.settingsNode ? this.settingsNode.value : 'none'
        return `
        *** Processor ${this.constructor.name}
                id = ${this.id}
                label = ${this.label}
                type = ${this.type}
                description = ${this.description}
                settingsNodeValue = ${settingsNodeValue}
                settings = ${this.settings}
       `
    }
}

export default Processor

================
File: src/processors/base/ProcessorSettings.js
================
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'

class ProcessorSettings {
    constructor(config) {
        this.config = config

    }

    getValues(property, fallback) {
        logger.debug(`\n\nProcessorSettings.getValues, property = ${property.value}`)

        if (!this.settingsNode || !this.config) {
            return fallback ? [fallback] : []
        }

        const dataset = this.config
        const ptr = grapoi({ dataset, term: this.settingsNode })


        logger.debug(`get all matches to ${this.settingsNode.value} ${property} ?value`)
        const values = ptr.out([property]).distinct()
        logger.debug(`Values found: ${values.terms.length}`)

        if (values.terms.length > 0) {
            const all = values.terms.map(term => term.value)
            logger.debug(`All values: ${all}`)
            return all
        }



        const settingsPtr = ptr.out([ns.trn.settings]).distinct()
        if (settingsPtr.term) {
            const refPtr = grapoi({ dataset, term: settingsPtr.term })
            const refValues = refPtr.out([property]).distinct()
            logger.debug(`RefValues found: ${refValues.terms.length}`)
            if (refValues.terms.length > 0) {
                return refValues.terms.map(term => term.value)
            }
        }

        return fallback ? [fallback] : []
    }

    getValue(property, fallback) {
        const values = this.getValues(property, fallback)
        logger.debug(`All values2: ${values}`)
        if (values.length == 0) {
            return undefined
        }
        return values.length == 1 ? values[0] : values
    }
}

export default ProcessorSettings

================
File: src/processors/example-group/ExampleProcessor.js
================
import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class ExampleProcessor extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {
        logger.debug(`\n\nExampleProcessor.process`)



        if (message.done) {
            return this.emit('message', message)

        }




        const me = await this.getProperty(ns.trn.me)
        logger.log(`\nI am ${me}`)

        message.common = await this.getProperty(ns.trn.common)
        message.something1 = await this.getProperty(ns.trn.something1)

        message.something2 = await this.getProperty(ns.trn.something2)

        var added = await this.getProperty(ns.trn.added, '')
        message.something1 = message.something1 + added

        message.notavalue = await this.getProperty(ns.trn.notavalue, 'fallback value')


        return this.emit('message', message)
    }
}
export default ExampleProcessor

================
File: src/processors/example-group/ExampleProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import ExampleProcessor from './ExampleProcessor.js'







class ExampleProcessorsFactory {

    static createProcessor(type, config) {

        if (type.equals(ns.trn.ExampleProcessor)) {
            return new ExampleProcessor(config)
        }









        return false
    }
}
export default ExampleProcessorsFactory

================
File: src/processors/flow/DeadEnd.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class DeadEnd extends Processor {

    async process(message) {
        logger.log('DeadEnd at [' + message.tags + '] ' + this.getTag())
    }

}
export default DeadEnd

================
File: src/processors/flow/FlowProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import ForEach from './ForEach.js'
import Ping from './Ping.js'
import NOP from '../flow/NOP.js'
import DeadEnd from '../flow/DeadEnd.js'
import Halt from '../flow/Halt.js'
import Unfork from '../flow/Unfork.js'
import Fork from '../flow/Fork.js'

class FlowProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.ForEach)) {
            logger.debug('FlowProcessorsFactory: Creating ForEach processor')
            return new ForEach(config)
        }
        if (type.equals(ns.trn.Ping)) {
            logger.debug('FlowProcessorsFactory: Creating Ping processor')
            return new Ping(config)
        }
        if (type.equals(ns.trn.NOP)) {
            return new NOP(config)
        }
        if (type.equals(ns.trn.DeadEnd)) {
            return new DeadEnd(config)
        }
        if (type.equals(ns.trn.Halt)) {
            return new Halt(config)
        }
        if (type.equals(ns.trn.Fork)) {
            return new Fork(config)
        }
        if (type.equals(ns.trn.Unfork)) {
            return new Unfork(config)
        }
        return false
    }
}

export default FlowProcessorsFactory

================
File: src/processors/flow/ForEach.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ForEach extends Processor {
    constructor(config) {
        super(config)
    }

    async process(message) {

        logger.debug('ForEach execute method called')

        if (!message.foreach || !Array.isArray(message.foreach)) {
            logger.error('ForEach: Invalid or missing foreach array in message')
            message.foreach = ["testing-testing", "one", "two", "three"]

        }

        for (const item of message.foreach) {
            const clonedMessage = structuredClone(message)
            clonedMessage.currentItem = item
            delete clonedMessage.foreach

            logger.debug(`ForEach: Emitting message for item: ${item}`)
            this.emit('message', clonedMessage)
        }

        logger.debug('ForEach: Finished processing all items')
    }
}
export default ForEach

================
File: src/processors/flow/Fork.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'




class Fork extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {

        const nForks = message.nForks || 2

        logger.debug('forks = ' + nForks)

        for (let i = 0; i < nForks; i++) {
            var messageClone = structuredClone(message)
            messageClone.forkN = i
            logger.debug('--- emit --- ' + i)
            this.emit('message', messageClone)
        }

        message.done = true

        return this.emit('message', message)

    }

}

export default Fork

================
File: src/processors/flow/Halt.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class Halt extends Processor {

    process(message) {
        logger.log('\n************************************************************************')
        logger.log('*** << Thou Hast Summoned HALT, the Mighty Stopper of All Things  >> ***')
        logger.log('*** <<                   ~~~ ALL IS GOOD ~~~                      >> ***')
        logger.log('*** <<                     Have a nice day!                       >> ***')
        logger.log('************************************************************************\n')
        logger.log('*** Transmission was : ' + message.tags)
        logger.log('*** Context now : ')
        logger.reveal(message)
        process.exit()
    }
}

export default Halt

================
File: src/processors/flow/NOP.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class NOP extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {
        const done = message.done ? `DONE` : `NOT DONE`
        logger.log(`\nNOP at [${message.tags}] ${this.getTag()} (${done})`)

        return this.emit('message', message)
    }

    double(string) {
        return string + string
    }
}
export default NOP

================
File: src/processors/flow/Ping.js
================
import { Worker } from 'worker_threads';
import path from 'path';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class Ping extends Processor {
    constructor(config) {
        super(config);
        this.worker = null;
        this.pingConfig = {
            interval: this.getPropertyFromMyConfig(ns.trn.interval) || 5000,
            count: this.getPropertyFromMyConfig(ns.trn.count) || 0,
            payload: this.getPropertyFromMyConfig(ns.trn.payload) || 'ping',
            killSignal: this.getPropertyFromMyConfig(ns.trn.killSignal) || 'STOP',
            retryAttempts: this.getPropertyFromMyConfig(ns.trn.retryAttempts) || 3,
            retryDelay: this.getPropertyFromMyConfig(ns.trn.retryDelay) || 1000
        };
    }

    async process(message) {
        try {

            if (message.kill === this.pingConfig.killSignal) {
                await this.shutdown();
                return this.emit('message', {
                    ...message,
                    pingStatus: 'stopped',
                    timestamp: Date.now()
                });
            }

            if (this.worker) {
                logger.warn('Ping worker already running, ignoring start request');
                return;
            }

            let retryCount = 0;
            const startWorker = async () => {
                try {
                    this.worker = new Worker(
                        path.join(process.cwd(), 'src/processors/flow/PingWorker.js')
                    );

                    this.worker.on('message', (msg) => {
                        switch (msg.type) {
                            case 'ping':
                                this.emit('message', {
                                    ...message,
                                    ping: {
                                        count: msg.count,
                                        timestamp: msg.timestamp,
                                        payload: msg.payload,
                                        status: 'running'
                                    }
                                });
                                break;
                            case 'complete':
                                this.emit('message', {
                                    ...message,
                                    pingComplete: true,
                                    timestamp: Date.now()
                                });
                                break;
                            case 'error':
                                this.handleWorkerError(msg.error, startWorker, retryCount);
                                break;
                        }
                    });

                    this.worker.on('error', (error) => {
                        this.handleWorkerError(error, startWorker, retryCount);
                    });

                    this.worker.on('exit', (code) => {
                        if (code !== 0) {
                            this.handleWorkerError(
                                new Error(`Worker stopped with exit code ${code}`),
                                startWorker,
                                retryCount
                            );
                        }
                        this.worker = null;
                    });

                    this.worker.postMessage({
                        type: 'start',
                        config: this.pingConfig
                    });

                } catch (error) {
                    this.handleWorkerError(error, startWorker, retryCount);
                }
            };

            await startWorker();

            return new Promise((resolve) => {
                this.worker.on('exit', () => {
                    resolve(message);
                });
            });

        } catch (error) {
            logger.error(`Failed to start ping processor: ${error}`);
            throw error;
        }
    }

    async handleWorkerError(error, retryFn, retryCount) {
        logger.error(`Ping worker error: ${error}`);

        if (retryCount < this.pingConfig.retryAttempts) {
            retryCount++;
            logger.info(`Retrying ping worker (attempt ${retryCount}/${this.pingConfig.retryAttempts})`);
            setTimeout(retryFn, this.pingConfig.retryDelay);
        } else {
            logger.error('Max retry attempts reached, stopping ping worker');
            this.emit('error', error);
            await this.shutdown();
        }
    }

    async shutdown() {
        if (this.worker) {
            this.worker.postMessage({ type: 'stop' });
            this.worker = null;
        }
    }
}

export default Ping;

================
File: src/processors/flow/Unfork.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import DeadEnd from './DeadEnd.js'






class Unfork extends Processor {

    constructor(config) {
        super(config)







    }

    async process(message) {

        logger.debug(`Unfork got message with done=${message.done}, tags=${message.tags}`)

        logger.debug('Unfork ----')
        if (message.done) {
            logger.debug(' - Unfork passing message >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>')
            message.done = false









            return this.emit('message', message)
        } else {
            logger.debug(' - Unfork terminating pipe')
            return
        }
    }
}
export default Unfork

================
File: src/processors/fs/DirWalker.js
================
import { readdir } from 'fs/promises'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import StringUtils from '../../utils/StringUtils.js'

class DirWalker extends Processor {
    constructor(config) {
        super(config)


        this.fileCount = 0
    }

    async process(message) {

        logger.debug('\nDirWalker.process')
        logger.debug(`\nDirWalker.process, this = ${this}`)
        message.counter = 0
        message.slugs = []
        message.done = false

        var sourceDir = this.getProperty(ns.trn.sourceDir)
        logger.debug(`DirWalker sourceDir from config = ${sourceDir}`)
        if (!message.sourceDir) {
            message.sourceDir = sourceDir
        }

        if (!sourceDir) {
            sourceDir = message.dataDir
        }


        this.includePatterns = this.getProperty(ns.trn.includePattern, ['*.md', '*.js', '*.json', '*.ttl'])
        this.excludePatterns = this.getProperty(ns.trn.excludePattern, ['*.', '.git', 'node_modules'])



        logger.debug('\n\nDirWalker, message.targetPath = ' + message.targetPath)
        logger.debug('DirWalker, message.rootDir = ' + message.rootDir)
        logger.debug('DirWalker, message.sourceDir = ' + message.sourceDir)



        let dirPath
        if (path.isAbsolute(sourceDir)) {
            dirPath = sourceDir
        } else {
            if (message.targetPath) {
                dirPath = path.join(message.targetPath, sourceDir)
            } else {
                dirPath = path.join(message.rootDir, sourceDir)
            }
        }
        logger.debug(`DirWalker resolved dirPath = ${dirPath}`)

        await this.walkDirectory(dirPath, message)

        const finalMessage = structuredClone(message)
        finalMessage.done = true
        logger.debug("DirWalker emitting final done=true message")
        return this.emit('message', finalMessage)
    }




    matchPatterns(str, patterns) {
        return StringUtils.matchPatterns(str, patterns)

        const matches = patterns.filter(pattern => this.matchesPattern(str, pattern))
        if (matches.length > 0) {
            return matches
        }
        return false
    }

    matchesPattern(str, pattern) {
        return StringUtils.matchesPattern(str, pattern)


        const regexPattern = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*')
        const regex = new RegExp(`^${regexPattern}$`)
        return regex.test(str)
    }

    async walkDirectory(dir, baseMessage) {
        logger.debug(`DirWalker.walkDirectory, dir = ${dir}`)

        const entries = await readdir(dir, { withFileTypes: true })

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name)




            if (entry.isDirectory() && !this.matchPatterns(fullPath, this.excludePatterns)) {
                await this.walkDirectory(fullPath, baseMessage)
            } else if (entry.isFile()) {



                if (!this.matchPatterns(fullPath, this.excludePatterns) &&
                    this.matchPatterns(fullPath, this.includePatterns)) {



                    const message = structuredClone(baseMessage)
                    message.filename = entry.name
                    message.subdir = path.dirname(path.relative(message.targetPath, fullPath)).split(path.sep)[1]
                    message.fullPath = fullPath
                    message.filepath = path.relative(baseMessage.targetPath || baseMessage.rootDir, fullPath)
                    message.done = false
                    message.counter++

                    const slug = message.filename.split('.')[0]
                    message.slugs.push(slug)

                    logger.debug(`DirWalker emitting :
                        message.targetPath: ${message.targetPath}
                        message.filename: ${message.filename}
                        message.fullPath: ${message.fullPath}
                        message.subdir: ${message.subdir}
                        message.filepath: ${message.filepath}
                        message.slugs: ${message.slugs}`)

                    message.fileCount++
                    this.emit('message', message)
                }
            }
        }
    }
}

export default DirWalker

================
File: src/processors/fs/FileCopy.js
================
import { copyFile, mkdir, readdir, stat } from 'node:fs/promises'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class FileCopy extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {


        logger.debug("message.rootDir = " + message.rootDir)
        var source, destination


        if (this.settings === 'undefined') {
            logger.debug('FileCopy: using message.source and message.destination')
            source = message.source
            destination = message.destination
        } else {
            logger.debug(`FileCopy: using settings ${this.settings.value}`)
            source = this.getPropertyFromMyConfig(ns.trn.source)
            destination = this.getPropertyFromMyConfig(ns.trn.destination)
            if (message.targetPath) {
                source = path.join(message.targetPath, source)
                destination = path.join(message.targetPath, destination)
            } else {
                source = path.join(message.rootDir, source)
                destination = path.join(message.rootDir, destination)
            }

        }

        logger.debug(`Source: ${source}`)
        logger.debug(`Destination: ${destination}`)

        try {
            await this.ensureDirectoryExists(path.dirname(destination))
            const sourceStat = await stat(source)

            if (sourceStat.isFile()) {
                logger.debug(`Copying file from ${source} to ${destination}`)
                await copyFile(source, destination)
            } else if (sourceStat.isDirectory()) {
                logger.debug(`Copying directory from ${source} to ${destination}`)
                await this.copyDirectory(source, destination)
            }
        } catch (err) {
            logger.error(`Error in FileCopy: ${err.message}`)
            logger.error(`Source: ${source}`)
            logger.error(`Destination: ${destination}`)
        }

        return this.emit('message', message)
    }





    async ensureDirectoryExists(dirPath) {
        logger.debug(`Ensuring directory exists: ${dirPath}`)
        try {
            await mkdir(dirPath, { recursive: true })
            logger.debug(`Directory created/ensured: ${dirPath}`)
        } catch (err) {
            logger.debug(`Error creating directory ${dirPath}: ${err.message}`)
            throw err
        }
    }






    async copyDirectory(source, destination) {
        logger.debug(`Copying directory: ${source} to ${destination}`)
        try {
            await this.ensureDirectoryExists(destination)
            const entries = await readdir(source, { withFileTypes: true })

            for (const entry of entries) {
                const srcPath = path.join(source, entry.name)
                const destPath = path.join(destination, entry.name)

                logger.debug(`Processing: ${srcPath} to ${destPath}`)

                if (entry.isDirectory()) {
                    await this.copyDirectory(srcPath, destPath)
                } else {
                    await copyFile(srcPath, destPath)
                    logger.debug(`File copied: ${srcPath} to ${destPath}`)
                }
            }
        } catch (err) {
            logger.debug(`Error in copyDirectory: ${err.message}`)
            throw err
        }
    }
}

export default FileCopy

================
File: src/processors/fs/FilenameMapper.js
================
import Processor from '../base/Processor.js';
import path from 'path';
import logger from '../../utils/Logger.js';

class FilenameMapper extends Processor {
    constructor(config) {
        super(config);
        this.extensions = {
            html: '.mm.html',
            svg: '.mm.svg'
        };
    }

    async process(message) {
        const format = message.format || 'html';
        const extension = this.extensions[format];

        if (!extension) {
            throw new Error(`Unknown format: ${format}`);
        }

        const parsedPath = path.parse(message.filepath);
        message.filepath = path.join(
            parsedPath.dir,
            parsedPath.name + extension
        );

        return this.emit('message', message);
    }
}

export default FilenameMapper;

================
File: src/processors/fs/FileReader.js
================
import { readFile } from 'node:fs/promises'
import { access, constants, statSync } from 'node:fs'
import path from 'path'
import mime from 'node-mime-types'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'

class FileReader extends Processor {
    constructor(config) {
        super(config)
    }


    async process(message) {
        logger.debug(`FileReader.process, done=${message.done}`)

        if (message.done) return this.emit('message', message)

        let filePath


        if (message.fullPath) {
            filePath = message.fullPath
        } else if (message.filepath) {
            if (message.targetPath && !path.isAbsolute(message.filepath)) {
                filePath = path.join(message.targetPath, message.filepath)
            } else {
                filePath = message.filepath
            }
        } else {

            filePath = await this.getProperty(ns.trn.sourceFile)
            if (!filePath) {
                throw new Error('No file path provided in message or config')
            }


            if (!path.isAbsolute(filePath)) {
                filePath = path.join(message.targetPath || message.rootDir, filePath)
            }
        }

        logger.debug(`FileReader.process(), reading file: ${filePath}`)
        logger.debug(`FileReader.process(), process.cwd() = ${process.cwd()}`)


        await new Promise((resolve, reject) => {
            access(filePath, constants.R_OK, (err) => {
                if (err) {
                    reject(new Error(`File ${filePath} is not readable: ${err.message}`))
                }
                resolve()
            })
        })


        const metaField = await this.getProperty(ns.trn.metaField)
        if (metaField) {
            const metadata = this.getFileMetadata(filePath)
            message[metaField] = metadata
        }


        const content = await readFile(filePath, 'utf8')
        message.content = content

        logger.debug(`FileReader successfully read file: ${filePath}`)
        return this.emit('message', message)
    }

    getFileMetadata(filePath) {
        try {
            const stats = statSync(filePath)
            const filename = path.basename(filePath)
            return {
                filename: filename,
                mediaType: mime.getMIMEType(filename),
                filepath: filePath,
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                accessed: stats.atime,
                isDirectory: stats.isDirectory(),
                isFile: stats.isFile(),
                permissions: stats.mode,
                owner: stats.uid,
                group: stats.gid
            }
        } catch (error) {
            logger.error(`Error getting file metadata: ${error.message}`)
            return null
        }
    }
}

export default FileReader

================
File: src/processors/fs/FileRemove.js
================
import { unlink, readdir, stat, rm } from 'node:fs/promises'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class FileRemove extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {



        this.ignoreDotfiles = true

        var target




        if (this.settings === 'undefined') {
            logger.debug('FileRemove no settings from transmission, using message.target')
            target = message.target
        } else {
            logger.debug('FileRemove this.settings = ' + this.settings.value)
            target = await this.getProperty(ns.trn.target)

            target = path.join(message.rootDir, target)
        }

        logger.debug('FileRemove, target = ' + target)
        try {
            const removeStat = await stat(target)

            if (removeStat.isFile()) {
                await this.removeFile(target)
            } else if (removeStat.isDirectory()) {
                await this.removeDirectoryContents(target)
            }
        } catch (err) {

            logger.debug('FileRemove, target stat caused err : ' + target)
        }

        return this.emit('message', message)
    }





    async removeFile(filePath) {
        await unlink(filePath)
    }





    async removeDirectoryContents(dirPath) {
        logger.debug('FileRemove, dirPath = ' + dirPath)
        const entries = await readdir(dirPath, { withFileTypes: true })

        for (const entry of entries) {
            if (this.ignoreDotfiles && (entry.name.charAt(0) === ".")) {
                continue
            }
            const entryPath = path.join(dirPath, entry.name)

            if (entry.isDirectory()) {
                await this.removeDirectoryContents(entryPath)
            } else {
                await unlink(entryPath)
            }
        }
    }
}

export default FileRemove

================
File: src/processors/fs/FileWriter.js
================
import path from 'path'
import { access, constants } from 'node:fs'
import ns from '../../utils/ns.js'
import { writeFile } from 'node:fs/promises'
import { dirname, join } from 'node:path'
import { mkdir, mkdirSync } from 'node:fs'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'














class FileWriter extends Processor {





    constructor(config) {
        super(config)
    }





    async process(message) {

        logger.debug(`\n\nFileWriter.process, message.done = ${message.done}`)
        if (message.done) {

            return this.emit('message', message)
        }

        if (message.dump) {


            const filename = 'message.json'
            const f = path.join(message.dataDir, filename)
            const content = JSON.stringify(message)

            access(f, constants.W_OK, (err) => {
                if (err) {
                    logger.error(`FileWriter error : ${f} is not writable.`)
                    logger.reveal(message)
                }
            })
            return this.doWrite(f, content, message)
        }

        logger.debug("Filewriter, message.filepath = " + message.filepath)

        var destinationFile = await this.getProperty(ns.trn.destinationFile)
        var filepath = message.filepath
        if (message.subdir) {
            filepath = path.join(message.subdir, filepath)
        }

        logger.debug(`Filewriter, 1 filepath = ${filepath}`)


        if (!destinationFile) {
            var targetDir = message.targetDir ?
                message.targetDir : await this.getProperty(ns.trn.targetDir)
            targetDir = targetDir ? targetDir : '.'

            filepath = path.join(targetDir, filepath)
        }

        if (!path.isAbsolute(filepath)) {
            filepath = path.join(message.targetPath, filepath)
        }

        logger.debug(`Filewriter, filepath = ${filepath}`)
        const dirName = dirname(filepath)
        logger.debug("Filewriter, dirName = " + dirName)














        var content = message.content



        this.mkdirs(dirName)

        return await this.doWrite(filepath, content, message)
    }

    async doWrite(f, content, message) {
        logger.log(' - FileWriter writing : ' + f)
        await writeFile(f, content)
        return this.emit('message', message)
    }

    mkdirs(dir) {
        mkdirSync(dir, { recursive: true })





    }
}

export default FileWriter

================
File: src/processors/fs/FsProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import DirWalker from './DirWalker.js'
import FileReader from './FileReader.js'
import FileWriter from './FileWriter.js'
import FileCopy from './FileCopy.js'
import FileRemove from './FileRemove.js'
import FilenameMapper from './FilenameMapper.js'

class FsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.DirWalker)) {
            return new DirWalker(config)
        }
        if (type.equals(ns.trn.FileReader)) {
            return new FileReader(config)
        }
        if (type.equals(ns.trn.FileWriter)) {
            return new FileWriter(config)
        }
        if (type.equals(ns.trn.FileCopy)) {
            return new FileCopy(config)
        }
        if (type.equals(ns.trn.FileRemove)) {
            return new FileRemove(config)
        }
        if (type.equals(ns.trn.FilenameMapper)) {
            return new FilenameMapper(config)
        }
        return false
    }
}

export default FsProcessorsFactory

================
File: src/processors/github/GitHubList_no-pag.js
================
import { Octokit } from '@octokit/rest'
import dotenv from 'dotenv'
import Processor from '../base/Processor.js'
import logger from '../../utils/Logger.js'

dotenv.config({ path: './trans-apps/applications/git-apps/.env' })

class GitHubList extends Processor {
    constructor(config) {
        super(config)
        logger.debug('GitHubList constructor called')
        this.octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })
        logger.debug('Octokit instance created')
    }

    async process(message) {
        logger.debug('GitHubList execute method called')
        logger.debug('Input message:', JSON.stringify(message, null, 2))

        if (!message.github || !message.github.name) {
            logger.error('GitHub username not provided in the message')
            throw new Error('GitHub username not provided in the message')
        }

        const username = message.github.name
        logger.debug(`Fetching repositories for username: ${username}`)

        try {
            logger.debug('Calling GitHub API')
            const { data } = await this.octokit.repos.listForUser({ username })
            logger.debug(`Fetched ${data.length} repositories`)

            const repositories = data.map(repo => repo.name)
            logger.debug('Extracted repository names:' + repositories)

            message.github.repositories = repositories
            logger.debug('Updated message:', JSON.stringify(message, null, 2))

            this.emit('message', message)
            logger.debug('Emitted updated message')
        } catch (error) {
            logger.error(`Error fetching repositories for ${username}:`, error)
            logger.debug('Error details:', JSON.stringify(error, null, 2))
            if (error.status === 403) {
                logger.warn('Possible rate limit exceeded. Check GitHub API rate limits.')
            }
            throw error
        }
    }
}

export default GitHubList

================
File: src/processors/github/GitHubList.js
================
import { Octokit } from '@octokit/rest'
import dotenv from 'dotenv'
import Processor from '../../../../transmissions/src/processors/base/Processor.js'
import logger from '../../../../transmissions/src/utils/Logger.js'

dotenv.config({ path: './trans-apps/applications/git-apps/.env' })

class GitHubList extends Processor {
    constructor(config) {
        super(config)
        logger.debug('GitHubList constructor called')
        this.octokit = new Octokit({ auth: process.env.GITHUB_TOKEN })
        logger.debug('Octokit instance created')
    }

    async process(message) {

        logger.debug('GitHubList process method called')

        try {

            if (!message.payload) {
                message.payload = {}
            }
            if (!message.payload.github) {
                message.payload.github = {}
            }


            const username = message.github.name
            logger.debug(`Processing for username: ${username}`)

            logger.debug('Calling GitHub API with pagination')
            logger.info(`Starting repository fetch for ${username}`)

            const repositories = await this.fetchAllRepositories(username)
            logger.debug(`Setting ${repositories.length} repositories in payload`)


            message.payload.github.repositories = repositories
            message.payload.github.totalRepos = repositories.length

            return this.emit('message', message)
        } catch (error) {
            this.handleError(error, username)
        }
    }

    async fetchAllRepositories(username) {
        const repositories = []
        let page = 1
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms))

























        while (true) {
            const response = await this.octokit.repos.listForUser({
                username,
                per_page: 100,
                page
            })

            let data = response.data


            logger.debug(`Page ${page}: Got ${data.length} repos`)

            repositories.push(...data.map(repo => repo.name))

            if (data.length < 100) break
            page++


            await new Promise(r => setTimeout(r, 5000))
        }

        logger.debug(`Total repositories found: ${repositories.length}`)

        return repositories
    }

    checkRateLimit(headers) {
        const remaining = headers['x-ratelimit-remaining']
        const resetTime = new Date(headers['x-ratelimit-reset'] * 1000)
        logger.info(`Rate limit remaining: ${remaining}, Reset time: ${resetTime}`)

        if (remaining < 10) {
            logger.warn(`Rate limit is low. Only ${remaining} requests left. Reset at ${resetTime}`)
        }
    }

    createDetailedError(error, message) {
        const detailedError = new Error(`${message}: ${error.message}`)
        detailedError.status = error.status
        detailedError.response = error.response
        return detailedError
    }

    handleError(error, username) {
        logger.error(`Error fetching repositories for ${username}:`, error.message)
        logger.debug('Error details:', JSON.stringify(error, null, 2))

        if (error.status === 403) {
            logger.warn('Rate limit exceeded. Check GitHub API rate limits.')
            throw new Error('GitHub API rate limit exceeded')
        } else if (error.status === 404) {
            logger.warn(`User ${username} not found on GitHub`)
            throw new Error(`GitHub user ${username} not found`)
        } else {
            throw new Error(`Failed to fetch GitHub repositories: ${error.message}`)
        }
    }
}

export default GitHubList

================
File: src/processors/github/GitHubProcessorsFactory.js
================
import logger from '../../../../transmissions/src/utils/Logger.js';
import ns from '../../../../transmissions/src/utils/ns.js';
import GitHubList from './GitHubList.js';

class GitHubProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.GitHubList)) {
            return new GitHubList(config);
        }
        return false;
    }
}

export default GitHubProcessorsFactory;

================
File: src/processors/http/services/MetricsService.js
================
import WebSocket from 'ws';
import os from 'os';

class MetricsService {
    constructor(server) {
        this.wss = new WebSocket.Server({ server });
        this.metrics = {
            startTime: Date.now(),
            requests: 0,
            connections: 0,
            memory: {},
            cpu: {}
        };
        this.setupWebSocket();
        this.startMetricsCollection();
    }

    setupWebSocket() {
        this.wss.on('connection', (ws) => {
            this.metrics.connections++;
            ws.on('close', () => this.metrics.connections--);
        });
    }

    startMetricsCollection() {
        setInterval(() => {
            this.updateMetrics();
            this.broadcastMetrics();
        }, 1000);
    }

    updateMetrics() {
        this.metrics.uptime = (Date.now() - this.metrics.startTime) / 1000;
        this.metrics.memory = {
            used: process.memoryUsage().heapUsed,
            total: os.totalmem(),
            free: os.freemem()
        };
        this.metrics.cpu = {
            load: os.loadavg(),
            cores: os.cpus().length
        };
    }

    broadcastMetrics() {
        const data = JSON.stringify(this.metrics);
        this.wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(data);
            }
        });
    }

    incrementRequests() {
        this.metrics.requests++;
    }
}

export default MetricsService;

================
File: src/processors/http/services/ShutdownService.js
================
import crypto from 'crypto';

class ShutdownService {
    constructor() {

        this.username = crypto.randomBytes(16).toString('hex');
        this.password = crypto.randomBytes(32).toString('hex');
    }

    setupMiddleware(app) {
        app.use('/admin', (req, res, next) => {
            const authHeader = req.headers.authorization;
            if (!this.validateAuth(authHeader)) {
                res.setHeader('WWW-Authenticate', 'Basic');
                return res.status(401).send('Authentication required');
            }
            next();
        });
    }

    validateAuth(authHeader) {
        if (!authHeader || !authHeader.startsWith('Basic ')) {
            return false;
        }
        const base64Credentials = authHeader.split(' ')[1];
        const credentials = Buffer.from(base64Credentials, 'base64').toString('utf-8');
        const [username, password] = credentials.split(':');

        return username === this.username && password === this.password;
    }

    setupEndpoints(app, shutdownCallback) {
        app.get('/admin/credentials', (req, res) => {
            res.json({ username: this.username, password: this.password });
        });

        app.post('/admin/shutdown', (req, res) => {
            res.send('Shutdown initiated');
            shutdownCallback();
        });
    }
}

export default ShutdownService;

================
File: src/processors/http/HttpClient.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'









class HttpClient extends Processor {





    constructor(config) {
        super(config)
    }





    async process(message) {



        return this.emit('message', message)
    }
}

export default HttpClient

================
File: src/processors/http/HttpProcessorsFactory.js
================
import ns from '../../utils/ns.js'

import HttpServer from './HttpServer.js'
import HttpClient from './HttpClient.js'
import HttpProxy from './HttpProxy.js'

class HttpProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.HttpServer)) {
            return new HttpServer(config)
        }
        if (type.equals(ns.trn.HttpClient)) {
            return new HttpClient(config)
        }
        if (type.equals(ns.trn.HttpProxy)) {
            return new HttpProxy(config)
        }

        return false
    }
}
export default HttpProcessorsFactory

================
File: src/processors/http/HttpProxy.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'









class HttpProxy extends Processor {





    constructor(config) {
        super(config)
    }





    async process(message) {



        return this.emit('message', message)
    }
}

export default HttpProxy

================
File: src/processors/http/HttpServer.js
================
import path from 'path';
import { Worker } from 'worker_threads';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class HttpServer extends Processor {
    constructor(config) {
        super(config);
        this.worker = null;
        this.serverConfig = {
            port: this.getPropertyFromMyConfig(ns.trn.port) || 4000,
            basePath: this.getPropertyFromMyConfig(ns.trn.basePath) || '/transmissions/test/',
            staticPath: this.getPropertyFromMyConfig(ns.trn.staticPath),
            cors: this.getPropertyFromMyConfig(ns.trn.cors) || false,
            timeout: this.getPropertyFromMyConfig(ns.trn.timeout) || 30000,
            maxRequestSize: this.getPropertyFromMyConfig(ns.trn.maxRequestSize) || '1mb',
            rateLimit: {
                windowMs: 15 * 60 * 1000,
                max: 100
            }
        };
    }

    async process(message) {
        try {
            this.worker = new Worker(
                path.join(process.cwd(), 'src/processors/http/HttpServerWorker.js')
            );

            this.worker.on('message', (msg) => {
                switch (msg.type) {
                    case 'status':
                        if (msg.status === 'running') {
                            logger.info(`Server running on port ${msg.port}`);
                        } else if (msg.status === 'stopped') {
                            this.emit('message', { ...message, serverStopped: true });
                        }
                        break;
                    case 'error':
                        logger.error(`Server error: ${msg.error}`);
                        this.emit('error', new Error(msg.error));
                        break;
                }
            });

            this.worker.on('error', (error) => {
                logger.error(`Worker error: ${error}`);
                this.emit('error', error);
            });

            this.worker.postMessage({
                type: 'start',
                config: this.serverConfig
            });

            return new Promise((resolve) => {
                this.worker.on('exit', () => {
                    resolve(message);
                });
            });

        } catch (error) {
            logger.error(`Failed to start server: ${error}`);
            throw error;
        }
    }

    async shutdown() {
        if (this.worker) {
            this.worker.postMessage({ type: 'stop' });
        }
    }
}

export default HttpServer;

================
File: src/processors/http/HttpServerWorker.js
================
import { parentPort } from 'worker_threads';
import express from 'express';
import path from 'path';
import logger from '../../utils/Logger.js';

class ServerWorker {
    constructor(config) {
        this.app = express();
        this.server = null;
        this.config = config;
        this.setupMessageHandling();
    }

    setupMessageHandling() {
        parentPort.on('message', (message) => {
            switch (message.type) {
                case 'start':
                    this.start(message.config);
                    break;
                case 'stop':
                    this.stop();
                    break;
                default:
                    logger.warn(`Unknown message type: ${message.type}`);
            }
        });
    }

    async start(config) {
        try {
            const { port = 4000, basePath = '/transmissions/test/', staticPath } = config;

            if (staticPath) {
                this.app.use(basePath, express.static(staticPath));
            }

            this.app.post('/shutdown', (req, res) => {
                res.send('Server shutting down...');
                this.stop();
            });

            this.server = this.app.listen(port, () => {
                parentPort.postMessage({
                    type: 'status',
                    status: 'running',
                    port: port
                });
            });

        } catch (error) {
            parentPort.postMessage({
                type: 'error',
                error: error.message
            });
        }
    }

    async stop() {
        if (this.server) {
            try {
                await new Promise((resolve, reject) => {
                    this.server.close((err) => {
                        if (err) reject(err);
                        resolve();
                    });
                });

                parentPort.postMessage({
                    type: 'status',
                    status: 'stopped'
                });

                process.exit(0);
            } catch (error) {
                parentPort.postMessage({
                    type: 'error',
                    error: error.message
                });
                process.exit(1);
            }
        }
    }
}

const worker = new ServerWorker();

================
File: src/processors/json/Blanker.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class Blanker extends Processor {
    constructor(config) {
        super(config)

        logger.debug(config.blankValue)
        this.blankValue = config.blankValue || ''
    }

    async process(message) {
        const pointer = this.getPropertyFromMyConfig(ns.trn.pointer)
        const preserve = this.getPropertyFromMyConfig(ns.trn.preserve)

        var preservePath = preserve.value ? preserve.value : 'nonono'

        logger.debug(`Blanker.process,  typeof preservePath = ${typeof preservePath}, preservePath = ${preservePath}`)
        logger.reveal(preservePath)
        if (!pointer) {
            if (preservePath) {
                message = this.blankValues(message, '', preservePath)
            } else {
                message = this.blankAllValues(message)
            }
        } else {
            const parts = pointer.toString().split('.')
            let target = message

            for (let i = 0; i < parts.length - 1; i++) {
                target = target[parts[i]]
                if (!target) break
            }

            if (target && target[parts[parts.length - 1]]) {
                if (preservePath) {
                    target[parts[parts.length - 1]] =
                        this.blankValues(target[parts[parts.length - 1]], parts.join('.'), preservePath)
                } else {
                    target[parts[parts.length - 1]] =
                        this.blankAllValues(target[parts[parts.length - 1]])
                }
            }
        }

        return this.emit('message', message)
    }

    shouldPreserve(path, preservePath) {
        logger.debug(`Blanker.shouldPreserve path = ${path}, preservePath = ${preservePath}`)
        if (!preservePath) return false
        const pathParts = path.split('.')
        const preserveParts = preservePath.split('.')

        if (pathParts.length < preserveParts.length) return false

        for (let i = 0; i < preserveParts.length; i++) {
            if (pathParts[i] !== preserveParts[i]) return false
        }
        return true
    }


    blankAllValues(obj) {
        if (Array.isArray(obj)) {
            return obj.map(item => this.blankAllValues(item))
        } else if (typeof obj === 'object' && obj !== null) {
            const result = {}
            for (const [key, value] of Object.entries(obj)) {
                result[key] = this.blankAllValues(value)
            }
            return result
        } else if (typeof obj === 'string') {
            return ''
        }
        return obj
    }

    blankValues(obj, currentPath = '', preservePath = '') {
        if (Array.isArray(obj)) {
            return obj.map((item, index) =>
                this.blankValues(item, `${currentPath}[${index}]`, preservePath)
            )
        } else if (typeof obj === 'object' && obj !== null) {
            const result = {}
            for (const [key, value] of Object.entries(obj)) {
                const newPath = currentPath ? `${currentPath}.${key}` : key
                logger.debug(`Blanker.blankValues 1 newPath = ${newPath}, preservePath = ${preservePath}`)
                if (this.shouldPreserve(newPath, preservePath)) {
                    result[key] = value
                } else {
                    result[key] = this.blankValues(value, newPath, preservePath)
                }
            }
            return result
        } else if (typeof obj === 'string') {
            logger.debug(`Blanker.blankValues 2 currentPath = ${currentPath}, preservePath = ${preservePath}`)
            return this.shouldPreserve(currentPath, preservePath) ? obj : ''
        }
        return obj
    }
}

export default Blanker

================
File: src/processors/json/JSONProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import JSONWalker from './JSONWalker.js'
import Restructure from './Restructure.js'
import ValueConcat from './ValueConcat.js'
import Blanker from './Blanker.js'

class JSONProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.Restructure)) {
            return new Restructure(config)
        }
        if (type.equals(ns.trn.JSONWalker)) {
            return new JSONWalker(config)
        }
        if (type.equals(ns.trn.ValueConcat)) {
            return new ValueConcat(config)
        }
        if (type.equals(ns.trn.Blanker)) {
            return new Blanker(config)
        }
        return false
    }

}
export default JSONProcessorsFactory

================
File: src/processors/json/JsonRestructurer.js
================
import logger from '../../utils/Logger.js'

class JsonRestructurer {
    constructor(mappings) {

        if (!mappings?.mappings || !Array.isArray(mappings.mappings)) {
            throw new Error('Invalid mapping structure')
        }
        this.mappings = mappings.mappings
        logger.debug('JsonRestructurer,  this.mappings = ' + this.mappings)

    }

    getValueByPath(obj, path) {







        try {
            const sp = path.split('.')
            logger.debug('JsonRestructurer, sp = ' + sp)
            const reduced = sp.reduce((acc, part) => acc[part], obj)
            logger.debug('JsonRestructurer, reduced = ' + reduced)
            return reduced
        } catch (e) {
            logger.warn(`Warning: Path ${path} not found`)
            return undefined
        }
    }

    setValueByPath(obj, path, value) {
        logger.debug(`JsonRestructurer.setValueByPath, obj = ${obj}, path = ${path}, value = ${value}`)
        const parts = path.split('.')
        const last = parts.pop()
        const target = parts.reduce((acc, part) => {
            acc[part] = acc[part] || {}
            return acc[part]
        }, obj)
        logger.debug(`JsonRestructurer.setValueByPath, target = ${target}, last = ${last}, value = ${value}`)
        target[last] = value
    }

    restructure(inputData) {

        if (typeof inputData === 'string') {
            try {
                inputData = JSON.parse(inputData)
            } catch (e) {
                throw new Error('Invalid JSON string provided')
            }
        }


        const result = {}
        this.mappings.forEach(({ pre, post }) => {

            const value = this.getValueByPath(inputData, pre)

            if (value !== undefined) {
                this.setValueByPath(result, post, value)
            }
        })



        return result
    }
}
export default JsonRestructurer

================
File: src/processors/json/JSONWalker.js
================
import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class JSONWalker extends Processor {
    constructor(config) {
        super(config)
    }







    async process(message) {

        message.done = false
        var pointer = this.getProperty(ns.trn.pointer)

        logger.debug(`JSONWalker pointer =  ${pointer}`)


        var content = structuredClone(message.content)
        if (typeof content === 'string') {
            logger.debug(`content is a string, parsing to JSON`)
            content = JSON.parse(content)
        }
        message.content = {}
        logger.debug(`content.length  = ${content.length}`)
        var die = this.getProperty(ns.trn.die)
        logger.debug(`die = ${die}`)
        if (die == "true") {


            process.exit(1)
        }

        for (var i = 0; i < content.length; i++) {
            const newMessage = structuredClone(message)
            newMessage.content = content[i]
            this.emit('message', newMessage)
        }

        var finalMessage = structuredClone(message)
        finalMessage.content = content[content.length - 1]













        finalMessage.done = true
        this.emit('message', finalMessage)

    }
}

export default JSONWalker

================
File: src/processors/json/Restructure.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import JsonRestructurer from './JsonRestructurer.js'
import ns from '../../utils/ns.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import rdf from 'rdf-ext'

class Restructure extends Processor {
    constructor(config) {
        super(config)
    }

    async getRenames(config, settings, term) {







        const renamesRDF = GrapoiHelpers.listToArray(config, this.settingsNode, term)
        const dataset = this.config

        var renames = []
        for (let i = 0; i < renamesRDF.length; i++) {
            let rename = renamesRDF[i]
            let poi = rdf.grapoi({ dataset: dataset, term: rename })
            let pre = poi.out(ns.trn.pre).value
            let post = poi.out(ns.trn.post).value
            renames.push({ "pre": pre, "post": post })
        }
        return renames
    }

    async process(message) {



        var renames
        if (this.config.simples) {
            renames = this.config.rename
        } else {
            renames = await this.getRenames(this.config, this.settings, ns.trn.rename)
        }





        this.restructurer = new JsonRestructurer({
            mappings: renames
        })
        try {
            logger.debug('Restructure processor executing...')



            const input = structuredClone(message)


            const restructured = this.restructurer.restructure(input)

            const type = typeof restructured




            for (const key of Object.keys(restructured)) {
                message[key] = restructured[key]
            }


            logger.debug('Restructure successful')
            return this.emit('message', message)

        } catch (err) {
            logger.error("Restructure processor error: " + err.message)
            logger.reveal(message)
            throw err
        }
    }
}

export default Restructure

================
File: src/processors/json/ValueConcat.js
================
import logger from '../../utils/Logger.js'
import rdf from 'rdf-ext'
import ns from '../../utils/ns.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import Processor from '../base/Processor.js'

class ValueConcat extends Processor {

    constructor(config) {
        super(config)
        logger.log('CREATING VALUECONCAT')
    }

}
export default ValueConcat

================
File: src/processors/markup/LinkFinder.js
================
import * as cheerio from 'cheerio'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class LinkFinder extends Processor {

    async process(message) {

        await this.extractLinks(message)

        if (data === '~~done~~') {
            logger.log('LF DONE*****************')
            return this.emitLocal('message', '~~done~~', message)
            return
        }
    }


    relocate(filename, extension) {
        const split = filename.split('.').slice(0, -1)
        return split.join('.') + extension
    }

    async extractLinks(htmlContent, message) {

        const $ = cheerio.load(htmlContent)
        let label = ''

        $('a, h1, h2, h3, h4, h5, h6').each((_, element) => {
            const tagName = element.tagName.toLowerCase()
            if (tagName.startsWith('h')) {
                const level = tagName.substring(1)
                const headerText = $(element).text()
                label = `\n\n${'#'.repeat(parseInt(level))} ${headerText}\n`
            } else if (tagName === 'a') {
                const linkText = $(element).text()

                let href = $(element).attr('href')

                if (!href || href.startsWith('#')) return

                if (href && !href.includes('://')) {

                    const baseURL = message.sourceURL

                    href = new URL(href, baseURL).toString()
                }
                label = `\n[${linkText}](${href})`

            }
            message.label = label
            return this.emit('message', message)
        })
    }
}

export default LinkFinder

================
File: src/processors/markup/MarkdownToHTML.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

import { marked } from 'marked'


import markedFootnote from 'marked-footnote'
import markedCodeFormat from 'marked-code-format'


class MarkdownToHTML extends Processor {


    async process(message) {
        logger.debug(`\n\nMarkdownToHTML.process`)
        logger.reveal(message)
        var input
        if (message.contentBlocks) {
            input = message.contentBlocks.content
        } else {
            input = message.content
        }



        message.content = await
            marked

                .use(markedFootnote())
                .use(
                    markedCodeFormat({

                    })
                )
                .parse(input.toString())

        return this.emit('message', message)
    }
}

export default MarkdownToHTML

================
File: src/processors/markup/MarkupProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import MetadataExtractor from './MetadataExtractor.js'
import LinkFinder from './LinkFinder.js'
import MarkdownToHTML from './MarkdownToHTML.js'

class MarkupProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.MetadataExtractor)) {
            return new MetadataExtractor(config)
        }
        if (type.equals(ns.trn.MarkdownToHTML)) {
            return new MarkdownToHTML(config)
        }
        if (type.equals(ns.trn.LinkFinder)) {
            return new LinkFinder(config)
        }
        return false
    }
}

export default MarkupProcessorsFactory

================
File: src/processors/markup/MetadataExtractor.js
================
import * as cheerio from 'cheerio'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class MetadataExtractor extends Processor {

    async process(message) {
        const filename = data.filename
        const content = data.content

        logger.debug("MetadataExtractor input file : " + filename)
        const targetFilename = this.relocate(filename)
        logger.debug("MetadataExtractor outputfile : " + targetFilename)

        const jsonData = this.convertEmailToJSON(content)

        const jsonString = JSON.stringify(jsonData)

        const output = { filename: targetFilename, content: jsonString }

        return this.emit('message', output, message)
    }

    relocate(filename) {

        const split = filename.split('.').slice(0, -1)
        var newFileName = split.join('.') + '.json'
        return newFileName
    }

    convertEmailToJSON(htmlContent) {
        const $ = cheerio.load(htmlContent)
        var subjectLine = $('H1').text().trim()
        var fromName = $('B').first().text().trim()
        var nextMessageLink = $('LINK[REL="Next"]').attr('HREF')
        var previousMessageLink = $('LINK[REL="Previous"]').attr('HREF')
        var messageText = $('PRE').text().trim()
        messageText = this.pruneContent(messageText)
        const jsonResult = {
            subjectLine: subjectLine,
            fromName: fromName,
            nextMessageLink: nextMessageLink,
            previousMessageLink: previousMessageLink,
            messageText: messageText

        }























        return jsonResult
    }

    pruneContent(content) {

        const regex1 = /(^|\n).*?:\n>/s
        content = content.replace(regex1, '$1')

        const regex2 = /\n>.*?\n/g




        content = content.replace(regex2, '\n')

        return content
    }
}



export default MetadataExtractor

================
File: src/processors/mcp/McpClient.js
================
import logger from "../../utils/Logger.js"
import Processor from "../base/Processor.js"









class McpClient extends Processor {




  constructor(config) {
    super(config)
  }





  async process(message) {



    return this.emit("message", message)
  }
}

export default McpClient

================
File: src/processors/mcp/McpProcessorsFactory.js
================
import logger from "../../utils/Logger.js";
import ns from "../../utils/ns.js";

import ProcessorTemplate from "./McpClient.js";



class ProcessorsFactoryTemplate {
  static createProcessor(type, config) {
    if (type.equals(ns.trn.ProcessorTemplate)) {
      return new ProcessorTemplate(config);
    }

    return false;
  }
}
export default ProcessorsFactoryTemplate;

================
File: src/processors/mcp/McpServer.js
================
import logger from "../../utils/Logger.js"
import Processor from "../base/Processor.js"









class McpServer extends Processor {




  constructor(config) {
    super(config)
  }





  async process(message) {



    return this.emit("message", message)
  }
}

export default McpServer

================
File: src/processors/postcraft/AtomFeedPrep.js
================
import fs from 'fs/promises';
import path from 'path';
import Processor from '../base/Processor.js';
import logger from '../../utils/Logger.js';

class AtomFeedPrep extends Processor {
    constructor(config) {
        super(config);
    }

    async process(message) {

        const entries = message.slugs || [];
        const siteUrl = message.site?.url || 'https://danny.ayers.name';

        if (message.targetPath) {
            message.templateFilename = path.join(message.targetPath, message.atomFeed.templateFilename)
        } else {
            message.templateFilename = path.join(message.rootDir, message.atomFeed.templateFilename)
        }

        const feed = {
            title: message.site?.title || "Danny Ayers' Blog",
            subtitle: message.site?.subtitle || '',
            updated: new Date().toISOString(),
            id: siteUrl,
            link: siteUrl,
            author: {
                name: "Danny Ayers",
                email: "danny.ayers@gmail.com"
            },
            entries: []
        };

        // Get same number of entries as front page
        const entryCount = Math.min(5, entries.length);
        const rangeStart = entries.length - entryCount;
        const rangeEnd = entries.length - 1;

        for (let i = rangeEnd; i >= rangeStart; i--) {
            const slug = entries[i];
            if (slug) {
                let filePath;
                if (message.targetPath) {
                    filePath = path.join(message.targetPath, message.entryContentMeta.targetDir, slug + '.html');
                } else {
                    filePath = path.join(message.rootDir, message.entryContentMeta.targetDir, slug + '.html');
                }

                const entry = {
                    title: `Entry ${slug}`,
                    id: `${siteUrl}/entries/${slug}.html`,
                    link: `${siteUrl}/entries/${slug}.html`,
                    updated: message.contentBlocks?.updated || new Date().toISOString(),
                    content: await this.getEntryContent(filePath)
                };

                feed.entries.push(entry);
            }
        }

        message.contentBlocks = feed;
        message.filepath = path.join(message.targetPath || message.rootDir, 'public/home/atom.xml');

        return this.emit('message', message);
    }

    async getEntryContent(filePath) {
        try {
            return await fs.readFile(filePath, 'utf8');
        } catch (error) {
            logger.error(`Error reading entry file ${filePath}: ${error}`);
            return '';
        }
    }
}

export default AtomFeedPrep;

================
File: src/processors/postcraft/EntryContentToPagePrep.js
================
import path from 'path'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class EntryContentToPagePrep extends Processor {

  constructor(config) {
    super(config)
  }

  async process(message) {
    if (message.done) {
      return this.emit('message', message)
      return
    }















    message.contentBlocks.content = message.content













    message.filepath = path.join(message.contentGroup.PostPages.targetDir, message.slug + '.html')
    logger.debug('EntryContentToPagePrep, message.filepath = ' + message.filepath)

    this.emit('message', message)
  }

}

export default EntryContentToPagePrep

================
File: src/processors/postcraft/FrontPagePrep.js
================
import path from 'path'
import { readFile } from 'node:fs/promises'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'


class FrontPagePrep extends Processor {
  constructor(config) {
    super(config)
  }


  async process(message) {












    const rawEntryPaths = this.resolveRawEntryPaths(message)
    message.content = ''

    // TODO tidy up //
    const entryCount = Math.min(5, rawEntryPaths.length) // Limit to 5 entries or less
    logger.debug('FrontPagePrep, entryCount = ' + entryCount)

    const rangeStart = rawEntryPaths.length - entryCount
    const rangeEnd = rawEntryPaths.length - 1
    //     for (let i = 0; i < entryCount; i++) {
    for (let i = rangeEnd; i >= rangeStart; i--) {
      logger.debug('FrontPagePrep, i = ' + entryCount)
      const rawEntryPath = rawEntryPaths[i]
      if (rawEntryPath) {
        message.content += await readFile(rawEntryPath, 'utf8')
      } else {
        logger.warn(`Skipping undefined entry path at index ${i}`)
      }
    }

    message.contentBlocks.content = message.content

    if (message.targetPath) {
      message.filepath = path.join(message.targetPath, message.indexPage.filepath)
    } else {
      message.filepath = path.join(message.rootDir, message.indexPage.filepath)
    }
    return this.emit('message', message)

  }


  resolveRawEntryPaths(message) {
    const paths = []
    const slugs = message.slugs || []
    const entryCount = slugs.length

    for (let i = 0; i < entryCount; i++) {
      const slug = slugs[i]
      if (slug) {

        let filePath







        filePath = path.join(message.targetPath, slug + '.html')
        paths.push(filePath)
      }
    }

    return paths
  }
}

export default FrontPagePrep

================
File: src/processors/postcraft/PostcraftDispatcher.js
================
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'
import grapoi from 'grapoi'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'











class PostcraftDispatcher extends Processor {





  constructor(config) {
    super(config)
  }






  async process(message) {

    const postcraftConfig = message.dataset
    message.template = data.toString()
    logger.debug('PostcraftDispatcherPostcraftDispatcherPostcraftDispatcher ' + data)
    process.exit(0)
    const poi = grapoi({ dataset: postcraftConfig })

    for (const q of poi.out(ns.rdf.type).quads()) {
      if (q.object.equals(ns.trn.ContentGroup)) {
        await this.processContentGroup(message, q.subject)
      }
    }
  }






  async processContentGroup(message, contentGroupID) {
    const postcraftConfig = message.dataset
    const groupPoi = rdf.grapoi({ dataset: postcraftConfig, term: contentGroupID })
    const sourceDir = groupPoi.out(ns.trn.sourceDirectory).term.value
    const targetDir = groupPoi.out(ns.trn.targetDirectory).term.value
    const templateFilename = groupPoi.out(ns.trn.template).term.value





    message.sourceDir = sourceDir
    message.targetDir = targetDir
    message.templateFilename = templateFilename
    message.loadContext = 'template'

    return this.emit('message', sourceDir, message)
  }
}

export default PostcraftDispatcher

================
File: src/processors/postcraft/PostcraftPrep.js
================
import path from 'path'
import logger from '../../utils/Logger.js'

import Processor from '../base/Processor.js'

class PostcraftPrep extends Processor {

  constructor(config) {
    super(config)
  }

  async process(message) {


    if (message.done) {
      return this.emit('message', message)
    }
    message.slug = this.extractSlug(message)
    message.targetFilename = this.extractTargetFilename(message)
    message.contentBlocks = {}
    message.contentBlocks.relURL = this.extractRelURL(message)


    message.contentBlocks.link = 'entries/' + message.contentBlocks.relURL

    message.contentBlocks.title = this.extractTitle(message)

    const { created, updated } = this.extractDates(message)
    message.contentBlocks.created = created
    message.contentBlocks.updated = updated

    return this.emit('message', message)
  }


  extractSlug(message) {

    var slug = message.filename

    if (slug.includes('.')) {
      slug = slug.substr(0, slug.lastIndexOf("."))
    }
    return slug
  }

  extractTargetFilename(message) {









    logger.reveal(message)








    return path.join(message.contentGroup.PostPages.targetDir, this.extractSlug(message) + '.html')
  }

  extractRelURL(message) {
    return this.extractSlug(message) + '.html'
  }

  extractDates(message) {
    const today = (new Date()).toISOString().split('T')[0]
    const dates = { created: today, updated: today }


    const nonExt = message.filename.split('.').slice(0, -1).join()
    const shreds = nonExt.split('_')
    if (Date.parse(shreds[0])) {
      dates.created = shreds[0]
    }
    return dates
  }




  extractTitle(message) {
    let title = 'Title'
    let match = message.content.toString().match(/^#(.*)$/m)
    let contentTitle = match ? match[1].trim() : null
    if (contentTitle) {
      title = contentTitle.replaceAll('#', '') // TODO make nicer
      return title
    }

    // derive from filename
    // eg. 2024-04-19_hello-postcraft.md
    try {
      const nonExt = message.filename.split('.').slice(0, -1).join()
      const shreds = nonExt.split('_')


      title = shreds[1].split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ')
    } catch (err) {
      title = message.filename
    }
    return title
  }
}

export default PostcraftPrep

================
File: src/processors/postcraft/PostcraftProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import PostcraftDispatcher from './PostcraftDispatcher.js'
import PostcraftPrep from './PostcraftPrep.js'
import EntryContentToPagePrep from './EntryContentToPagePrep.js'
import FrontPagePrep from './FrontPagePrep.js'
import AtomFeedPrep from './AtomFeedPrep.js'

class PostcraftProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.PostcraftDispatcher)) {
            return new PostcraftDispatcher(config)
        }
        if (type.equals(ns.trn.PostcraftPrep)) {
            return new PostcraftPrep(config)
        }
        if (type.equals(ns.trn.EntryContentToPagePrep)) {
            return new EntryContentToPagePrep(config)
        }
        if (type.equals(ns.trn.FrontPagePrep)) {
            return new FrontPagePrep(config)
        }
        if (type.equals(ns.trn.AtomFeedPrep)) {
            return new AtomFeedPrep(config)
        }
        return false
    }
}

export default PostcraftProcessorsFactory

================
File: src/processors/protocols/HttpGet.js
================
import axios from 'axios'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'

import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class HttpGet extends Processor {
    constructor(config) {
        super(config)
    }







    async process(url, message) {

        logger.debug('HttpGet, url = ' + url)
        if (url === '~~done~~') {
            logger.log('HG DONE*****************')
            return this.emit('message', url, message)
            return
        }
        try {
            logger.log('HG GETTING*****************')
            const response = await axios.get(url)
            const content = response.data

            message.sourceURL = url
            return this.emit('message', content, message)
        } catch (error) {
            logger.error("HttpGet.execute error\n" + error)
        }
    }
}

export default HttpGet

================
File: src/processors/protocols/ProtocolsProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import HttpGet from './HttpGet.js'



class ProtocolsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.HttpGet)) {
            return new HttpGet(config)
        }

        return false
    }
}

export default ProtocolsProcessorsFactory

================
File: src/processors/rdf/ConfigMap.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import path from 'path'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ConfigMap extends Processor {
  constructor(config) {
    super(config)
  }

  async process(message) {








    logger.debug(`ConfigMap.process`)
    this.showMyConfig()

    const basePath = message.targetPath || message.rootDir
    logger.debug(`ConfigMap using base path: ${basePath}`)

    const dataset = message.dataset
    const poi = grapoi({ dataset })


    for (const quad of poi.out(ns.rdf.type, ns.trn.ConfigSet).quads()) {
      const groupID = quad.subject

      let groupName = ns.getShortname(groupID.value)

      logger.debug(`*** groupName = ${groupName} `)


      const groupPoi = grapoi({ dataset, term: groupID })

      if (!message.contentGroup) message.contentGroup = {}

      if (groupPoi.out(ns.trn.sourceDirectory).term) {
        let sourceDir = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.sourceDirectory).term.value)

        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].sourceDir = sourceDir
      }

      if (groupPoi.out(ns.trn.targetDirectory).term) {
        let targetDir = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.targetDirectory).term.value
        )
        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].targetDir = targetDir
      }

      if (groupPoi.out(ns.trn.template).term) {
        let templateFile = this.resolvePath(
          basePath,
          groupPoi.out(ns.trn.template).term.value
        )
        if (!message.contentGroup[groupName]) message.contentGroup[groupName] = {}
        message.contentGroup[groupName].templateFile = templateFile
      }













    }


    return this.emit('message', message)
  }

  resolvePath(basePath, relativePath) {
    if (!basePath || !relativePath) {
      throw new Error('Base path and relative path required')
    }

    const resolved = path.isAbsolute(relativePath)
      ? relativePath
      : path.join(basePath, relativePath)

    return path.normalize(resolved)
  }
}

export default ConfigMap

================
File: src/processors/rdf/DatasetReader.js
================
import path from 'path';
import rdf from 'rdf-ext';
import { fromFile } from 'rdf-utils-fs';
import ns from '../../utils/ns.js';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';

class DatasetReader extends Processor {
    constructor(config) {
        super(config);
    }

    async process(message) {
        try {
            const datasetFile = this.getPropertyFromMyConfig(ns.trn.datasetFile);
            const datasetPath = path.join(message.rootDir, datasetFile);

            logger.debug(`Reading dataset from ${datasetPath}`);
            const stream = fromFile(datasetPath);
            message.dataset = await rdf.dataset().import(stream);

            if (message.dataset.size === 0) {
                logger.warn('Empty dataset loaded');
            } else {
                logger.debug(`Loaded dataset with ${message.dataset.size} quads`);
            }

            return this.emit('message', message);
        } catch (err) {
            logger.error('Failed to read dataset:', err);
            throw err;
        }
    }
}

export default DatasetReader;

================
File: src/processors/rdf/RDFConfig.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class RDFConfig extends Processor {
  constructor(config) {
    super(config)
    this.configMap = new Map()
  }

  async process(message) {
    if (!message.dataset) {
      throw new Error('No RDF dataset provided')
    }

    const dataset = message.dataset
    const poi = grapoi({ dataset })


    for (const configGroup of poi.out(ns.rdf.type, ns.trn.ConfigGroup).terms) {
      const groupPoi = grapoi({ dataset, term: configGroup })


      const mappings = {}
      for (const quad of groupPoi.quads()) {
        if (!quad.predicate.equals(ns.rdf.type)) {
          mappings[quad.predicate.value] = this.resolveValue(quad.object)
        }
      }

      this.configMap.set(configGroup.value, mappings)
      message.configMap = this.configMap
    }


    if (message.configPatterns) {
      for (const pattern of message.configPatterns) {
        const config = this.configMap.get(pattern)
        if (config) {
          Object.assign(message, config)
        }
      }
    }

    return this.emit('message', message)
  }

  resolveValue(term) {

    if (term.termType === 'NamedNode') {
      return term.value
    } else if (term.termType === 'Literal') {
      const value = term.value

      return isNaN(value) ? value : Number(value)
    }
    return term.value
  }

  getConfig(groupId) {
    return this.configMap.get(groupId)
  }
}

export default RDFConfig

================
File: src/processors/rdf/RDFProcessorsFactory.js
================
import ns from '../../utils/ns.js'
import DatasetReader from './DatasetReader.js'
import ConfigMap from './ConfigMap.js'
import RDFConfig from './RDFConfig.js'

class RDFProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.DatasetReader)) {
            return new DatasetReader(config)
        }
        if (type.equals(ns.trn.ConfigMap)) {
            return new ConfigMap(config)
        }
        if (type.equals(ns.trn.RDFConfig)) {
            return new RDFConfig(config)
        }
        return false
    }
}

export default RDFProcessorsFactory

================
File: src/processors/sparql/component-interaction.mermaid
================
sequenceDiagram
    participant C as Client
    participant V as Validator
    participant T as Template Engine
    participant U as TextUtils
    participant L as LanguageConfig
    
    C->>V: validate(message)
    activate V
    V->>L: checkLanguageTags()
    V->>U: validateURLs()
    V-->>C: ValidationResult
    deactivate V
    
    alt validation passed
        C->>T: render(message)
        activate T
        T->>U: escapeStringLiteral()
        T->>L: getLanguageConfig()
        T->>U: escapeIRI()
        T-->>C: turtleRDF
        deactivate T
    else validation failed
        C->>C: handleError()
    end

================
File: src/processors/sparql/config.js
================
export const config = {
    baseUrl: 'http://example.com',
    requiredFields: ['slug', 'title'],
    dateFormat: 'YYYY-MM-DDThh:mm:ssZ',

    setBaseUrl(url) {
        if (!url.startsWith('http')) {
            throw new Error('Base URL must start with http(s)');
        }
        this.baseUrl = url;
    }
};

================
File: src/processors/sparql/custom-predicates.js
================
export const customPredicates = {
    validate(predicate, value) {
        if (!this[predicate]) {
            throw new Error(`Unknown predicate: ${predicate}`);
        }
        return this[predicate].validate(value);
    },

    format(predicate, value) {
        return this[predicate].format(value);
    },

    category: {
        validate: value => typeof value === 'string' && value.length > 0,
        format: value => `schema:category "${value}"`
    },

    keywords: {
        validate: value => Array.isArray(value) && value.every(v => typeof v === 'string'),
        format: value => value.map(keyword => `schema:keywords "${keyword}"`).join(' ; ')
    },

    license: {
        validate: value => typeof value === 'string' && value.startsWith('http'),
        format: value => `schema:license <${value}>`
    }
}

================
File: src/processors/sparql/handover-doc (1).md
================
# RDF Turtle Template System

## System Overview

A templating system for generating RDF Turtle syntax from JavaScript objects, with support for multilingual content, custom predicates, and configurable validation rules.

### System Architecture
The system follows a modular architecture with clear separation of concerns:

![System Architecture](system-architecture)

### Processing Flow
Message processing follows a strict validation and transformation pipeline:

![Message Processing Flow](message-processing-flow)

### Component Interactions
Components interact through well-defined interfaces:

![Component Interaction Sequence](component-interaction)

### Language Processing
Multilingual content follows a deterministic processing flow:

![Language Processing Flow](language-processing)

### Core Components

1. **Template Engine**: Nunjucks-based template for RDF generation
2. **TextUtils**: String manipulation and escaping utilities
3. **Validator**: Input validation and sanitization
4. **Configuration**: System-wide settings management
5. **Language Handling**: BCP47 language tag support

## Architecture

### Module Structure

```
src/
 templates/
    turtle.njk         # Main Nunjucks template
 lib/
    TextUtils.js       # Text processing utilities
    Validator.js       # Validation logic
    Config.js          # Configuration management
    CustomPredicates.js # Custom RDF predicate handling
 config/
     languageConfig.js  # Language-specific settings
```

## Implementation Details

### Data Model

Input messages follow this structure:

```javascript
interface Message {
    slug: string;
    title: string | LocalizedString;
    content: string | LocalizedString;
    summary?: string | LocalizedString;
    datePublished?: string;  // ISO 8601
    dateModified?: string;   // ISO 8601
    author?: Author;
    translations?: Translations;
    customProperties?: CustomProperties;
}

interface LocalizedString {
    value: string;
    lang: string;  // BCP47 language tag
}

interface Author {
    name: string;
    homepage?: string;
    nick?: string;
}

interface Translations {
    [field: string]: {
        [lang: string]: string;
    };
}
```

### Usage Examples

#### Basic Usage

```javascript
import { MessageValidator } from './lib/Validator';
import { config } from './lib/Config';
import nunjucks from 'nunjucks';

const message = {
    slug: 'example-post',
    title: {
        value: 'Example Post',
        lang: 'en'
    },
    content: 'Post content',
    author: {
        name: 'John Doe',
        homepage: 'https://example.com/john'
    }
};

// Validate input
const validation = MessageValidator.validate(message);
if (!validation.isValid) {
    throw new Error(`Invalid message: ${validation.errors.join(', ')}`);
}

// Generate Turtle
const turtle = nunjucks.render('turtle.njk', { message });
```

#### Multilingual Content

```javascript
const multilingualMessage = {
    slug: 'multilingual-post',
    title: {
        value: 'Hello World',
        lang: 'en'
    },
    translations: {
        title: {
            'es': 'Hola Mundo',
            'fr': 'Bonjour le Monde'
        },
        content: {
            'es': 'Contenido del post',
            'fr': 'Contenu du post'
        }
    }
};
```

#### Custom Predicates

```javascript
// Adding custom predicates
import { customPredicates } from './lib/CustomPredicates';

customPredicates.category = {
    validate: value => typeof value === 'string' && value.length > 0,
    format: value => `schema:category "${value}"`
};

const messageWithCustom = {
    // ... basic fields ...
    customProperties: {
        category: 'Technology'
    }
};
```

## Validation Rules

### Required Fields
- slug
- title
- content

### Field-Specific Validation

```javascript
const validationRules = {
    slug: {
        pattern: /^[a-z0-9-]+$/,
        maxLength: 100
    },
    datePublished: {
        format: 'ISO8601',
        required: false
    },
    author: {
        type: 'object',
        properties: {
            name: { required: true },
            homepage: { type: 'url', required: false }
        }
    }
};
```

## Language Handling

### Configuration

```javascript
// languageConfig.js
export const languageConfig = {
    defaultLanguage: 'en',
    supportedLanguages: ['en', 'es', 'fr', 'de'],
    languageFields: {
        title: ['en', 'es', 'fr', 'de'],
        content: ['en', 'es', 'fr']
    }
};
```

### BCP47 Validation

All language tags are validated against BCP47 specifications using the following regex:
```javascript
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
```

## Output Format

The system generates Turtle RDF following W3C specifications. Example output:

```turtle
@prefix schema: <http://schema.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://example.com/example-post> a schema:Article ;
    schema:headline "Example Post"@en ;
    schema:articleBody "Post content"@en ;
    schema:author [
        a schema:Person ;
        schema:name "John Doe" ;
        foaf:homepage <https://example.com/john>
    ] .
```

## Error Handling

Errors are handled through a structured validation system:

```javascript
interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}

// Example error handling
try {
    const validation = MessageValidator.validate(message);
    if (!validation.isValid) {
        logger.error('Validation failed:', validation.errors);
        throw new ValidationError(validation.errors);
    }
} catch (error) {
    if (error instanceof ValidationError) {
        // Handle validation errors
    } else {
        // Handle other errors
    }
}
```

## Testing

Tests are written using Jasmine. Run with:
```bash
npm test
```

Key test areas:
- Input validation
- RDF generation
- Language tag handling
- Custom predicate processing
- Error handling

## Configuration Options

System-wide settings are managed through the Config module:

```javascript
config.setBaseUrl('https://example.com');
config.setDefaultLanguage('en');
config.addRequiredField('category');
```

## Performance Considerations

- Template compilation is cached
- Language tag validation uses regex for speed
- String escaping is optimized for common cases
- Validation runs only once per message

## Known Limitations

1. No support for RDF lists
2. Limited datatype handling
3. No blank node reference support
4. Single-document processing only

## Future Enhancements

1. Graph merging support
2. Extended datatype handling
3. Streaming processing for large datasets
4. SHACL validation integration

## Maintenance Notes

1. Update language tags when adding new languages
2. Monitor template performance with large datasets
3. Regular validation of IRIs against service health
4. Review custom predicate implementations

## Dependencies

- nunjucks: ^3.2.0
- loglevel: ^1.8.0
- validator: ^13.7.0

================
File: src/processors/sparql/handover-doc.md
================
# RDF Turtle Template System

## System Overview

A templating system for generating RDF Turtle syntax from JavaScript objects, with support for multilingual content, custom predicates, and configurable validation rules.

### System Architecture
The system follows a modular architecture with clear separation of concerns:

![System Architecture](system-architecture)

### Processing Flow
Message processing follows a strict validation and transformation pipeline:

![Message Processing Flow](message-processing-flow)

### Component Interactions
Components interact through well-defined interfaces:

![Component Interaction Sequence](component-interaction)

### Language Processing
Multilingual content follows a deterministic processing flow:

![Language Processing Flow](language-processing)

### Core Components

1. **Template Engine**: Nunjucks-based template for RDF generation
2. **TextUtils**: String manipulation and escaping utilities
3. **Validator**: Input validation and sanitization
4. **Configuration**: System-wide settings management
5. **Language Handling**: BCP47 language tag support

## Architecture

### Module Structure

```
src/
 templates/
    turtle.njk         # Main Nunjucks template
 lib/
    TextUtils.js       # Text processing utilities
    Validator.js       # Validation logic
    Config.js          # Configuration management
    CustomPredicates.js # Custom RDF predicate handling
 config/
     languageConfig.js  # Language-specific settings
```

## Implementation Details

### Data Model

Input messages follow this structure:

```javascript
interface Message {
    slug: string;
    title: string | LocalizedString;
    content: string | LocalizedString;
    summary?: string | LocalizedString;
    datePublished?: string;  // ISO 8601
    dateModified?: string;   // ISO 8601
    author?: Author;
    translations?: Translations;
    customProperties?: CustomProperties;
}

interface LocalizedString {
    value: string;
    lang: string;  // BCP47 language tag
}

interface Author {
    name: string;
    homepage?: string;
    nick?: string;
}

interface Translations {
    [field: string]: {
        [lang: string]: string;
    };
}
```

### Usage Examples

#### Basic Usage

```javascript
import { MessageValidator } from './lib/Validator';
import { config } from './lib/Config';
import nunjucks from 'nunjucks';

const message = {
    slug: 'example-post',
    title: {
        value: 'Example Post',
        lang: 'en'
    },
    content: 'Post content',
    author: {
        name: 'John Doe',
        homepage: 'https://example.com/john'
    }
};

// Validate input
const validation = MessageValidator.validate(message);
if (!validation.isValid) {
    throw new Error(`Invalid message: ${validation.errors.join(', ')}`);
}

// Generate Turtle
const turtle = nunjucks.render('turtle.njk', { message });
```

#### Multilingual Content

```javascript
const multilingualMessage = {
    slug: 'multilingual-post',
    title: {
        value: 'Hello World',
        lang: 'en'
    },
    translations: {
        title: {
            'es': 'Hola Mundo',
            'fr': 'Bonjour le Monde'
        },
        content: {
            'es': 'Contenido del post',
            'fr': 'Contenu du post'
        }
    }
};
```

#### Custom Predicates

```javascript
// Adding custom predicates
import { customPredicates } from './lib/CustomPredicates';

customPredicates.category = {
    validate: value => typeof value === 'string' && value.length > 0,
    format: value => `schema:category "${value}"`
};

const messageWithCustom = {
    // ... basic fields ...
    customProperties: {
        category: 'Technology'
    }
};
```

## Validation Rules

### Required Fields
- slug
- title
- content

### Field-Specific Validation

```javascript
const validationRules = {
    slug: {
        pattern: /^[a-z0-9-]+$/,
        maxLength: 100
    },
    datePublished: {
        format: 'ISO8601',
        required: false
    },
    author: {
        type: 'object',
        properties: {
            name: { required: true },
            homepage: { type: 'url', required: false }
        }
    }
};
```

## Language Handling

### Configuration

```javascript
// languageConfig.js
export const languageConfig = {
    defaultLanguage: 'en',
    supportedLanguages: ['en', 'es', 'fr', 'de'],
    languageFields: {
        title: ['en', 'es', 'fr', 'de'],
        content: ['en', 'es', 'fr']
    }
};
```

### BCP47 Validation

All language tags are validated against BCP47 specifications using the following regex:
```javascript
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
```

## Output Format

The system generates Turtle RDF following W3C specifications. Example output:

```turtle
@prefix schema: <http://schema.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://example.com/example-post> a schema:Article ;
    schema:headline "Example Post"@en ;
    schema:articleBody "Post content"@en ;
    schema:author [
        a schema:Person ;
        schema:name "John Doe" ;
        foaf:homepage <https://example.com/john>
    ] .
```

## Error Handling

Errors are handled through a structured validation system:

```javascript
interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}

// Example error handling
try {
    const validation = MessageValidator.validate(message);
    if (!validation.isValid) {
        logger.error('Validation failed:', validation.errors);
        throw new ValidationError(validation.errors);
    }
} catch (error) {
    if (error instanceof ValidationError) {
        // Handle validation errors
    } else {
        // Handle other errors
    }
}
```

## Testing

Tests are written using Jasmine. Run with:
```bash
npm test
```

Key test areas:
- Input validation
- RDF generation
- Language tag handling
- Custom predicate processing
- Error handling

## Configuration Options

System-wide settings are managed through the Config module:

```javascript
config.setBaseUrl('https://example.com');
config.setDefaultLanguage('en');
config.addRequiredField('category');
```

## Performance Considerations

- Template compilation is cached
- Language tag validation uses regex for speed
- String escaping is optimized for common cases
- Validation runs only once per message

## Known Limitations

1. No support for RDF lists
2. Limited datatype handling
3. No blank node reference support
4. Single-document processing only

## Future Enhancements

1. Graph merging support
2. Extended datatype handling
3. Streaming processing for large datasets
4. SHACL validation integration

## Maintenance Notes

1. Update language tags when adding new languages
2. Monitor template performance with large datasets
3. Regular validation of IRIs against service health
4. Review custom predicate implementations

## Dependencies

- nunjucks: ^3.2.0
- loglevel: ^1.8.0
- validator: ^13.7.0

================
File: src/processors/sparql/handover-metadata.txt
================
@prefix schema: <http://schema.org/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix prov: <http://www.w3.org/ns/prov#> .

<http://example.com/docs/turtle-template-system>
    a schema:TechArticle ;
    dcterms:title "RDF Turtle Template System - Technical Documentation" ;
    dcterms:created "2025-01-25T00:00:00Z"^^xsd:dateTime ;
    dcterms:description "Technical documentation for the RDF Turtle templating system including architecture, implementation details, and usage examples." ;
    schema:version "1.0" ;
    schema:keywords "RDF", "Turtle", "Template", "Multilingual", "Validation" ;
    
    schema:programmingLanguage "JavaScript" ;
    schema:codeRepository "https://example.com/repo/turtle-template" ;
    
    prov:wasDerivedFrom [
        a schema:SoftwareSourceCode ;
        schema:name "Turtle Template System" ;
        schema:programmingLanguage "JavaScript" ;
        schema:softwareVersion "1.0.0"
    ] ;
    
    dcterms:requires [
        a schema:SoftwareApplication ;
        schema:name "Node.js" ;
        schema:softwareVersion ">=14.0.0"
    ] ;
    
    schema:maintainer [
        a schema:Person ;
        schema:name "Development Team" ;
        schema:email "team@example.com"
    ] .

================
File: src/processors/sparql/language-processing.mermaid
================
flowchart LR
    Input[Input String] --> HasLang{Has Language?}
    HasLang --> |Yes| ValidLang{Valid BCP47?}
    HasLang --> |No| DefLang{Default Language?}
    
    ValidLang --> |Yes| AddTag[Add Language Tag]
    ValidLang --> |No| Error[Language Error]
    
    DefLang --> |Yes| NonLangField{Non-Language Field?}
    DefLang --> |No| Plain[Plain Literal]
    
    NonLangField --> |Yes| Plain
    NonLangField --> |No| AddDefTag[Add Default Tag]
    
    AddTag --> Escape[Escape String]
    AddDefTag --> Escape
    Plain --> Escape
    
    Escape --> Output[RDF Literal]
    
    class Input,Output borderbox
    class Error emphasis

================
File: src/processors/sparql/message-processing-flow.mermaid
================
flowchart TB
    Input[Message Input] --> Validate{Validate}
    Validate --> |Invalid| Error[Validation Error]
    Validate --> |Valid| Transform[Transform to RDF]
    
    subgraph Validation
        V1[Check Required Fields] --> V2[Validate Types]
        V2 --> V3[Check Language Tags]
        V3 --> V4[Validate URLs]
        V4 --> V5[Custom Predicates]
    end
    
    subgraph Transform
        T1[Load Template] --> T2[Process Message]
        T2 --> T3[Generate Triples]
        T3 --> T4[Format Output]
    end
    
    Transform --> Output[Turtle RDF]
    
    class Input,Output,Error borderbox
    class Validation,Transform subdomain

================
File: src/processors/sparql/SessionEnvironment.js
================
import axios from 'axios'
import nunjucks from 'nunjucks'
import fs from 'fs/promises'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

class SessionEnvironment {
    constructor(processor) {
        this.processor = processor
        this.endpoints = null
        this.templateCache = new Map()
    }

    async loadEndpoints(dir) {

        logger.debug(`SessionEnvironment.loadEndpoints dir = ${dir}`)
        const settingsPath = this.processor.getProperty(ns.trn.endpointSettings)
        logger.debug(`SessionEnvironment.loadEndpoints dir = ${dir}`)
        logger.debug(`SessionEnvironment.loadEndpoints settingsPath = ${settingsPath}`)

        if (!settingsPath) {
            throw new Error('Endpoint settings path is undefined')
        }

        const filePath = path.join(dir, settingsPath)
        logger.debug(`SessionEnvironment.loadEndpoints filePath = ${filePath}`)
        const data = await fs.readFile(filePath, 'utf8')
        this.endpoints = JSON.parse(data)
    }

    getQueryEndpoint() {
        return this.endpoints.find(e => e.type === 'query')
    }

    getUpdateEndpoint() {
        return this.endpoints.find(e => e.type === 'update')
    }

    async getTemplate(dir, templateFilename) {
        logger.setLogLevel('debug')
        logger.debug(`SessionEnvironment.getTemplate dir = ${dir}`)
        logger.debug(`SessionEnvironment.getTemplate templateFilename = ${templateFilename}`)

        const cacheKey = path.join(dir, templateFilename)

        if (this.templateCache.has(cacheKey)) {
            return this.templateCache.get(cacheKey)
        }

        const template = await fs.readFile(cacheKey, 'utf8')
        this.templateCache.set(cacheKey, template)
        logger.debug(`SessionEnvironment.getTemplate cacheKey = ${cacheKey}`)
        logger.debug(`SessionEnvironment.getTemplate template = ${template}`)
        return template
    }

    clearTemplateCache() {
        this.templateCache.clear()
    }





    getBasicAuthHeader(endpoint) {
        return `Basic ${Buffer.from(
            `${endpoint.credentials.user}:${endpoint.credentials.password}`
        ).toString('base64')}`
    }
}

export default SessionEnvironment

================
File: src/processors/sparql/SPARQLProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import SPARQLSelect from './SPARQLSelect.js'
import SPARQLUpdate from './SPARQLUpdate.js'









class SPARQLProcessorsFactory {

    static createProcessor(type, config) {

        if (type.equals(ns.trn.SPARQLSelect)) {
            return new SPARQLSelect(config)
        }
        if (type.equals(ns.trn.SPARQLUpdate)) {
            return new SPARQLUpdate(config)
        }

        return false
    }
}
export default SPARQLProcessorsFactory

================
File: src/processors/sparql/SPARQLSelect.js
================
import axios from 'axios';
import nunjucks from 'nunjucks';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';
import SessionEnvironment from './SessionEnvironment.js';

class SPARQLSelect extends Processor {
    constructor(config) {
        super(config);
        this.env = new SessionEnvironment(this);
    }

    async process(message) {
        if (!this.env.endpoints) {
            await this.env.loadEndpoints(message.rootDir);
        }

        const endpoint = this.env.getQueryEndpoint();
        const template = await this.env.getTemplate(
            message.rootDir,
            await this.getProperty(ns.trn.templateFilename)
        );

        const queryData = {
            startDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
            ...message
        };

        const query = nunjucks.renderString(template, queryData);

        try {
            const response = await axios.post(endpoint.url, query, {
                headers: {
                    'Content-Type': 'application/sparql-query',
                    'Accept': 'application/json',
                    'Authorization': this.env.getBasicAuthHeader(endpoint)
                }
            });

            message.queryResults = response.data;
            return this.emit('message', message);
        } catch (error) {
            logger.error('SPARQL query error:', error);
            throw error;
        }
    }
}

export default SPARQLSelect;

================
File: src/processors/sparql/SPARQLUpdate.js
================
import axios from 'axios'
import nunjucks from 'nunjucks'
import crypto from 'crypto'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import SessionEnvironment from './SessionEnvironment.js'

class SPARQLUpdate extends Processor {
    constructor(config) {
        super(config)
        this.env = new SessionEnvironment(this)
    }

    async process(message) {
        logger.setLogLevel('debug')
        logger.debug(`\nSPARQLUpdate.process`)


        if (!this.env.endpoints) {
            await this.env.loadEndpoints(message.rootDir)
        }


        const endpoint = this.env.getUpdateEndpoint()
        logger.debug(`SPARQLUpdate.process endpoint = ${endpoint}`)
        const template = await this.env.getTemplate(
            message.rootDir,
            await this.getProperty(ns.trn.templateFilename)
        )
        logger.debug(`SPARQLUpdate.process template = ${template}`)

        const now = new Date().toISOString()
        const updateData = {
            id: crypto.randomUUID(),
            title: message.meta?.title || 'Untitled Post',
            content: message.content,
            published: now,
            modified: now,
            author: {
                name: 'Danny',
                email: 'danny.ayers@gmail.com',
                url: 'https://danny.ayers.name'
            },
            ...message
        }
        logger.setLogLevel('debug')

        logger.debug(`renderString(template = ${template}
            updateData = ${updateData})`)
        const update = nunjucks.renderString(template, updateData)

        try {
            const response = await axios.post(endpoint.url, update, {
                headers: {
                    'Content-Type': 'application/sparql-update',
                    'Authorization': this.env.getBasicAuthHeader(endpoint)
                }
            })

            message.updateStatus = response.status === 200 ? 'success' : 'error'
            message.updateResponse = response.data

            return this.emit('message', message)
        } catch (error) {
            logger.error('SPARQL update error:', error)
            throw error
        }
    }
}

export default SPARQLUpdate

================
File: src/processors/sparql/system-architecture.mermaid
================
graph TB
    subgraph Core Components
        TE[Template Engine]
        TU[TextUtils]
        VAL[Validator]
    end
    
    subgraph Configuration
        CONF[Config]
        LANG[Language Config]
        PRED[Custom Predicates]
    end
    
    subgraph Input Processing
        MSG[Message]
        VAL_RES[Validation Result]
        RDF[RDF Output]
    end
    
    MSG --> VAL
    VAL --> VAL_RES
    VAL_RES --> TE
    TE --> RDF
    
    CONF --> TE
    CONF --> VAL
    
    LANG --> TE
    LANG --> VAL
    
    PRED --> VAL
    PRED --> TE
    
    TU --> TE
    TU --> VAL
    
    classDef core fill:#f9f,stroke:#333,stroke-width:2px
    classDef config fill:#bbf,stroke:#333,stroke-width:2px
    classDef process fill:#bfb,stroke:#333,stroke-width:2px
    
    class TE,TU,VAL core
    class CONF,LANG,PRED config
    class MSG,VAL_RES,RDF process

================
File: src/processors/sparql/validator.js
================
import { config } from './config.js';
import { TextUtils } from './TextUtils.js';
import { customPredicates } from './customPredicates.js';

export class MessageValidator {
    static validate(message) {
        const errors = [];


        for (const field of config.requiredFields) {
            if (!message[field]) {
                errors.push(`Missing required field: ${field}`);
            }
        }


        if (message.datePublished && !TextUtils.isValidDateTime(message.datePublished)) {
            errors.push('Invalid datePublished format');
        }

        if (message.dateModified && !TextUtils.isValidDateTime(message.dateModified)) {
            errors.push('Invalid dateModified format');
        }


        if (message.author?.homepage && !TextUtils.isValidURL(message.author.homepage)) {
            errors.push('Invalid author homepage URL');
        }


        if (message.customProperties) {
            for (const [prop, value] of Object.entries(message.customProperties)) {
                try {
                    if (!customPredicates.validate(prop, value)) {
                        errors.push(`Invalid value for custom predicate: ${prop}`);
                    }
                } catch (e) {
                    errors.push(e.message);
                }
            }
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }
}

================
File: src/processors/staging/MarkdownFormatter.js
================
import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class MarkdownFormatter extends Processor {
    constructor(config) {
        super(config)
    }

    async process(message) {

        if (message.done) return


        const dir = '/home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md'

        const filename = `${message.content.created_at.substring(0, 10)}_${message.content.uuid.substring(0, 3)}.md`

        message.filepath = path.join(dir, message.meta.conv_uuid.substring(0, 4), filename)
        message.content = this.extractMarkdown(message)

        return this.emit('message', message)
    }



    extractMarkdown(message) {

        const urlBase = 'https://claude.ai/chat/'

        const lines = []
        lines.push(`# [${message.meta.conv_name}](${urlBase}${message.meta.conv_uuid})\n`)

        lines.push(`${message.content.uuid}\n`)

        lines.push(message.content.text)
        lines.push('\n---\n')

        for (const [key, value] of Object.entries(message)) {
            if (key !== 'content' && value !== null) {
                if (value) {
                    const v = typeof value === 'object' ? JSON.stringify(value, null, 2) : value.toString()
                    lines.push(`* **${key}** : ${v}`)
                } else {
                    lines.push(`* **${key}** : [undefined]`)
                }
            }
        }

        return lines.join('\n')
    }

}

export default MarkdownFormatter

================
File: src/processors/staging/StagingProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import MarkdownFormatter from './MarkdownFormatter.js'
import TurtleFormatter from './TurtleFormatter.js'




class StagingProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.MarkdownFormatter)) {
            return new MarkdownFormatter(config)
        }
        if (type.equals(ns.trn.TurtleFormatter)) {
            return new TurtleFormatter(config)
        }
        return false
    }
}
export default StagingProcessorsFactory

================
File: src/processors/staging/TurtleFormatter.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class TurtleFormatter extends Processor {
    constructor(config) {
        super(config)
        this.baseURI = config.baseURI || 'http://example.org/'
    }

    async process(message) {
        try {
            const item = message.currentItem
            if (!item) {
                return
            }


            const turtle = this.formatTurtle(item)
            message.content = turtle
            message.targetFile = `${item.id}.ttl`

            this.emit('message', message)
        } catch (err) {
            logger.error("TurtleFormatter.execute error: " + err.message)
            throw err
        }
    }

    formatTurtle(item) {
        const lines = []
        lines.push('@prefix : <http://example.org/ns#> .')
        lines.push('@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .')
        lines.push('')

        const subject = `<${this.baseURI}${item.id}>`
        lines.push(`${subject} a :Item ;`)

        const entries = Object.entries(item)
        entries.forEach(([key, value], index) => {
            if (value !== null) {
                const isLast = index === entries.length - 1
                const literal = typeof value === 'string' ?
                    `"${value.replace(/"/g, '\\"')}"` :
                    `"${JSON.stringify(value)}"`
                lines.push(`    :${key} ${literal}${isLast ? ' .' : ' ;'}`)
            }
        })

        return lines.join('\n')
    }
}

export default TurtleFormatter

================
File: src/processors/system/EnvLoader.js
================
import 'dotenv/config'



import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'














class EnvLoader extends Processor {





    constructor(config) {
        super(config)
    }





    async process(message) {



        this.config.whiteboard.env = process.env

        return this.emit("message", message)
    }
}

export default EnvLoader

================
File: src/processors/system/SystemProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'


import EnvLoader from './EnvLoader.js'



class SystemsProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.EnvLoader)) {
            return new EnvLoader(config)
        }
        return false
    }
}
export default SystemsProcessorsFactory

================
File: src/processors/terrapack/comment-stripper.js
================
import path from 'path';

const LANGUAGE_PATTERNS = {
    js: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    jsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    ts: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    tsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    py: {
        single: '#',
        multi: { start: '"""', end: '"""' }
    },
    java: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    cpp: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    c: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    h: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    }
};

export function commentStripper(content, filepath) {
    const ext = path.extname(filepath).toLowerCase().slice(1);
    const patterns = LANGUAGE_PATTERNS[ext];

    if (!patterns) {
        return content;
    }

    let lines = content.split('\n');
    let inMultiLineComment = false;
    let result = [];

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();

        if (inMultiLineComment) {
            if (line.includes(patterns.multi.end)) {
                inMultiLineComment = false;
                line = line.split(patterns.multi.end)[1];
            } else {
                continue;
            }
        }

        if (patterns.multi && line.includes(patterns.multi.start)) {
            const parts = line.split(patterns.multi.start);
            if (!parts[1].includes(patterns.multi.end)) {
                inMultiLineComment = true;
                line = parts[0];
            } else {
                line = parts[0] + parts[1].split(patterns.multi.end)[1];
            }
        }

        if (patterns.single && line.startsWith(patterns.single)) {
            continue;
        }

        if (patterns.single) {
            const commentIndex = line.indexOf(patterns.single);
            if (commentIndex >= 0) {
                line = line.substring(0, commentIndex).trim();
            }
        }

        if (line.trim()) {
            result.push(line);
        }
    }

    return result.join('\n');
}

================
File: src/processors/terrapack/CommentStripper.js
================
import path from 'path';

const LANGUAGE_PATTERNS = {
    js: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    jsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    ts: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    tsx: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    py: {
        single: '#',
        multi: { start: '"""', end: '"""' }
    },
    java: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    cpp: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    c: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    },
    h: {
        single: '//',
        multi: { start: '/*', end: '*/' }
    }
};

export function commentStripper(content, filepath) {
    const ext = path.extname(filepath).toLowerCase().slice(1);
    const patterns = LANGUAGE_PATTERNS[ext];

    if (!patterns) {
        return content;
    }

    let lines = content.split('\n');
    let inMultiLineComment = false;
    let result = [];

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();

        if (inMultiLineComment) {
            if (line.includes(patterns.multi.end)) {
                inMultiLineComment = false;
                line = line.split(patterns.multi.end)[1];
            } else {
                continue;
            }
        }

        if (patterns.multi && line.includes(patterns.multi.start)) {
            const parts = line.split(patterns.multi.start);
            if (!parts[1].includes(patterns.multi.end)) {
                inMultiLineComment = true;
                line = parts[0];
            } else {
                line = parts[0] + parts[1].split(patterns.multi.end)[1];
            }
        }

        if (patterns.single && line.startsWith(patterns.single)) {
            continue;
        }

        if (patterns.single) {
            const commentIndex = line.indexOf(patterns.single);
            if (commentIndex >= 0) {
                line = line.substring(0, commentIndex).trim();
            }
        }

        if (line.trim()) {
            result.push(line);
        }
    }

    return result.join('\n');
}

================
File: src/processors/terrapack/file-container.js
================
import Processor from '../base/Processor.js';
import logger from '../../utils/Logger.js';
import ns from '../../utils/ns.js';
import path from 'path';

class FileContainer extends Processor {
    constructor(config) {
        super(config);
        this.container = {
            files: {},
            summary: {
                totalFiles: 0,
                fileTypes: {},
                timestamp: new Date().toISOString()
            }
        };
    }

    async process(message) {
        if (message.done) {
            message.content = JSON.stringify(this.container, null, 2);
            message.filepath = this.getPropertyFromMyConfig(ns.trn.destination);
            return this.emit('message', message);
        }

        if (!message.filepath || !message.content) {
            logger.warn('FileContainer: Missing filepath or content');
            return;
        }


        const targetDir = message.targetPath || message.rootDir;
        const relativePath = path.relative(targetDir, message.filepath);


        this.container.files[relativePath] = {
            content: message.content,
            type: path.extname(message.filepath),
            timestamp: new Date().toISOString()
        };


        this.container.summary.totalFiles++;
        const fileType = path.extname(message.filepath) || 'unknown';
        this.container.summary.fileTypes[fileType] = (this.container.summary.fileTypes[fileType] || 0) + 1;

        return this.emit('message', message);
    }
}

export default FileContainer;

================
File: src/processors/terrapack/FileContainer.js
================
import Processor from '../base/Processor.js'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import path from 'path'

class FileContainer extends Processor {
    constructor(config) {
        super(config)
        this.container = {
            files: {},
            summary: {
                totalFiles: 0,
                fileTypes: {},
                timestamp: new Date().toISOString()
            }
        }
    }

    async process(message) {

        message.filepath = await this.getProperty(ns.trn.destination)
        if (message.done) {


            message.filepath = message.filepath + '_done.txt'

            message.content = JSON.stringify(this.container, null, 2)


            return this.emit('message', message)
        }

        if (!message.filepath || !message.content) {
            logger.warn('FileContainer: Missing filepath or content')

            return
        }


        const targetDir = message.targetPath || message.rootDir
        const relativePath = path.relative(targetDir, message.filepath)


        this.container.files[relativePath] = {
            content: message.content,
            type: path.extname(message.filepath),
            timestamp: new Date().toISOString()
        }


        this.container.summary.totalFiles++
        const fileType = path.extname(message.filepath) || 'unknown'
        this.container.summary.fileTypes[fileType] = (this.container.summary.fileTypes[fileType] || 0) + 1

        return this.emit('message', message)
    }
}

export default FileContainer

================
File: src/processors/terrapack/terrapack-factory.js
================
import logger from '../../utils/Logger.js';
import ns from '../../utils/ns.js';
import FileContainer from './FileContainer.js';

class PackerProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.FileContainer)) {
            logger.debug('PackerProcessorsFactory: Creating FileContainer processor');
            return new FileContainer(config);
        }
        return false;
    }
}

export default PackerProcessorsFactory;

================
File: src/processors/terrapack/TerrapackProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import FileContainer from './FileContainer.js'

class TerrapackProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.trn.FileContainer)) {
            logger.debug('TerrapackProcessorsFactory: Creating FileContainer processor')
            return new FileContainer(config)
        }
        return false
    }
}

export default TerrapackProcessorsFactory

================
File: src/processors/test/_old/AppendProcess.js
================
import logger from '../../../utils/Logger.js'
import Processor from '../../base/Processor.js'

class AppendProcess extends Processor {


    async process(message) {
        logger.debug("AppendProcess data : " + message.content)
        message.content = message.content + " world"
        return this.emit('message', message)
    }
}

export default AppendProcess

================
File: src/processors/test/_old/FileSink.js
================
import path from 'path'
import { fileURLToPath } from 'url'

import { writeFile } from 'node:fs/promises'
import footpath from '../../../utils/footpath.js'
import grapoi from 'grapoi'
import ns from '../../../utils/ns.js'
import logger from '../../../utils/Logger.js'
import Processor from '../../base/Processor.js'

class FileSink extends Processor {

    constructor(config) {
        super(config)
        const dataset = this.config
        const poi = grapoi({ dataset })
        this.destinationFile = poi.out(ns.trn.destinationFile).value
    }


    async process(message) {
        const toRootDir = '../../../'
        const dataDir = path.join(toRootDir, message.dataDir)
        const df = footpath.resolve(import.meta.url, dataDir, this.destinationFile)
        logger.debug("FileSink to = " + df)
        await writeFile(df, message.content)
        return this.emit('message', message)
    }
}

export default FileSink

================
File: src/processors/test/_old/FileSource.js
================
import path from 'path'
import { fileURLToPath } from 'url'

import { readFile } from 'node:fs/promises'

import footpath from '../../../utils/footpath.js'
import rdf from 'rdf-ext'

import grapoi from 'grapoi'
import ns from '../../../utils/ns.js'

import logger from '../../../utils/Logger.js'
import Processor from '../../base/Processor.js'

class FileSource extends Processor {

    constructor(config) {
        super(config)
        const dataset = this.config
        const poi = grapoi({ dataset })
        this.sourceFile = poi.out(ns.trn.sourceFile).value
    }


    async process(message) {
        try {
            const toRootDir = '../../../'
            const dataDir = toRootDir + message.dataDir
            const sf = footpath.resolve(import.meta.url, dataDir, this.sourceFile)
            logger.debug('FileSource file : ' + sf)
            const contents = await readFile(sf, { encoding: 'utf8' })
            logger.debug('FileSource data : ' + contents)
            return this.emit('message', { content: contents, ...message })
        } catch (err) {
            logger.error("FileSource.execute error : " + err.message)
        }
    }
}

export default FileSource

================
File: src/processors/test/_old/StringSink.js
================
import logger from '../../../utils/Logger.js'
import Processor from '../../base/Processor.js'

class StringSink extends Processor {

    process(message) {
        logger.log("\n\nStringSink outputs : \"" + message + "\"\n\n")
    }
}

export default StringSink

================
File: src/processors/test/_old/StringSource.js
================
import Processor from '../../base/Processor.js'

class StringSource extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {
        console.log("message = " + message)
        console.log("data = " + data)
        return this.emit('message', message)
    }
}

export default StringSource

================
File: src/processors/test/_old/TestProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import StringSource from './_old/StringSource.js'
import StringSink from './_old/StringSink.js'
import AppendProcess from './_old/AppendProcess.js'
import FileSource from './_old/FileSource.js'
import FileSink from './_old/FileSink.js'



class TestProcessorsFactory {
    static createProcessor(type, config) {



        if (type.equals(ns.trn.StringSource)) {
            return new StringSource(config)
        }
        if (type.equals(ns.trn.StringSink)) {
            return new StringSink(config)
        }
        if (type.equals(ns.trn.AppendProcess)) {
            return new AppendProcess(config)
        }


        if (type.equals(ns.trn.FileSource)) {
            return new FileSource(config)
        }
        if (type.equals(ns.trn.FileSink)) {
            return new FileSink(config)
        }

        return false
    }
}

export default TestProcessorsFactory

================
File: src/processors/test/TestProcessorsFactory.js
================
import ns from '../../utils/ns.js'

import TestSettings from './TestSettings.js'

class TestProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.TestSettings)) {
            return new TestSettings(config)
        }
        return false
    }
}

export default TestProcessorsFactory

================
File: src/processors/test/TestSettings.js
================
import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class TestSettings extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {

        logger.debug(`\n\nTestSettings.process`)



        const me = this.getProperty(ns.trn.me, 'default me')
        logger.log(`\nI am ${me}`)

        switch (me) {
            case ':settingsUseMessage':
                message.test = 'this came from message'
                logger.log(`${this.getProperty(ns.trn.test)}`)
                break

            case ':settingsSingle':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                break

            case ':settingsURI':
                logger.log(`${this.getProperty(ns.trn.uri)}`)
                break

            case ':settingsPath':


                logger.log(`${this.getProperty(ns.trn.path)}`)
                break

            case ':settingsMulti':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                logger.log(`${this.getProperty(ns.trn.uri)}`)
                break


            case ':settingsKeyValue':
                logger.log(`${this.getProperty(ns.trn.name)}`)
                break

            case ':settingsLists':
                logger.log(`aSetting : \n${this.getProperty(ns.trn.aSetting)}`)
                logger.log(`bSetting : \n${this.getProperty(ns.trn.bSetting)}`)
                break

            default:
                logger.log(`This is fallback : ${this.getProperty(ns.trn.name, 'yes it is')}`)
                break
        }


        return this.emit('message', message)
    }
}
export default TestSettings

================
File: src/processors/text/LineReader.js
================
import { readFile } from 'node:fs/promises'
import grapoi from 'grapoi'
import ns from '../../utils/ns.js'
import footpath from '../../utils/footpath.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class LineReader extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {

        const text = data.toString()


        const lines = text.split('\n')
        for await (let line of lines) {
            if (line.trim() && !line.startsWith('#')) {
                logger.debug('Line = [[[' + line + ']]]')
                return this.emit('message', line, message)
            }
        }

        return this.emit('message', '~~done~~', message)
    }
}

export default LineReader

================
File: src/processors/text/StringFilter.js
================
import path from 'path'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'
import StringUtils from '../../utils/StringUtils.js'

class StringFilter extends Processor {
    constructor(config) {
        super(config)
    }


    async process(message) {
        if (message.done) {
            return this.emit('message', message)
        }

        if (!message.filepath) {
            logger.warn('StringFilter: No filepath provided')
            return
        }
        this.includePatterns = this.getValues(ns.trn.includePattern)
        this.excludePatterns = this.getValues(ns.trn.excludePattern)

        if (this.isAccepted(message.filepath)) {
            return this.emit('message', message)
        }
    }
















    isAccepted(filePath) {
        if (!filePath) return false

        if (this.excludePatterns.length === 0 && this.includePatterns.length === 0) {
            return true
        }









        if (StringUtils.matchPatterns(filePath, this.excludePatterns)) {
            return false
        }

        if (StringUtils.matchPatterns(filePath, this.includePatterns)) {
            return true
        }













        return true
    }
}

export default StringFilter

================
File: src/processors/text/StringMerger.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'


class StringMerger extends Processor {
    constructor(config) {
        super(config)
        this.merged = ''
    }

    async process(message) {
        logger.log('SMDATA*********************************\n' + data)

        if (data === '~~done~~') {
            logger.log('SM  DONE**********************************\n' + this.merged)
            return this.emit('message', this.merged, message)
            return
        }
        this.merged = this.merged + data

    }
}

export default StringMerger

================
File: src/processors/text/StringReplace.js
================
import ns from '../../utils/ns.js'
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class StringReplace extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {

        const inputField = await this.getProperty(ns.trn.inputField)
        const outputField = await this.getProperty(ns.trn.outputField)

        var match = message.match ? message.match : await this.getProperty(ns.trn.match)
        var replace = message.replace ? message.replace : await this.getProperty(ns.trn.replace)

        var input = message.input ? message.input : message[inputField]
        if (!input) {
            input = message.content
        }

        logger.debug('StringReplace.process input = ' + input)


        const output = input.split(match).join(replace)

        logger.debug('StringReplace output: ' + output)
        try {
            message[outputField] = output
        } catch {
            message.content = output
        }
        return this.emit('message', message)
    }
}

export default StringReplace

================
File: src/processors/text/Templater.js
================
import Processor from '../base/Processor.js'
import nunjucks from 'nunjucks'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

class Templater extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {




        var templateFilename = await this.getProperty(ns.trn.templateFilename)

        logger.debug(`\nTemplater.process, templateFilename = ${templateFilename}`)


        if (templateFilename) {



            var targetPath = templateFilename.substr(0, templateFilename.lastIndexOf("/"))
            const filename = templateFilename.substr(templateFilename.lastIndexOf("/") + 1)

            if (!path.isAbsolute(targetPath)) {
                targetPath = path.join(await this.getProperty(ns.trn.targetPath, message.rootDir), targetPath)
            }

            logger.debug('\nTemplater, targetPath = ' + targetPath)
            logger.debug('Templater, filename = ' + filename)


            nunjucks.configure(targetPath, { autoescape: false })



            message.content = nunjucks.render(filename, message.contentBlocks)

            logger.debug(`content POST = ${message.content}`)


        } else {


            nunjucks.configure({ autoescape: false })



            message.content = nunjucks.renderString(message.template, message.contentBlocks)
        }

        return this.emit('message', message)
    }
}
export default Templater

================
File: src/processors/text/TextProcessorsFactory.js
================
import ns from '../../utils/ns.js'

import LineReader from './LineReader.js'
import StringFilter from './StringFilter.js'
import StringMerger from './StringMerger.js'
import StringReplace from './StringReplace.js'
import Templater from './Templater.js'

class TextProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.Templater)) {
            return new Templater(config)
        }
        if (type.equals(ns.trn.LineReader)) {
            return new LineReader(config)
        }

        if (type.equals(ns.trn.StringFilter)) {
            return new StringFilter(config)
        }

        if (type.equals(ns.trn.StringMerger)) {
            return new StringMerger(config)
        }

        if (type.equals(ns.trn.StringReplace)) {
            return new StringReplace(config)
        }





        return false
    }
}

export default TextProcessorsFactory

================
File: src/processors/unsafe/ExampleProcessor.js
================
import { readFile } from 'node:fs/promises'
import { access, constants } from 'node:fs'
import path from 'path'
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class ExampleProcessor extends Processor {
    constructor(config) {
        super(config)
    }





    async process(message) {
        logger.debug(`\n\nExampleProcessor.process`)



        if (message.done) {
            return this.emit('message', message)

        }




        const me = await this.getProperty(ns.trn.me)
        logger.log(`\nI am ${me}`)

        message.common = await this.getProperty(ns.trn.common)
        message.something1 = await this.getProperty(ns.trn.something1)

        message.something2 = await this.getProperty(ns.trn.something2)

        var added = await this.getProperty(ns.trn.added, '')
        message.something1 = message.something1 + added

        message.notavalue = await this.getProperty(ns.trn.notavalue, 'fallback value')


        return this.emit('message', message)
    }
}
export default ExampleProcessor

================
File: src/processors/unsafe/RunCommand.js
================
import { exec } from 'child_process';
import logger from '../../utils/Logger.js';
import Processor from '../base/Processor.js';
import ns from '../../utils/ns.js';

class RunCommand extends Processor {
    constructor(config) {
        super(config);
        this.allowedCommands = config.allowedCommands || [];
        this.blockedPatterns = config.blockedPatterns || [];
        this.timeout = config.timeout || 5000;
        this.initializeSecurity();
    }

    async initializeSecurity() {
        if (this.settings) {
            const allowed = await this.getPropertyFromMyConfig(ns.trn.allowedCommands);
            this.allowedCommands = allowed ? allowed.split(',') : [];

            const blocked = await this.getPropertyFromMyConfig(ns.trn.blockedPatterns);
            this.blockedPatterns = blocked ? blocked.split(',') : [];
        }
    }

    validateCommand(command) {
        if (!command) {
            throw new Error('No command specified');
        }

        const commandName = command.split(' ')[0];
        const isAllowed = this.allowedCommands.length === 0 ||
            this.allowedCommands.includes(commandName);

        if (!isAllowed) {
            throw new Error(`Command '${commandName}' not in allowed list`);
        }

        const hasBlocked = this.blockedPatterns.some(pattern =>
            command.includes(pattern)
        );
        if (hasBlocked) {
            throw new Error('Command contains blocked pattern');
        }
    }

    async process(message) {
        let command = message.command;
        if (!command) {
            command = this.getPropertyFromMyConfig(ns.trn.command);
        }

        try {
            this.validateCommand(command);
            const result = await this.executeCommand(command);
            message.content = result.stdout;
            message.commandResult = result;
            logger.debug(`Command executed successfully: ${command}`);
        } catch (error) {
            logger.error(`Command error: ${error.message}`);
            message.commandError = error.message;
            message.content = error.message;
            throw error;
        }

        return this.emit('message', message);
    }

    executeCommand(command) {
        return new Promise((resolve, reject) => {
            const child = exec(command, {
                timeout: this.timeout
            }, (error, stdout, stderr) => {
                if (error) {
                    if (error.signal === 'SIGTERM') {
                        reject(new Error('Command timeout'));
                    } else {
                        reject(error);
                    }
                    return;
                }
                resolve({
                    stdout: stdout.toString(),
                    stderr: stderr.toString(),
                    code: 0
                });
            });
        });
    }
}

export default RunCommand;

================
File: src/processors/unsafe/UnsafeProcessorsFactory.js
================
import ns from '../../utils/ns.js'


import RunCommand from './RunCommand.js'


class UnsafeProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.RunCommand)) {
            return new RunCommand(config)
        }

        return false
    }
}
export default UnsafeProcessorsFactory

================
File: src/processors/util/CaptureAll.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class CaptureAll extends Processor {
    constructor(config) {

        if (!config.whiteboard || !Array.isArray(config.whiteboard)) {
            config.whiteboard = []
        }
        super(config)

        if (CaptureAll.singleInstance) {
            return CaptureAll.singleInstance
        }
        CaptureAll.singleInstance = this
    }

    async process(message) {
        logger.debug(`CaptureAll at [${message.tags}] ${this.getTag()}, done=${message.done}`)
        this.config.whiteboard.push(message)
        return this.emit('message', message)
    }
}

export default CaptureAll

================
File: src/processors/util/SetMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import GrapoiHelpers from '../../utils/GrapoiHelpers.js'
import ns from '../../utils/ns.js'
import rdf from 'rdf-ext'

class SetMessage extends Processor {

    constructor(config) {
        super(config)
        logger.log('SetMessage constructor')
    }

    async process(message) {

        const setters = await this.getSetters(this.config, this.settingsNode, ns.trn.setValue)
        for (let i = 0; i < setters.length; i++) {
            message[setters[i].key] = setters[i].value
        }
        return this.emit('message', message)
    }

    async getSetters(config, settings, term) {

        logger.debug(`***** settings.value = ${settings.value}`)
        logger.debug(`***** term = ${term}`)
        const settersRDF = GrapoiHelpers.listToArray(config, settings, term)
        const dataset = this.config
        var setters = []
        for (let i = 0; i < settersRDF.length; i++) {
            let setter = settersRDF[i]
            let poi = rdf.grapoi({ dataset: dataset, term: setter })
            let key = poi.out(ns.trn.key).value
            let value = poi.out(ns.trn.value).value
            setters.push({ "key": key, "value": value })
        }
        return setters
    }
}

export default SetMessage

================
File: src/processors/util/ShowConfig.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowConfig extends Processor {

    constructor(config) {
        super(config)
    }

    async process(message) {

        logger.log("***************************")
        logger.log("***   Config Triples   ***")
        logger.log(this.config)
        logger.log("***************************")
        return this.emit('message', message)
    }
}

export default ShowConfig

================
File: src/processors/util/ShowMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowMessage extends Processor {

    constructor(config) {
        super(config)
        this.verbose = false
    }

    async process(message) {



        if (this.verbose) logger.log("\n***  Show Message ***")

        logger.log("***************************")
        logger.log("***  Message")
        logger.reveal(message)
        logger.log("***************************")




        return this.emit('message', message)
    }
}

export default ShowMessage

================
File: src/processors/util/ShowSettings.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'
import Processor from '../base/Processor.js'


class ShowSettings extends Processor {

    constructor(config) {
        super(config)

    }

    async process(message) {

        logger.debug(`ShowSettings.process`)

        const property = ns.trn.name

        logger.debug(`ShowSettings.process, property = ${property}`)

        const value = await this.getProperty(property)

        logger.debug(`ShowSettings.process, value  = ${value}`)

        return this.emit('message', message)
    }
}

export default ShowSettings

================
File: src/processors/util/ShowTransmission.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class ShowTransmission extends Processor {

    async process(message) {
        logger.log(this.transmission.toString())
        return this.emit('message', message)
    }
}

export default ShowTransmission

================
File: src/processors/util/Stash.js
================
import rdf from 'rdf-ext'
import { fromFile, toFile } from 'rdf-utils-fs'
import Processor from '../base/Processor.js'












class Stash extends Processor {





    constructor(config) {
        super(config)
    }






    async process(message) {
        const manifestFilename = rootDir + '/manifest.ttl'
        const stream = fromFile(manifestFilename)


        message.rootDir = rootDir
        message.dataset = await rdf.dataset().import(stream)
        return this.emit('message', message)
    }
}
export default Stash

================
File: src/processors/util/UtilProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import ShowMessage from './ShowMessage.js'
import ShowTransmission from './ShowTransmission.js'
import CaptureAll from './CaptureAll.js'
import ShowConfig from './ShowConfig.js'
import WhiteboardToMessage from './WhiteboardToMessage.js'
import SetMessage from './SetMessage.js'
import ShowSettings from './ShowSettings.js'
ShowSettings

class UtilProcessorsFactory {
    static createProcessor(type, config) {

        if (type.equals(ns.trn.ShowMessage)) {
            return new ShowMessage(config)
        }
        if (type.equals(ns.trn.ShowTransmission)) {
            return new ShowTransmission(config)
        }
        if (type.equals(ns.trn.CaptureAll)) {
            return new CaptureAll(config)
        }
        if (type.equals(ns.trn.ShowConfig)) {
            return new ShowConfig(config)
        }
        if (type.equals(ns.trn.WhiteboardToMessage)) {
            return new WhiteboardToMessage(config)
        }
        if (type.equals(ns.trn.SetMessage)) {
            return new SetMessage(config)
        }
        if (type.equals(ns.trn.ShowSettings)) {
            return new ShowSettings(config)
        }
        return false
    }
}
export default UtilProcessorsFactory

================
File: src/processors/util/WhiteboardToMessage.js
================
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'

class WhiteboardToMessage extends Processor {

    constructor(config) {
        super(config)
    }
    async process(message) {

        logger.debug('WhiteboardToMessage at [' + message.tags + '] ' + this.getTag())

        const originalArray = this.config.whiteboard

        message.whiteboard = Object.keys(originalArray).reduce((acc, key) => {
            const value = originalArray[key]
            if (value !== undefined && value !== null) {
                Object.keys(value).forEach((prop) => {
                    if (!acc[prop]) {
                        acc[prop] = []
                    }
                    acc[prop].push(value[prop])
                })
            }
            return acc
        }, {})

        return this.emit('message', message)
    }
}

export default WhiteboardToMessage

================
File: src/processors/xmpp/XmppClient.js
================
import logger from "../../utils/Logger.js";
import Processor from "../base/Processor.js";









class XmppClient extends Processor {




  constructor(config) {
    super(config);
  }





  async process(message) {
    logger.setLogLevel("debug");


    return this.emit("message", message);
  }
}

export default XmppClient

================
File: src/processors/xmpp/XmppProcessorsFactory.js
================
import logger from "../../utils/Logger.js";
import ns from "../../utils/ns.js";

import ProcessorTemplate from "./XmppClient.js";



class XmppProcessorsFactory {
  static createProcessor(type, config) {
    if (type.equals(ns.trn.XmppClient)) {
      return new XmppClient(config)
    }
    return false
  }
}
export default XmppProcessorsFactory

================
File: src/processors/about.md
================
# Creating a new Processor

- update repopacks for `transmissions` and `trans-apps`
- create a new chat session in existing Project
- upload repopacks to Claude, with anything else that might be relevant (handover from previous session?)
- follow the prompt model as in `/home/danny/workspaces_hkms-desktop/postcrafts-raw/transmissions/prompts/github-list.md`
- remember additions to `xProcessorsFactory.js` and `transmissions/src/engine/AbstractProcessorFactory.js`

#:todo add comment creation
#:todo check simples & application suitability
#:todo create document creation workflow
#:todo create manifest.ttl creation
#:todo make crossrefs.md, crossrefs.ttl
#:todo create manifest.ttl consumption
#:todo add test creation
#:todo wire to an API, include file creation ops
#:todo add support in #:hyperdata-desktop

#:todo dedicated transmissions model, fine-tuned on relevant docs

#:todo extract todos as something like :

```turtle
<http://hyperdata.it/transmissions/src/processors/about/nid123> a pv:ToDoItem ;
dc:source <http://hyperdata.it/transmissions/src/processors/about.md> ;
pv:semtag "#:todo" ;
dc:line "3" ;
dc:title "tbd" ;
dc:content "extract todos as something like :" .
```

================
File: src/simples/env-loader/about.md
================
node src/apps-simple/env-loader/env-loader.js

from:

:envy a trm:Pipeline ;

# trm:pipe (:SC :s10 :s20 :SM) .

trm:pipe (:p10 :p20 :SC) .
:p10 a :EnvLoader .
:p20 a :WhiteboardToMessage .

================
File: src/simples/env-loader/env-loader.js
================
import logger from '../../utils/Logger.js'
import EnvLoader from '../../processors/system/EnvLoader.js'
import WhiteboardToMessage from '../../processors/util/WhiteboardToMessage.js'

logger.log('EnvLoader simple')

const config = { whiteboard: [] }

const p10 = new EnvLoader(config)
p10.id = 'http://purls.org/stuff/#p10'

const p20 = new WhiteboardToMessage(config)
p10.id = 'http://purls.org/stuff/#p20'

var message = {
    "dataDir": "src/applications/env-loader-test/data",
    "rootDir": "[no key]",
    "tags": "SM"
}

const x = 3

message = await p10.process(message)

logger.log('p10 output ' + p10.getTag() + message)

message = await p20.process(message)

logger.log('p20 output ')

logger.reveal(message)

================
File: src/simples/nop/nop.js
================
import NOP from '../../processors/flow/NOP.js'

const config = {
    "runmode": "functions",
    whiteboard: []
}

const nop = new NOP(config)

var message = { 'value': '42' }

message = await nop.process(message)

console.log('value = ' + message.value)

================
File: src/simples/nop/simple-runner.js
================
import NOP from '../../processors/flow/NOP.js'
import Fork from '../../processors/flow/Fork.js'








async function main() {
    const config = {}
    const nop = new NOP(config)
    const fork = new Fork(config)

    var message = { 'value': '42' }



    var outputs = await nop.process(message)
    console.log('NOP outputs:', outputs)


    message.nForks = 3
    outputs = await fork.process(message)
    console.log('Fork outputs:', outputs)
}

main().catch(console.error)

================
File: src/simples/set-message/set-message.js
================
import logger from '../../utils/Logger.js'
import SetMessage from '../../processors/util/SetMessage.js'

const config = {
    "runmode": "functions",
    whiteboard: []
}

const setm = new SetMessage(config)

var message = { 'value': '42' }

message = await setm.process(message)

logger.log('value = ' + message.value)

logger.reveal(message)

================
File: src/utils/cache.js
================


================
File: src/utils/footpath.js
================
import path from 'path'
import { fileURLToPath } from 'url'

import logger from './Logger.js'







let footpath = {}

footpath.resolve = function footpath(here, relative, start) {

    const loggy = false
    if (loggy) {
        logger.debug("\n*** start footpath.resolve ***")
        logger.debug("process.cwd() = " + process.cwd())
        logger.debug("here = " + here)
        logger.debug("relative = " + relative)
        logger.debug("start = " + start)
    }

    const __filename = fileURLToPath(here)
    const __dirname = path.dirname(__filename)
    const rootDir = path.resolve(__dirname, relative)
    const filePath = path.join(rootDir, start)

    if (loggy) {
        logger.debug("__filename = " + __filename)
        logger.debug("__dirname = " + __dirname)
        logger.debug("rootDir = " + rootDir)
        logger.debug("filePath = " + filePath)
        logger.debug("*** end footpath.resolve ***\n")
    }

    return filePath
}

footpath.urlLastPart = function footpath(url = 'http://example.org/not-a-url') {


    const urlObj = new URL(url);
    const hash = urlObj.hash;
    const path = urlObj.pathname;
    const lastPart = hash ? hash.replace(/^#/, '') : path.split('/').pop();
    // } catch {
    //  return 'not-a-url'

    return lastPart;
}

export default footpath

================
File: src/utils/GrapoiHelpers.js
================
import rdf from 'rdf-ext'
import grapoi from 'grapoi'
import { fromFile, toFile } from 'rdf-utils-fs'
import ns from './ns.js'
import logger from './Logger.js'



class GrapoiHelpers {


    static async readDataset(filename) {
        const stream = fromFile(filename)
        const dataset = await rdf.dataset().import(stream)
        return dataset
    }

    static async writeDataset(dataset, filename) {
        await toFile(dataset.toStream(), filename)
    }


    static listToArray(dataset, term, property) {
        const poi = rdf.grapoi({ dataset: dataset, term: term })
        const first = poi.out(property).term

        let p = rdf.grapoi({ dataset, term: first })
        let object = p.out(ns.rdf.first).term

        const result = [object]

        while (true) {
            let restHead = p.out(ns.rdf.rest).term
            let p2 = rdf.grapoi({ dataset, term: restHead })
            let object = p2.out(ns.rdf.first).term

            if (restHead.equals(ns.rdf.nil)) break
            result.push(object)
            p = rdf.grapoi({ dataset, term: restHead })
        }
        return result
    }





    static listObjects(dataset, subjectList, predicate) {
        const objects = []
        for (const subject of subjectList) {
            logger.log("subject = " + subject.value)
            let p = rdf.grapoi({ dataset, term: subject })
            let object = p.out(predicate).term
            logger.log("object = " + object.value)
            objects.push(object)
        }
        return objects
    }
}
export default GrapoiHelpers

================
File: src/utils/Logger.js
================
import log from 'loglevel'
import fs from 'fs'
import chalk from 'chalk'

const logger = {}





const LOG_STYLES = {
    "trace": chalk.bgGray.greenBright,
    "debug": chalk.bgCyanBright.black,
    "info": chalk.white,
    "warn": chalk.red.italic,
    "error": chalk.red.bold
}
const LOG_LEVELS = ["trace", "debug", "info", "warn", "error"]

logger.logfile = 'latest.log'
logger.currentLogLevel = "warn"

log.setLevel(logger.currentLogLevel)

logger.getLevel = () => log.getLevel()
logger.enableAll = () => log.enableAll()
logger.disableAll = () => log.disableAll()
logger.setDefaultLevel = (level) => log.setDefaultLevel(level)
logger.getLogger = (name) => {
    const namedLogger = log.getLogger(name)
    return wrapLogger(namedLogger, name)
}

logger.methodFactory = log.methodFactory

logger.noConflict = () => log.noConflict()

function wrapLogger(baseLogger, name = 'root') {
    const wrapped = {}

    wrapped.log = function (msg, level = "info") {
        const timestamp = chalk.dim(`[${logger.timestampISO()}]`)
        const levelStyle = LOG_STYLES[level] || LOG_STYLES["info"]
        const levelTag = levelStyle(`[${level.toUpperCase()}]`)
        const nameTag = chalk.green(`[${name}]`)
        const message = levelStyle(msg)


        const consoleMessage = `${message}`
        const fileMessage = `[${logger.timestampISO()}] [${level.toUpperCase()}] [${name}] - ${msg}`

        baseLogger[level](consoleMessage)
        logger.appendLogToFile(fileMessage)
    }

    LOG_LEVELS.forEach(level => {
        wrapped[level] = (msg) => wrapped.log(msg, level)
    })

    wrapped.getLevel = () => baseLogger.getLevel()
    wrapped.setLevel = (level, persist) => baseLogger.setLevel(level, persist)
    wrapped.setDefaultLevel = (level) => baseLogger.setDefaultLevel(level)
    wrapped.enableAll = () => baseLogger.enableAll()
    wrapped.disableAll = () => baseLogger.disableAll()
    wrapped.methodFactory = baseLogger.methodFactory
    wrapped.setMethodFactory = function (factory) {
        baseLogger.methodFactory = factory
        baseLogger.rebuild()
    }

    return wrapped
}

logger.appendLogToFile = function (message) {
    if (logger.logfile) {
        fs.appendFileSync(logger.logfile, message + '\n', 'utf8')
    }
}

logger.setLogLevel = function (logLevel = "warn", persist = true) {
    logger.currentLogLevel = logLevel
    log.setLevel(logLevel, persist)
}

logger.timestampISO = function () {
    return new Date().toISOString()
}

logger.log = function (msg, level = "info") {
    const levelStyle = LOG_STYLES[level] || LOG_STYLES["info"]
    const message = levelStyle(msg)
    const consoleMessage = `${message}`
    const fileMessage = `[${logger.timestampISO()}] [${level.toUpperCase()}] [root] - ${msg}`
    try {



        log[level](consoleMessage)
        logger.appendLogToFile(fileMessage)
    } catch (err) {
        console.log(`wtf? ${err.message}`)
    }

}


logger.reveal = function (instance) {

    if (!instance) {

        return
    }

    const serialized = {}

    const loglevel = logger.getLevel()
    logger.setLogLevel('trace')


    if (instance.constructor) {
        logger.log(`*** Class : ${instance.constructor.name}`)
    }
    logger.log('* Keys :  ', 'debug')
    for (const key in instance) {
        if (key === 'dataset') {
            logger.log('[[dataset found, skipping]]', 'debug')
            continue
        }

        if (key.startsWith('_')) {
            logger.log(`       ${key}`, 'debug')
            continue
        }

        if (instance.hasOwnProperty(key)) {
            let value = instance[key]
            if (value) {
                if (Buffer.isBuffer(value)) {
                    value = value.toString()
                }
                if (value.length > 100) {
                    try {
                        value = value.substring(0, 100) + '...'
                    } catch (e) {
                        value = value.slice(0, 99)
                    }
                }
                serialized[key] = value
            } else {
                serialized[key] = '[no key]'
            }
        }
    }

    const props = JSON.stringify(serialized, null, 2)

    logger.log(`Instance of ${chalk.yellow(chalk.bold(instance.constructor.name))} with properties - \n${chalk.yellow(props)})`)
    logger.setLogLevel(loglevel)
}

LOG_LEVELS.forEach(level => {
    logger[level] = (msg) => logger.log(msg, level)
})

logger.poi = function exploreGrapoi(grapoi, predicates, objects, subjects) {
    console.log(chalk.bold('Properties of the Grapoi object:'))
    for (const prop in grapoi) {
        console.log(chalk.cyan(`\t${prop}: ${grapoi[prop]}`))
    }

    console.log(chalk.bold('\nPath:'))
    const path = grapoi.out(predicates, objects).in(predicates, subjects)
    for (const quad of path.quads()) {
        console.log(chalk.cyan(`\t${quad.predicate.value}: ${quad.object.value}`))
    }
}

function handleExit(options, exitCode) {
    if (options.cleanup) {

    }
    if (exitCode || exitCode === 0) console.log(exitCode)
    if (options.exit) process.exit()
}

process.on('exit', handleExit.bind(null, { cleanup: true }))
process.on('SIGINT', handleExit.bind(null, { exit: true }))
process.on('SIGUSR1', handleExit.bind(null, { exit: true }))
process.on('SIGUSR2', handleExit.bind(null, { exit: true }))
process.on('uncaughtException', handleExit.bind(null, { exit: true }))









export default logger

================
File: src/utils/MockApplicationManager.js
================
import logger from './Logger.js'

class MockApplicationManager {
    constructor() {
        this.appsDir = 'src/applications'
        logger.debug('MockApplicationManager: Created new instance')
    }

    async initialize(appName, appPath, subtask, target, flags) {
        logger.debug(`MockApplicationManager.initialize(${appName}, ${appPath}, ${subtask}, ${target})`)

        if (!appName) {
            throw new Error('Application name is required')
        }

        this.app = {
            appName,
            appPath: appPath || appName,
            subtask,
            targetPath: target,
            dataset: {},
            manifestFilename: target ? `${target}/manifest.ttl` : null
        }

        return Promise.resolve()
    }

    async start(message = {}) {
        logger.debug('MockApplicationManager.start()')
        logger.debug('Message:', message)

        if (!this.app) {
            throw new Error('Application not initialized')
        }


        return {
            success: true,
            whiteboard: [
                { type: 'processingComplete', timestamp: new Date().toISOString() }
            ]
        }
    }

    async listApplications() {
        logger.debug('MockApplicationManager.listApplications()')


        return [
            'test_app1',
            'test_app2',
            'example_app'
        ]
    }

    resolveApplicationPath(appName) {
        if (!appName) {
            throw new Error('Application name is required')
        }

        logger.debug(`MockApplicationManager.resolveApplicationPath(${appName})`)

        if (appName.startsWith('/')) {
            return appName
        }

        if (appName.startsWith('..')) {
            return path.resolve(process.cwd(), appName)
        }

        return path.join(process.cwd(), this.appsDir, appName)
    }
}

export default MockApplicationManager

================
File: src/utils/ns.js
================
import rdf from 'rdf-ext'

const ns = {
    rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
    rdfs: rdf.namespace('http://www.w3.org/2000/01/rdf-schema#'),
    dc: rdf.namespace('http://purl.org/dc/terms/'),
    schema: rdf.namespace('http://schema.org/'),
    xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#'),
    trn: rdf.namespace('http://purl.org/stuff/transmissions/'),



}





ns.shortName = ns.getShortname = function (url) {

    if (!url) return
    url = url.toString()
    const lastSlashIndex = url.lastIndexOf('/');
    const lastHashIndex = url.lastIndexOf('#');
    const path = url.slice(lastSlashIndex + 1);
    return path.split('#')[0].split('?')[0];
}
export default ns

================
File: src/utils/RDFUtils.js
================
import rdf from 'rdf-ext'
import { fromFile } from 'rdf-utils-fs'
import { fileURLToPath } from 'url'
import path from 'path'
import logger from './Logger.js'

class RDFUtils {
    static async loadDataset(relativePath) {
        try {
            const __filename = fileURLToPath(import.meta.url)
            const __dirname = path.dirname(__filename)
            const rootDir = path.resolve(__dirname, '../..')
            const filePath = path.join(rootDir, relativePath)

            logger.debug(`Loading RDF dataset from: ${filePath}`)
            const stream = fromFile(filePath)
            const dataset = await rdf.dataset().import(stream)
            logger.debug(`Loaded ${dataset.size} quads`)

            return dataset
        } catch (error) {
            logger.error(`Error loading dataset: ${error.message}`)
            logger.error(`Stack: ${error.stack}`)
            throw error
        }
    }
}

export default RDFUtils

================
File: src/utils/StringUtils.js
================
import logger from './Logger.js'

class StringUtils {


    static matchPatterns(str, patterns) {
        logger.trace(`StringUtils.matchPatterns, patterns = ${patterns}`)
        const matches = patterns.filter(pattern => this.matchesPattern(str, pattern))
        if (matches.length > 0) {
            return matches
        }
        return false
    }


    static matchesPattern(str, pattern) {

        logger.trace(`StringUtils.matchesPattern, pattern = ${pattern}`)
        const regexPattern = pattern
            .replace(/\./g, '\\.')
            .replace(/\*/g, '.*')
        const regex = new RegExp(`^${regexPattern}$`)
        return regex.test(str)
    }
}
export default StringUtils

================
File: src/utils/t2j.js
================
import { Readable } from 'readable-stream'
import rdf from '@rdfjs/data-model'
import SerializerJsonld from '@rdfjs/serializer-jsonld'
import Serializer from '@rdfjs/serializer-turtle'
import N3Parser from '@rdfjs/parser-n3'
import { fromFile } from 'rdf-utils-fs'
import { toFile } from 'rdf-utils-fs'

const testTurtle = `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix : <https://hyperdata.it/transmissions/> . # for custom terms & instances

:simplepipe a trm:TransmissionTransmission ;
    trm:pipe (:s1 :s2 :s3) .

:s1 a trm:StringSource .
:s2 a trm:AppendProcess .
:s3 a trm:StringSink .
`
export class Turtle2JSONLD {
    static async convert(turtle) {

        let parser = new N3Parser({ factory: rdf })



        const input = Readable.from(turtle)

        const output = parser.import(input)

        const serializerJsonld = new SerializerJsonld()
        const jsonStream = serializerJsonld.import(output)





        const outputJson = await Turtle2JSONLD.streamToString(jsonStream)
        return outputJson
    }

    static stringToStream(str) {
        const stream = new Readable();
        stream.push(str);
        stream.push(null);
        return stream;
    }

    static streamToString(stream) {
        const chunks = [];
        return new Promise((resolve, reject) => {
            stream.on('data', (chunk) => {
                chunks.push(Buffer.from(chunk))
                console.log('chunk:', chunk)
            }
            );
            stream.on('error', (err) => reject(err));
            stream.on('end', () => {
                const result = Buffer.concat(chunks).toString('utf8')
                resolve(result)
                console.log('****************** result:', result)
            });
        })
    }
}



const testJson = await Turtle2JSONLD.convert(testTurtle)
console.log('')
console.log(testJson)

================
File: src/utils/test_runner.js
================
import fs from 'fs';
import path from 'path';

const testFiles = fs.readdirSync(__dirname).filter(file => file.startsWith('test_'));

testFiles.forEach(testFile => {
    console.log(`Running ${testFile}`);
    require(path.join(__dirname, testFile));
});

================
File: src/utils/text-utils.js
================
const LANGUAGE_TAG_REGEX = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;






export function isValidLanguageTag(langTag) {
    return LANGUAGE_TAG_REGEX.test(langTag);
}









export function escapeStringLiteral(str, options = {}) {
    if (!str) return '';

    const escaped = str.includes('\n')
        ? `"""${str.replace(/"""/g, '\\"\\"\\"')
                 .replace(/\\/g, '\\\\')
                 .replace(/\r/g, '\\r')
                 .replace(/\t/g, '\\t')}"""`
        : `"${str.replace(/"/g, '\\"')
               .replace(/\\/g, '\\\\')
               .replace(/\r/g, '\\r')
               .replace(/\n/g, '\\n')
               .replace(/\t/g, '\\t')}"`;

    if (options.language && isValidLanguageTag(options.language)) {
        return `${escaped}@${options.language.toLowerCase()}`;
    }

    if (options.datatype) {
        return `${escaped}^^${options.datatype}`;
    }

    return escaped;
}







export function escapeIRI(iri) {
    if (!iri) return '';

    return iri.replace(/[\x00-\x20<>"{}|^`\\]/g, (char) => {
        return `\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`;
    });
}







export function escapeLocalName(localName) {
    if (!localName) return '';

    return localName.replace(/[~.!$&'()*+,;=/?#@%_-]/g, '\\$&');
}






export function isValidDateTime(dateStr) {
    const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$/;
    return regex.test(dateStr);
}






export function createSlug(str) {
    return str.toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
}






export function isValidURL(url) {
    try {
        new URL(url);
        return true;
    } catch {
        return false;
    }
}

================
File: src/terrapack.config.json
================
{
  "files": {
    "../packer.config.json": {
      "content": "\nimport fs from 'fs';\nimport path from 'path';\n\nconst testFiles = fs.readdirSync(__dirname).filter(file => file.startsWith('test_'));\n\ntestFiles.forEach(testFile => {\n    console.log(`Running ${testFile}`);\n    require(path.join(__dirname, testFile));\n});\n",
      "type": ".json",
      "timestamp": "2025-01-19T17:29:55.361Z"
    }
  },
  "summary": {
    "totalFiles": 185,
    "fileTypes": {
      ".json": 185
    },
    "timestamp": "2025-01-19T17:29:53.827Z"
  }
}

================
File: src/terrapack.config.json_done.txt
================
{
  "files": {
    "../packer.config.json": {
      "content": "\nimport fs from 'fs';\nimport path from 'path';\n\nconst testFiles = fs.readdirSync(__dirname).filter(file => file.startsWith('test_'));\n\ntestFiles.forEach(testFile => {\n    console.log(`Running ${testFile}`);\n    require(path.join(__dirname, testFile));\n});\n",
      "type": ".json",
      "timestamp": "2025-01-19T17:36:06.303Z"
    }
  },
  "summary": {
    "totalFiles": 185,
    "fileTypes": {
      ".json": 185
    },
    "timestamp": "2025-01-19T17:36:04.886Z"
  }
}

================
File: staging/schema-documentation.md
================
# Transmissions Templates Schema Documentation

## JSON Schema
The JSON schema provides a strict validation structure for application definitions:

### Core Components
1. `appName`: String identifier used in paths & configurations
2. `purpose`: Object describing application goals
   - `primaryGoal`: Single sentence description
   - `inputs`/`outputs`: Array of expected formats
   - `behavior`: Expected processing behavior 

3. `processingRequirements`: Object defining data flow
   - `input`: Message & file specifications
   - `steps`: Array of processing stages
   - `output`: Expected results format

4. `components`: Required implementation pieces
   - `newProcessors`: New code needed
   - `configFiles`: Configuration files
   - `existingProcessors`: Reused components

5. `testing`: Test specifications
   - `unitTests`: Component-level tests
   - `integrationTests`: Pipeline tests

## RDF Schema
The RDF schema models the application definition as linked data:

### Core Classes
1. `trm:ApplicationDefinition`
   - Links requirements, components, testing
   - Provides metadata about application

2. `trm:Requirements` 
   - Models input/output specifications
   - Defines processing steps
   - Links to configurations

3. `trm:ComponentList`
   - Catalogs needed processors
   - Specifies configurations
   - References existing code

4. `trm:TestingRequirements`
   - Defines test scenarios
   - Specifies test data
   - Documents expectations

### Additional Properties
```turtle
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix prj: <http://purl.org/stuff/project/> .

trm:ApplicationDefinition
    trm:hasVersion "1.0" ;
    trm:requiresTransmissionsVersion "2.0" ;
    trm:category "data-processing" ;
    prj:status "development" ;
    prj:priority "medium" ;
    prj:estimatedEffort "2d" ;
    prj:dependencies [
        a prj:DependencyList ;
        prj:requires "markmap-lib", "rdf-ext"
    ] ;
    prj:documentation [
        a prj:DocumentationRequirements ;
        prj:requiresAPIDoc true ;
        prj:requiresUserGuide true
    ] ;
    prj:deployment [
        a prj:DeploymentRequirements ;
        prj:environment "node16+" ;
        prj:memoryRequirements "512MB"
    ] .
```

================
File: staging/template-cli.js
================
#!/usr/bin/env node
import TemplateGenerator from './TemplateGenerator.js';

const generator = new TemplateGenerator();
generator.run();

================
File: staging/template-generator.js
================
import fs from 'fs/promises';
import path from 'path';
import { Command } from 'commander';
import inquirer from 'inquirer';
import { rdf, namespace } from '@rdfjs/data-model';
import { Writer } from 'n3';

const ns = {
    trm: namespace('http://purl.org/stuff/transmission/'),
    prj: namespace('http://purl.org/stuff/project/'),
    app: namespace('http://example.org/app/')
};

class TemplateGenerator {
    constructor() {
        this.program = new Command();
        this.setupCommands();
    }

    setupCommands() {
        this.program
            .name('trans-template')
            .description('Generate Transmissions application templates')
            .version('1.0.0');

        this.program
            .command('create')
            .description('Create new application templates')
            .argument('<name>', 'Application name')
            .option('-f, --format <format>', 'Output format (json|turtle|markdown)', 'json')
            .action(async (name, options) => {
                const answers = await this.promptForDetails(name);
                await this.generateTemplates(name, answers, options.format);
            });
    }

    async promptForDetails(name) {
        return inquirer.prompt([
            {
                type: 'input',
                name: 'primaryGoal',
                message: 'What is the primary goal of this application?'
            },
            {
                type: 'input',
                name: 'inputs',
                message: 'Input formats (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'input',
                name: 'outputs',
                message: 'Output formats (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'input',
                name: 'processors',
                message: 'Required processors (comma-separated):',
                filter: input => input.split(',').map(i => i.trim())
            },
            {
                type: 'confirm',
                name: 'needsTests',
                message: 'Generate test templates?',
                default: true
            }
        ]);
    }

    async generateTemplates(name, answers, format) {
        const outputDir = path.join(process.cwd(), name);
        await fs.mkdir(outputDir, { recursive: true });

        const templates = {
            json: () => this.generateJSON(name, answers),
            turtle: () => this.generateTurtle(name, answers),
            markdown: () => this.generateMarkdown(name, answers)
        };

        const content = templates[format]();
        const fileExt = format === 'turtle' ? 'ttl' : format;

        await fs.writeFile(
            path.join(outputDir, `app-definition.${fileExt}`),
            content
        );


        await this.generateFileStructure(outputDir, answers);

        console.log(`Generated ${format} template in ${outputDir}`);
    }

    generateJSON(name, answers) {
        return JSON.stringify({
            appName: name,
            purpose: {
                primaryGoal: answers.primaryGoal,
                inputs: answers.inputs,
                outputs: answers.outputs
            },
            processingRequirements: {
                steps: answers.processors.map(p => ({
                    name: p,
                    processor: p,
                    config: {}
                }))
            },
            testing: {
                unitTests: answers.processors.map(p => ({
                    component: p,
                    cases: ['basic', 'error']
                }))
            }
        }, null, 2);
    }

    generateTurtle(name, answers) {
        const writer = new Writer();
        const app = ns.app(name);

        writer.addQuad(
            app,
            ns.trn('title'),
            rdf.literal(name)
        );

        writer.addQuad(
            app,
            ns.trn('primaryGoal'),
            rdf.literal(answers.primaryGoal)
        );

        answers.processors.forEach(p => {
            const proc = ns.app(p);
            writer.addQuad(
                app,
                ns.trn('hasProcessor'),
                proc
            );
        });

        return writer.toString();
    }

    generateMarkdown(name, answers) {
        return `# ${name}

## Purpose
${answers.primaryGoal}

## Inputs
${answers.inputs.map(i => `- ${i}`).join('\n')}

## Outputs
${answers.outputs.map(o => `- ${o}`).join('\n')}

## Processors
${answers.processors.map(p => `- ${p}`).join('\n')}

## Testing
${answers.needsTests ? '- Unit tests required\n- Integration tests required' : 'No tests specified'}
`;
    }

    async generateFileStructure(outputDir, answers) {
        const dirs = [
            'processors',
            'tests',
            'config'
        ];

        for (const dir of dirs) {
            await fs.mkdir(path.join(outputDir, dir), { recursive: true });
        }


        const files = {
            'transmissions.ttl': '',
            'config.ttl': '',
            'about.md': `# ${path.basename(outputDir)}\n\n${answers.primaryGoal}`
        };

        for (const [file, content] of Object.entries(files)) {
            await fs.writeFile(
                path.join(outputDir, file),
                content
            );
        }
    }

    run() {
        this.program.parse();
    }
}

export default TemplateGenerator;

================
File: staging/template-tool-docs.md
================
# Transmissions Template Generator

## Overview
Command-line tool to generate scaffold for new Transmissions applications.

## Installation
```bash
npm install -g trans-template
```

## Usage
```bash
# Generate new application template
trans-template create my-app

# Specify output format
trans-template create my-app --format turtle

# Help
trans-template --help
```

## Generated Structure
```
my-app/
 processors/      # New processors
 tests/          # Test files
 config/         # Configuration files
 transmissions.ttl  # Pipeline definition
 config.ttl         # Service configuration
 about.md          # Application documentation
```

## Template Formats

### JSON
- Full application definition
- Validates against JSON schema
- Used for tooling/automation

### Turtle
- RDF representation
- Linked data model
- Integration with semantic tools

### Markdown
- Human-readable format
- Documentation focus
- GitHub-friendly

## Environment Variables
- `TRANS_TEMPLATE_PATH`: Base path for templates
- `TRANS_CONFIG_PATH`: Path to configuration

## Error Handling
- Validates input parameters
- Creates missing directories
- Reports detailed errors

## Extension
Custom templates can be added in:
```bash
~/.config/trans-template/templates/
```

================
File: staging/transmissions-prompt-template.md
================
# Transmissions Application Definition Template

## Application Name
[Short name for the application, will be used in file paths]

## Purpose
- Primary goal in one sentence
- Key inputs and outputs
- Expected behavior

## Technical Context
- Base paths:
  - Transmissions core: ~/github-danny/transmissions
  - Applications: ~/github-danny/trans-apps

## Processing Requirements 
1. Input Format
   - Message structure
   - File formats/paths
   - Required fields

2. Processing Steps
   - List processing stages in sequence
   - Note any existing processors to use
   - Identify new processors needed

3. Output Format
   - Expected message structure
   - File formats/paths
   - Required fields

## Required Components
- New processors to create [list]
- Configuration files needed [list]
- Existing processors to reuse [list]

## Example Usage
```bash
./trans [app-name] [example command line arguments]
```

## Success Criteria
- List specific conditions that indicate successful implementation
- Example outputs or results

## Technical Constraints
- Note any performance requirements
- Special error handling needs
- Specific processor features needed

## Reference Material
- Links to example code
- Related processors
- Documentation needed

================
File: staging/transmissions-template-schema.json
================
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Transmissions Application Definition",
  "type": "object",
  "required": ["appName", "purpose", "technicalContext", "processingRequirements", "components", "testing"],
  "properties": {
    "appName": {
      "type": "string",
      "description": "Short name for the application"
    },
    "purpose": {
      "type": "object",
      "required": ["primaryGoal", "inputs", "outputs", "behavior"],
      "properties": {
        "primaryGoal": { "type": "string" },
        "inputs": { "type": "array", "items": { "type": "string" }},
        "outputs": { "type": "array", "items": { "type": "string" }},
        "behavior": { "type": "string" }
      }
    },
    "technicalContext": {
      "type": "object",
      "required": ["transmissionsPath", "applicationsPath"],
      "properties": {
        "transmissionsPath": { "type": "string" },
        "applicationsPath": { "type": "string" }
      }
    },
    "processingRequirements": {
      "type": "object",
      "required": ["input", "steps", "output"],
      "properties": {
        "input": {
          "type": "object",
          "properties": {
            "messageStructure": { "type": "object" },
            "fileFormats": { "type": "array", "items": { "type": "string" }},
            "requiredFields": { "type": "array", "items": { "type": "string" }}
          }
        },
        "steps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "processor": { "type": "string" },
              "config": { "type": "object" }
            }
          }
        },
        "output": {
          "type": "object",
          "properties": {
            "messageStructure": { "type": "object" },
            "fileFormats": { "type": "array", "items": { "type": "string" }},
            "requiredFields": { "type": "array", "items": { "type": "string" }}
          }
        }
      }
    },
    "components": {
      "type": "object",
      "required": ["newProcessors", "configFiles", "existingProcessors"],
      "properties": {
        "newProcessors": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "configFiles": { 
          "type": "array", 
          "items": { "type": "string" }
        },
        "existingProcessors": { 
          "type": "array", 
          "items": { "type": "string" }
        }
      }
    },
    "testing": {
      "type": "object",
      "required": ["unitTests", "integrationTests"],
      "properties": {
        "unitTests": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "component": { "type": "string" },
              "cases": { 
                "type": "array",
                "items": { "type": "string" }
              }
            }
          }
        },
        "integrationTests": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "scenario": { "type": "string" },
              "steps": { 
                "type": "array",
                "items": { "type": "string" }
              }
            }
          }
        }
      }
    }
  }
}

================
File: staging/transmissions-template-turtle.txt
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix prj: <http://purl.org/stuff/project/> .
@prefix app: <http://example.org/app/> .

app:Application a trm:ApplicationDefinition ;
    dcterms:title "Application Name" ;
    dcterms:description "Primary goal description" ;
    trm:basePath "/path/to/application" ;
    trm:hasRequirement app:ProcessingRequirements ;
    trm:hasComponent app:Components ;
    trm:hasTesting app:Testing .

app:ProcessingRequirements a trm:Requirements ;
    trm:input [
        a trm:InputRequirement ;
        trm:messageStructure "JSON structure" ;
        trm:fileFormat "format specification" ;
        trm:requiredField "field1", "field2"
    ] ;
    trm:processing [
        a trm:ProcessingStep ;
        trm:order 1 ;
        trm:processor "ProcessorName" ;
        trm:configuration app:ProcessorConfig
    ] ;
    trm:output [
        a trm:OutputRequirement ;
        trm:messageStructure "JSON structure" ;
        trm:fileFormat "format specification" ;
        trm:requiredField "field1", "field2"
    ] .

app:Components a trm:ComponentList ;
    trm:newProcessor [
        a trm:Processor ;
        dcterms:title "Processor Name" ;
        trm:class "ProcessorClass" ;
        trm:sourcePath "/path/to/source"
    ] ;
    trm:configFile [
        a trm:Configuration ;
        dcterms:title "Config Name" ;
        trm:format "Turtle" ;
        trm:path "/path/to/config"
    ] ;
    trm:existingProcessor [
        a trm:Processor ;
        dcterms:title "Existing Processor" ;
        trm:class "ProcessorClass"
    ] .

app:Testing a trm:TestingRequirements ;
    trm:unitTest [
        a trm:UnitTest ;
        dcterms:title "Test Name" ;
        trm:component "ComponentName" ;
        trm:testCase "test description"
    ] ;
    trm:integrationTest [
        a trm:IntegrationTest ;
        dcterms:title "Test Scenario" ;
        trm:step "step description" ;
        trm:expectedResult "expected outcome"
    ] ;
    trm:testData [
        a trm:TestData ;
        trm:input "/path/to/test/input" ;
        trm:expected "/path/to/test/output"
    ] .

================
File: staging/transmissions-testing-template.md
================
# Transmissions Testing Requirements Template

## Unit Tests
1. Individual Processors
   - Input validation tests
   - Core processing tests 
   - Error handling tests
   - Edge case tests
   - Sample data needed

2. Configuration Tests
   - Config file loading
   - Config validation
   - Default values
   - Error conditions

## Integration Tests
1. Pipeline Tests
   - Full transmission flow
   - Inter-processor communication
   - Message transformations
   - File I/O operations

2. System Tests
   - CLI interface testing
   - File system interactions
   - Error recovery
   - Resource cleanup

## Test Data Requirements
1. Input Test Files
   - Sample files needed
   - File formats
   - Edge cases
   - Invalid data samples

2. Expected Outputs
   - Reference output files
   - Validation criteria
   - Format specifications
   - Error conditions

## Test Environment
1. Setup Requirements
   - Directory structure
   - Required permissions
   - External dependencies
   - Configuration files

2. Cleanup Procedures
   - File cleanup
   - Resource cleanup
   - State reset
   - Verification steps

## Documentation
1. Test Coverage
   - Required coverage metrics
   - Critical paths
   - Exception paths
   - Performance criteria

2. Test Reports
   - Required metrics
   - Format specifications
   - Success criteria
   - Failure analysis

================
File: test-failures/test_env-loader/2024-11-28T17-44-11.419Z/test-output.json
================
{
  "result": {
    "stdout": "\nCommandUtils.run()\nCommandUtils.run, process.cwd() = /home/danny/github-danny/transmissions\nCommandUtils.run, application = test_env-loader\nCommandUtils.run, target = undefined\n\nCommandUtils.splitName, fullPath  = test_env-loader\n\nCommandUtils.splitName, parts  = test_env-loader\nCommandUtils.splitName, appName:test_env-loader, appPath:test_env-loader, task:false,\n\n\n    CommandUtils.run, \n    appName = test_env-loader\n    appPath = test_env-loader\n    subtask = undefined\n    target = undefined\n\n+ ***** Construct Transmission :  <http://hyperdata.it/transmissions/envy>\n| Create processor :s10 of type :EnvLoader\n| Create processor :s20 of type :WhiteboardToMessage\n| Create processor :SM of type :ShowMessage\n  > Connect #0 [s10] => [s20]\nTransmission.connect from http://hyperdata.it/transmissions/s10 to http://hyperdata.it/transmissions/s10\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s10 this.toName =  http://hyperdata.it/transmissions/s20\n  > Connect #1 [s20] => [SM]\nTransmission.connect from http://hyperdata.it/transmissions/s20 to http://hyperdata.it/transmissions/s20\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s20 this.toName =  http://hyperdata.it/transmissions/SM\n\n+ ***** Execute Transmission :  <http://hyperdata.it/transmissions/envy>\n| Running : http://hyperdata.it/transmissions/s10 a EnvLoader\nTypeError: (intermediate value).handle is not a function\n    at EnvLoader.process (file:///home/danny/github-danny/transmissions/src/processors/system/EnvLoader.js:43:22)\n    at EnvLoader.executeQueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:187:24)\n    at EnvLoader.enqueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:156:18)\n    at EnvLoader.receive (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:145:20)\n    at Transmission.process (file:///home/danny/github-danny/transmissions/src/engine/Transmission.js:36:23)\n    at ApplicationManager.start (file:///home/danny/github-danny/transmissions/src/core/ApplicationManager.js:76:36)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async CommandUtils.begin (file:///home/danny/github-danny/transmissions/src/api/common/CommandUtils.js:40:16)\n    at async Object.handler (file:///home/danny/github-danny/transmissions/src/api/cli/run.js:69:13)\n0\n",
    "stderr": "",
    "code": 0,
    "signal": null,
    "success": false,
    "duration": "0.771"
  },
  "config": {
    "name": "test_env-loader"
  }
}

================
File: test-failures/test_env-loader/2024-11-28T17-46-20.677Z/test-output.json
================
{
  "result": {
    "stdout": "\n+ ***** Construct Transmission :  <http://hyperdata.it/transmissions/envy>\n| Create processor :s10 of type :EnvLoader\n| Create processor :s20 of type :WhiteboardToMessage\n| Create processor :SM of type :ShowMessage\n  > Connect #0 [s10] => [s20]\nTransmission.connect from http://hyperdata.it/transmissions/s10 to http://hyperdata.it/transmissions/s10\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s10 this.toName =  http://hyperdata.it/transmissions/s20\n  > Connect #1 [s20] => [SM]\nTransmission.connect from http://hyperdata.it/transmissions/s20 to http://hyperdata.it/transmissions/s20\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s20 this.toName =  http://hyperdata.it/transmissions/SM\n\n+ ***** Execute Transmission :  <http://hyperdata.it/transmissions/envy>\n| Running : http://hyperdata.it/transmissions/s10 a EnvLoader\nTypeError: (intermediate value).handle is not a function\n    at EnvLoader.process (file:///home/danny/github-danny/transmissions/src/processors/system/EnvLoader.js:43:22)\n    at EnvLoader.executeQueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:187:24)\n    at EnvLoader.enqueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:156:18)\n    at EnvLoader.receive (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:145:20)\n    at Transmission.process (file:///home/danny/github-danny/transmissions/src/engine/Transmission.js:36:23)\n    at ApplicationManager.start (file:///home/danny/github-danny/transmissions/src/core/ApplicationManager.js:76:36)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async CommandUtils.begin (file:///home/danny/github-danny/transmissions/src/api/common/CommandUtils.js:40:16)\n    at async Object.handler (file:///home/danny/github-danny/transmissions/src/api/cli/run.js:69:13)\n0\n",
    "stderr": "",
    "code": 0,
    "signal": null,
    "success": false,
    "duration": "0.709"
  },
  "config": {
    "name": "test_env-loader"
  }
}

================
File: test-failures/test_env-loader/2024-11-28T18-31-38.300Z/test-output.json
================
{
  "result": {
    "stdout": "\n+ ***** Construct Transmission :  <http://hyperdata.it/transmissions/envy>\n| Create processor :s10 of type :EnvLoader\n| Create processor :s20 of type :WhiteboardToMessage\n| Create processor :SM of type :ShowMessage\n  > Connect #0 [s10] => [s20]\nTransmission.connect from http://hyperdata.it/transmissions/s10 to http://hyperdata.it/transmissions/s10\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s10 this.toName =  http://hyperdata.it/transmissions/s20\n  > Connect #1 [s20] => [SM]\nTransmission.connect from http://hyperdata.it/transmissions/s20 to http://hyperdata.it/transmissions/s20\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s20 this.toName =  http://hyperdata.it/transmissions/SM\n\n+ ***** Execute Transmission :  <http://hyperdata.it/transmissions/envy>\n| Running : http://hyperdata.it/transmissions/s10 a EnvLoader\nTypeError: (intermediate value).handle is not a function\n    at EnvLoader.process (file:///home/danny/github-danny/transmissions/src/processors/system/EnvLoader.js:43:22)\n    at EnvLoader.executeQueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:187:24)\n    at EnvLoader.enqueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:156:18)\n    at EnvLoader.receive (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:145:20)\n    at Transmission.process (file:///home/danny/github-danny/transmissions/src/engine/Transmission.js:36:23)\n    at ApplicationManager.start (file:///home/danny/github-danny/transmissions/src/core/ApplicationManager.js:76:36)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async CommandUtils.begin (file:///home/danny/github-danny/transmissions/src/api/common/CommandUtils.js:40:16)\n    at async Object.handler (file:///home/danny/github-danny/transmissions/src/api/cli/run.js:69:13)\n0\n",
    "stderr": "",
    "code": 0,
    "signal": null,
    "success": false,
    "duration": "0.723"
  },
  "config": {
    "name": "test_env-loader"
  }
}

================
File: test-failures/test_env-loader/2024-11-28T18-34-16.177Z/test-output.json
================
{
  "result": {
    "stdout": "\n+ ***** Construct Transmission :  <http://hyperdata.it/transmissions/envy>\n| Create processor :s10 of type :EnvLoader\n| Create processor :s20 of type :WhiteboardToMessage\n| Create processor :SM of type :ShowMessage\n  > Connect #0 [s10] => [s20]\nTransmission.connect from http://hyperdata.it/transmissions/s10 to http://hyperdata.it/transmissions/s10\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s10 this.toName =  http://hyperdata.it/transmissions/s20\n  > Connect #1 [s20] => [SM]\nTransmission.connect from http://hyperdata.it/transmissions/s20 to http://hyperdata.it/transmissions/s20\nConnector.connect this.fromName = http://hyperdata.it/transmissions/s20 this.toName =  http://hyperdata.it/transmissions/SM\n\n+ ***** Execute Transmission :  <http://hyperdata.it/transmissions/envy>\n| Running : http://hyperdata.it/transmissions/s10 a EnvLoader\n| Running >>> :  (s10) s20 a WhiteboardToMessage\nWhiteboardToMessage at (s10.s20) s20\nTypeError: (intermediate value).handle is not a function\n    at WhiteboardToMessage.process (file:///home/danny/github-danny/transmissions/src/processors/util/WhiteboardToMessage.js:28:22)\n    at WhiteboardToMessage.executeQueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:187:24)\n    at WhiteboardToMessage.enqueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:156:18)\n    at WhiteboardToMessage.receive (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:145:20)\n    at EnvLoader.<anonymous> (file:///home/danny/github-danny/transmissions/src/engine/Connector.js:32:25)\n    at EnvLoader.emit (node:events:518:28)\n    at EnvLoader.emit (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:246:15)\n    at EnvLoader.process (file:///home/danny/github-danny/transmissions/src/processors/system/EnvLoader.js:41:21)\n    at EnvLoader.executeQueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:187:24)\n    at EnvLoader.enqueue (file:///home/danny/github-danny/transmissions/src/processors/base/Processor.js:156:18)\n0\n",
    "stderr": "",
    "code": 0,
    "signal": null,
    "success": false,
    "duration": "0.708"
  },
  "config": {
    "name": "test_env-loader"
  }
}

================
File: test-failures/test_http-server/2024-11-30T12-30-16.673Z/test-output.json
================
{
  "result": {
    "stdout": "\n+ ***** Construct Transmission :  <http://hyperdata.it/transmissions/mini>\n| Create processor :server of type :HttpServer\n| Create processor :SM of type :ShowMessage\n  > Connect #0 [server] => [SM]\nTransmission.connect from http://hyperdata.it/transmissions/server to http://hyperdata.it/transmissions/server\nConnector.connect this.fromName = http://hyperdata.it/transmissions/server this.toName =  http://hyperdata.it/transmissions/SM\n\n+ ***** Execute Transmission :  <http://hyperdata.it/transmissions/mini>\n| Running : http://hyperdata.it/transmissions/server a HttpServer\nError: listen EADDRINUSE: address already in use :::4000\n    at Server.setupListenHandle [as _listen2] (node:net:1872:16)\n    at listenInCluster (node:net:1920:12)\n    at Server.listen (node:net:2008:7)\n    at Function.listen (/home/danny/github-danny/transmissions/node_modules/express/lib/application.js:635:24)\n    at ServerWorker.start (file:///home/danny/github-danny/transmissions/src/processors/http/HttpServerWorker.js:42:36)\n    at MessagePort.<anonymous> (file:///home/danny/github-danny/transmissions/src/processors/http/HttpServerWorker.js:18:26)\n    at [nodejs.internal.kHybridDispatch] (node:internal/event_target:826:20)\n    at exports.emitMessage (node:internal/per_context/messageport:23:28) {\n  code: 'EADDRINUSE',\n  errno: -98,\n  syscall: 'listen',\n  address: '::',\n  port: 4000\n}\n0\n",
    "stderr": "",
    "code": 0,
    "signal": null,
    "success": false,
    "duration": "0.898"
  },
  "config": {
    "name": "test_http-server"
  }
}

================
File: tests/examples/test-data-usage.js
================
import TestDataGenerator from '../helpers/TestDataGenerator.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateTestData() {

    const generator = new TestDataGenerator(
        path.join(__dirname, '../../src/applications/test_markmap/data')
    );

    try {

        await generator.init();


        const files = await generator.generateMarkdownFiles(3);
        console.log('Generated basic test files:', files);


        await generator.generateNestedStructure();
        console.log('Generated nested structure');


        await generator.generateEdgeCases();
        console.log('Generated edge cases');


        await generator.generateRequiredOutputs(
            path.join(generator.baseDir, 'input')
        );
        console.log('Generated required outputs');

    } catch (error) {
        console.error('Error generating test data:', error);
    }
}


generateTestData().catch(console.error);

================
File: tests/helpers/file-test-helper.js
================
import fs from 'fs/promises';
import path from 'path';
import logger from '../../src/utils/Logger.js';

class FileTestHelper {
    constructor(baseDir) {
        this.baseDir = baseDir;
    }

    async setup() {
        await fs.mkdir(this.baseDir, { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'input'), { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'output'), { recursive: true });
    }

    async cleanup() {
        try {
            await fs.rm(this.baseDir, { recursive: true, force: true });
        } catch (error) {
            logger.error('Cleanup error:', error);
        }
    }

    async createTestFile(subPath, content) {
        const filePath = path.join(this.baseDir, subPath);
        await fs.mkdir(path.dirname(filePath), { recursive: true });
        await fs.writeFile(filePath, content);
        return filePath;
    }

    async compareFiles(actualPath, expectedPath) {
        try {
            const actual = await fs.readFile(actualPath, 'utf8');
            const expected = await fs.readFile(expectedPath, 'utf8');
            return {
                match: actual.trim() === expected.trim(),
                actual: actual.trim(),
                expected: expected.trim()
            };
        } catch (error) {
            logger.error('File comparison error:', error);
            return {
                match: false,
                error: error.message
            };
        }
    }

    async clearOutputFiles(pattern = 'output-*') {
        const outputDir = path.join(this.baseDir, 'output');
        const files = await fs.readdir(outputDir);
        for (const file of files) {
            if (file.match(pattern)) {
                await fs.unlink(path.join(outputDir, file));
            }
        }
    }

    async fileExists(filePath) {
        try {
            await fs.access(path.join(this.baseDir, filePath));
            return true;
        } catch {
            return false;
        }
    }
}

export default FileTestHelper;

================
File: tests/helpers/reporter.js
================
import { SpecReporter } from 'jasmine-spec-reporter';

class CustomReporter {
    constructor() {
        this.specReporter = new SpecReporter({
            spec: {
                displayPending: true
            }
        });
    }

    jasmineStarted() {
        this.specReporter.jasmineStarted.apply(this.specReporter, arguments);
    }

    suiteStarted() {
        this.specReporter.suiteStarted.apply(this.specReporter, arguments);
    }

    specStarted() {
        this.specReporter.specStarted.apply(this.specReporter, arguments);
    }

    specDone() {
        this.specReporter.specDone.apply(this.specReporter, arguments);
    }

    suiteDone() {
        this.specReporter.suiteDone.apply(this.specReporter, arguments);
    }

    jasmineDone() {
        this.specReporter.jasmineDone.apply(this.specReporter, arguments);
    }
}

export default CustomReporter;

================
File: tests/helpers/test-data-generator.js
================
import path from 'path';
import fs from 'fs/promises';
import logger from '../../src/utils/Logger.js';

class TestDataGenerator {
    constructor(baseDir) {
        this.baseDir = baseDir;
    }

    async init() {
        await fs.mkdir(this.baseDir, { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'input'), { recursive: true });
        await fs.mkdir(path.join(this.baseDir, 'output'), { recursive: true });
    }

    async generateMarkdownFiles(count = 5) {
        const files = [];
        for (let i = 1; i <= count; i++) {
            const content = this.generateMarkdownContent(i);
            const filename = `test-${String(i).padStart(2, '0')}.md`;
            const filepath = path.join(this.baseDir, 'input', filename);

            await fs.writeFile(filepath, content);
            files.push(filepath);
        }
        return files;
    }

    generateMarkdownContent(depth = 3) {
        const content = [];
        content.push(`# Test Document ${depth}`);

        for (let i = 1; i <= depth; i++) {
            content.push(`\n${'#'.repeat(i + 1)} Section ${i}`);
            content.push(this.generateListItems(i));

            if (i < depth) {
                content.push(this.generateParagraph(i));
            }
        }

        return content.join('\n');
    }

    generateListItems(count) {
        const items = [];
        for (let i = 1; i <= count; i++) {
            items.push(`* List item ${i}`);
            if (Math.random() > 0.5) {
                for (let j = 1; j <= 2; j++) {
                    items.push(`  * Nested item ${i}.${j}`);
                }
            }
        }
        return items.join('\n');
    }

    generateParagraph(seed) {
        const sentences = [
            "Lorem ipsum dolor sit amet.",
            "Consectetur adipiscing elit.",
            "Sed do eiusmod tempor incididunt.",
            "Ut labore et dolore magna aliqua.",
            "Ut enim ad minim veniam."
        ];

        return sentences.slice(0, seed + 1).join(' ');
    }

    async generateNestedStructure(depth = 3) {
        for (let i = 1; i <= depth; i++) {
            const dirPath = path.join(this.baseDir, 'input', 'nested',
                ...Array(i).fill(0).map((_, idx) => `level-${idx + 1}`));

            await fs.mkdir(dirPath, { recursive: true });

            const content = this.generateMarkdownContent(i);
            const filepath = path.join(dirPath, `nested-${i}.md`);
            await fs.writeFile(filepath, content);
        }
    }

    async generateEdgeCases() {
        const cases = {
            'empty.md': '',
            'only-title.md': '# Solo Title',
            'special-chars.md': '# Test & < > " \' Document',
            'very-deep.md': this.generateDeepStructure(10),
            'wide.md': this.generateWideStructure(10)
        };

        const edgeCaseDir = path.join(this.baseDir, 'input', 'edge-cases');
        await fs.mkdir(edgeCaseDir, { recursive: true });

        for (const [filename, content] of Object.entries(cases)) {
            await fs.writeFile(path.join(edgeCaseDir, filename), content);
        }
    }

    generateDeepStructure(depth) {
        return Array(depth)
            .fill(0)
            .map((_, i) => `${'#'.repeat(i + 1)} Level ${i + 1}`)
            .join('\n');
    }

    generateWideStructure(width) {
        const content = ['# Wide Document'];
        for (let i = 1; i <= width; i++) {
            content.push(`## Section ${i}`);
            for (let j = 1; j <= width; j++) {
                content.push(`* Item ${i}.${j}`);
            }
        }
        return content.join('\n');
    }

    async generateRequiredOutputs(sourceDir) {
        const files = await fs.readdir(sourceDir);
        for (const file of files) {
            if (file.endsWith('.md')) {
                const content = await fs.readFile(path.join(sourceDir, file));


                await fs.writeFile(
                    path.join(this.baseDir, 'output', `required-${file.replace('.md', '.mm.html')}`),
                    this.wrapHTML(content.toString())
                );


                await fs.writeFile(
                    path.join(this.baseDir, 'output', `required-${file.replace('.md', '.mm.svg')}`),
                    this.generateSVG(content.toString())
                );
            }
        }
    }

    wrapHTML(content) {
        return `<!DOCTYPE html>
<html>
<head>
    <title>Markmap</title>
</head>
<body>
    <div class="markmap">
        ${content}
    </div>
</body>
</html>`;
    }

    generateSVG(content) {

        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
    <text x="10" y="20">Test SVG for: ${content.split('\n')[0]}</text>
</svg>`;
    }

    async cleanup() {
        try {
            await fs.rm(this.baseDir, { recursive: true, force: true });
        } catch (error) {
            logger.error('Cleanup error:', error);
        }
    }
}

export default TestDataGenerator;

================
File: tests/integration/app-context.spec.js
================
import { expect } from 'chai'
import path from 'path'
import { fileURLToPath } from 'url'
import fs from 'fs/promises'
import rdf from 'rdf-ext'
import ApplicationManager from '../../src/engine/ApplicationManager.js'
import ns from '../../src/utils/ns.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

describe('Application Context Integration', () => {
    let manager
    const testAppRoot = path.join(__dirname, '../../src/applications/test_app_context')
    const testTarget = path.join(testAppRoot, 'target')

    beforeEach(async () => {
        manager = new ApplicationManager()
        await setupTestFiles()
    })

    afterEach(async () => {
        await cleanupTestFiles()
    })

    async function setupTestFiles() {
        await fs.mkdir(testAppRoot, { recursive: true })
        await fs.mkdir(path.join(testAppRoot, 'data'), { recursive: true })
        await fs.mkdir(testTarget, { recursive: true })

        await fs.writeFile(path.join(testAppRoot, 'transmissions.ttl'), `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .
:test a :Transmission ;
    :pipe (:p10 :p20) .
:p10 a :ShowMessage .
:p20 a :ShowConfig .`)

        await fs.writeFile(path.join(testAppRoot, 'config.ttl'), `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .
:testConfig a :ConfigSet ;
    :testKey "testValue" .`)
    }

    async function cleanupTestFiles() {
        try {
            await fs.rm(testAppRoot, { recursive: true, force: true })
        } catch (err) {
            if (err.code !== 'ENOENT') throw err
        }
    }

    it('should create application graph during initialization', async () => {
        await manager.initialize('test_app_context', testAppRoot, null, testTarget)

        const appNode = rdf.namedNode('http://purl.org/stuff/transmissions/test_app_context')
        const hasType = manager.dataset.match(appNode, ns.rdf.type, ns.trn.Application).size > 0
        expect(hasType).to.be.true
    })

    it('should propagate app context through processors', async () => {
        await manager.initialize('test_app_context', testAppRoot, null, testTarget)

        const message = { test: 'value' }
        const result = await manager.start(message)

        expect(result).to.have.property('success', true)
        expect(message).to.have.property('app')
        expect(message.app).to.have.property('sessionNode')
        expect(message.app.dataset).to.be.instanceOf(rdf.dataset().constructor)
    })

    it('should resolve paths correctly using app context', async () => {
        await manager.initialize('test_app_context', testAppRoot, null, testTarget)

        let processorPaths = []
        const testMessage = {
            onProcess: (processor, message) => {
                const testPath = 'test/path'
                const resolved = processor.getAppPath(testPath)
                processorPaths.push(resolved)
            }
        }

        await manager.start(testMessage)

        expect(processorPaths.length).to.be.greaterThan(0)
        processorPaths.forEach(resolved => {
            expect(resolved).to.equal(path.join(testAppRoot, 'test/path'))
        })
    })

    it('should preserve existing functionality', async () => {

        await manager.initialize('test_app_context', testAppRoot, null, testTarget)
        const result = await manager.start()

        expect(result).to.have.property('success', true)
        const appConfig = await manager.app.getConfigPath()
        expect(appConfig).to.include('config.ttl')
    })
})

================
File: tests/integration/application-manager.spec.js
================
import { expect } from 'chai'
import path from 'path'
import fs from 'fs/promises'
import { fileURLToPath } from 'url'
import ApplicationManager from '../../src/engine/ApplicationManager.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

describe('ApplicationManager Integration', () => {
    let manager
    const testAppRoot = path.join(__dirname, '../../src/applications/test_app_manager')
    const testTarget = path.join(testAppRoot, 'target')

    beforeEach(async () => {
        manager = new ApplicationManager()
        await setupTestFiles()
    })

    afterEach(async () => {
        await cleanupTestFiles()
    })

    async function setupTestFiles() {
        await fs.mkdir(testAppRoot, { recursive: true })
        await fs.mkdir(path.join(testAppRoot, 'data'), { recursive: true })
        await fs.mkdir(testTarget, { recursive: true })

        await fs.writeFile(path.join(testAppRoot, 'transmissions.ttl'), `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .
:test a :Transmission ;
    :pipe (:p10) .
:p10 a :NOP .`)

        await fs.writeFile(path.join(testAppRoot, 'config.ttl'), `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://purl.org/stuff/transmissions/> .
:config a :ConfigSet .`)

        await fs.writeFile(path.join(testAppRoot, 'about.md'), '# Test App')
    }

    async function cleanupTestFiles() {
        try {
            await fs.rm(testAppRoot, { recursive: true, force: true })
        } catch (err) {
            if (err.code !== 'ENOENT') throw err
        }
    }

    describe('message processing', () => {
        it('should propagate application context in messages', async () => {
            await manager.initialize('test_app_manager', testAppRoot, null, testTarget)

            const testMessage = { test: 'value' }
            const result = await manager.start(testMessage)

            expect(result).to.have.property('success', true)
            expect(testMessage).to.have.property('appName', 'test_app_manager')
            expect(testMessage).to.have.property('appPath', testAppRoot)
            expect(testMessage).to.have.property('targetPath', testTarget)
            expect(testMessage).to.have.property('dataDir').that.includes('data')
        })
    })
})

================
File: tests/integration/configmap.spec.js
================
import { expect } from 'chai';
import rdf from 'rdf-ext';
import ConfigMap from '../../src/processors/rdf/ConfigMap.js';
import ns from '../../src/utils/ns.js';

describe('ConfigMap Integration Tests', () => {
  let configMap;
  let message;
  const testBasePath = '/test/base';

  beforeEach(() => {
    configMap = new ConfigMap({});
    message = {
      rootDir: testBasePath,
      dataset: rdf.dataset()
    };
  });

  function addTestData(predicates) {
    const subject = rdf.namedNode('http://hyperdata.it/transmissions/Content');
    message.dataset.add(rdf.quad(
      subject,
      ns.rdf.type,
      ns.trn.ConfigSet
    ));

    for (const [pred, obj] of Object.entries(predicates)) {
      message.dataset.add(rdf.quad(
        subject,
        ns.trn[pred],
        rdf.literal(obj)
      ));
    }
  }

  it('should resolve paths from ContentGroup', async () => {
    addTestData({
      sourceDirectory: 'content/src',
      targetDirectory: 'content/out'
    });

    await configMap.process(message);
    expect(message.contentGroup?.Content?.sourceDir).to.equal('/test/base/content/src');
    expect(message.contentGroup?.Content?.targetDir).to.equal('/test/base/content/out');
  });

  it('should preserve absolute paths', async () => {
    addTestData({
      sourceDirectory: '/abs/path/src',
      targetDirectory: '/abs/path/out'
    });

    await configMap.process(message);
    expect(message.contentGroup?.Content?.sourceDir).to.equal('/abs/path/src');
    expect(message.contentGroup?.Content?.targetDir).to.equal('/abs/path/out');
  });

  it('should handle missing paths', async () => {
    addTestData({});
    await configMap.process(message);
    expect(message.contentGroup?.Content?.sourceDir).to.be.undefined;
    expect(message.contentGroup?.Content?.targetDir).to.be.undefined;
  });

  it('should normalize paths', async () => {
    addTestData({
      sourceDirectory: 'content/../src'
    });
    await configMap.process(message);
    expect(message.contentGroup?.Content?.sourceDir).to.equal('/test/base/src');
  });
});

================
File: tests/integration/file-container-integration-test.js
================
import { expect } from 'chai';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('FileContainer Integration', () => {
    const testDir = path.join(__dirname, '../../src/applications/test_file-container/data');
    const inputDir = path.join(testDir, 'input');
    const outputDir = path.join(testDir, 'output');

    beforeEach(async () => {
        await fs.mkdir(outputDir, { recursive: true });
        await fs.writeFile(
            path.join(inputDir, 'test1.js'),
            'console.log("test1");'
        );
        await fs.writeFile(
            path.join(inputDir, 'test2.js'),
            'console.log("test2");'
        );
    });

    afterEach(async () => {
        try {
            await fs.rm(outputDir, { recursive: true });
        } catch (err) {
            if (err.code !== 'ENOENT') throw err;
        }
    });

    it('should process files in pipeline', async () => {
        const { exec } = await import('child_process');
        const util = await import('util');
        const execAsync = util.promisify(exec);

        const result = await execAsync('node src/api/cli/run.js test_file-container', {
            cwd: path.resolve(__dirname, '../../')
        });

        const output = JSON.parse(await fs.readFile(
            path.join(outputDir, 'container-output.json'),
            'utf8'
        ));

        expect(output.files).to.have.property('test1.js');
        expect(output.files).to.have.property('test2.js');
        expect(output.summary.totalFiles).to.equal(2);
        expect(output.summary.fileTypes['.js']).to.equal(2);
    });
});

================
File: tests/integration/filename-mapper.spec.js
================
import { expect } from 'chai';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('filename-mapper test', () => {
    const dataDir = path.join(__dirname, '../../src/applications/test_filename-mapper/data');
    const inputDir = path.join(dataDir, 'input');
    const outputDir = path.join(dataDir, 'output');

    async function setupTestFiles() {
        await fs.mkdir(outputDir, { recursive: true });
        const inputContent = 'Test content for filename mapping';
        await fs.writeFile(path.join(inputDir, 'input-01.txt'), inputContent);
    }

    async function cleanup() {
        try {
            const files = await fs.readdir(outputDir);
            for (const file of files) {
                if (file.startsWith('output-')) {
                    await fs.unlink(path.join(outputDir, file));
                }
            }
        } catch (err) {
            if (err.code !== 'ENOENT') throw err;
        }
    }

    beforeEach(async () => {
        await cleanup();
        await setupTestFiles();
    });

    afterAll(async () => {
        await cleanup();
    });

    async function compareFiles() {
        const outputFile = path.join(outputDir, 'output-01.txt');
        const requiredFile = path.join(outputDir, 'required-01.txt');

        const [output, required] = await Promise.all([
            fs.readFile(outputFile, 'utf8'),
            fs.readFile(requiredFile, 'utf8')
        ]);

        return output.trim() === required.trim();
    }

    it('should process files correctly', async () => {
        const { exec } = await import('child_process');
        const util = await import('util');
        const execAsync = util.promisify(exec);

        const result = await execAsync('node src/api/cli/run.js test_filename-mapper', {
            cwd: path.resolve(__dirname, '../..')
        });

        const matched = await compareFiles();
        expect(matched).to.be.true;
    });
});

================
File: tests/integration/fork.spec.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import { exec } from 'child_process'

describe('fork test', function () {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const logFile = path.join(__dirname, '../../latest.log')

    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000

    it('should create correct number of message paths', (done) => {
        exec('node src/api/cli/run.js test_fork', async (error, stdout, stderr) => {
            if (error) {
                console.error('Exec error:', error)
                done(error)
                return
            }

            try {

                const logs = stdout.toString()
                const nopMatches = logs.match(/NOP at/g)
                const nopCount = nopMatches ? nopMatches.length : 0


                expect(nopCount).to.equal(3)
                done()
            } catch (err) {
                console.error('Test error:', err)
                done(err)
            }
        })
    })
})

================
File: tests/integration/fs-rw_simple.spec.js
================
import footpath from '../../src/utils/footpath.js'
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import fs from 'fs/promises'

describe('fs-rw simple test', function () {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const rootDir = path.resolve(__dirname, '../../')

    const outputFile = path.join(rootDir, 'src/applications/test_fs-rw/data/output/output-01.md')
    const requiredFile = path.join(rootDir, 'src/applications/test_fs-rw/data/output/required-01.md')

    beforeEach(async () => {
        try {
            await fs.unlink(outputFile)
        } catch (error) {
            if (error.code !== 'ENOENT') throw error
        }
    })

    it('should process file correctly', async () => {

        await import('../../src/applications/test_fs-rw/simple.js')


        const output = await fs.readFile(outputFile, 'utf8')
        const required = await fs.readFile(requiredFile, 'utf8')

        expect(output.trim()).to.equal(required.trim())
    })
})

================
File: tests/integration/fs-rw.spec.js
================
import { expect } from 'chai';
import rdf from 'rdf-ext';
import ConfigMap from '../../src/processors/rdf/ConfigMap.js';
import ns from '../../src/utils/ns.js';

describe('ConfigMap Integration Tests', () => {
    let configMap;
    let message;
    const testBasePath = '/test/base';

    beforeEach(() => {
        configMap = new ConfigMap({});
        message = {
            rootDir: testBasePath,
            dataset: rdf.dataset()
        };
    });

    function addTestData(predicates) {
        const subject = rdf.namedNode('http://hyperdata.it/transmissions/Content');
        message.dataset.add(rdf.quad(
            subject,
            ns.rdf.type,
            ns.trn.ConfigSet
        ));

        for (const [pred, obj] of Object.entries(predicates)) {
            message.dataset.add(rdf.quad(
                subject,
                ns.trn[pred],
                rdf.literal(obj)
            ));
        }
    }

    it('should resolve paths from ContentGroup', async () => {
        addTestData({
            sourceDirectory: 'content/src',
            targetDirectory: 'content/out'
        });

        await configMap.process(message);
        expect(message.contentGroup?.Content?.sourceDir).to.equal('/test/base/content/src');
        expect(message.contentGroup?.Content?.targetDir).to.equal('/test/base/content/out');
    });

    it('should preserve absolute paths', async () => {
        addTestData({
            sourceDirectory: '/abs/path/src',
            targetDirectory: '/abs/path/out'
        });

        await configMap.process(message);
        expect(message.contentGroup?.Content?.sourceDir).to.equal('/abs/path/src');
        expect(message.contentGroup?.Content?.targetDir).to.equal('/abs/path/out');
    });

    it('should handle missing paths', async () => {
        addTestData({});
        await configMap.process(message);
        expect(message.contentGroup?.Content?.sourceDir).to.be.undefined;
        expect(message.contentGroup?.Content?.targetDir).to.be.undefined;
    });

    it('should normalize paths', async () => {
        addTestData({
            sourceDirectory: 'content/../src'
        });
        await configMap.process(message);
        expect(message.contentGroup?.Content?.sourceDir).to.equal('/test/base/src');
    });
});

================
File: tests/integration/http-server.spec.js
================
import { expect } from 'chai';
import fetch from 'node-fetch';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

describe('HTTP Server Integration', () => {
    const SERVER_URL = 'http://localhost:4000';
    const TEST_VALUES = { testKey: 'testValue' };
    let serverProcess;

    before(async () => {
        serverProcess = exec('node src/api/cli/run.js test_http-server');
        await new Promise(resolve => setTimeout(resolve, 1000));
    });

    after(async () => {
        try {
            await fetch(`${SERVER_URL}/shutdown`, {
                method: 'POST'
            });
        } catch (e) {
            console.log('Server already stopped');
        }
    });

    it('should serve static files', async () => {
        const response = await fetch(`${SERVER_URL}/transmissions/test/`);
        expect(response.status).to.equal(200);
        const html = await response.text();
        expect(html).to.include('HTTP Server Test Interface');
    });

    it('should accept message values and shutdown', async () => {
        const response = await fetch(`${SERVER_URL}/shutdown`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(TEST_VALUES)
        });
        expect(response.status).to.equal(200);
    });
});

================
File: tests/integration/markmap.spec.js
================
import path from 'path';
import { fileURLToPath } from 'url';
import { expect } from 'chai';
import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Markmap Integration', () => {
    const testDir = path.join(__dirname, '../../src/applications/markmap/data/test');
    const testFiles = ['test1.md', 'test2.md'];

    beforeAll(async () => {

        await fs.mkdir(testDir, { recursive: true });


        await fs.writeFile(
            path.join(testDir, 'test1.md'),
            '# Test 1\n## Section 1\n* Item 1\n* Item 2'
        );

        await fs.writeFile(
            path.join(testDir, 'test2.md'),
            '# Test 2\n## Section 2\n* Item A\n* Item B'
        );
    });

    afterAll(async () => {

        await fs.rm(testDir, { recursive: true, force: true });
    });

    it('should process multiple markdown files through ForEach', async () => {
        const message = {
            paths: testFiles.map(f => path.join(testDir, f))
        };

        const result = await execAsync(
            `./trans markmap -m '${JSON.stringify(message)}'`
        );


        for (const file of testFiles) {
            const basePath = path.join(testDir, path.parse(file).name);


            const htmlPath = `${basePath}.mm.html`;
            const htmlExists = await fs.access(htmlPath)
                .then(() => true)
                .catch(() => false);
            expect(htmlExists).to.be.true;


            const html = await fs.readFile(htmlPath, 'utf8');
            expect(html).to.include('<html');
            expect(html).to.include(`Test ${file[4]}`);


            const svgPath = `${basePath}.mm.svg`;
            const svgExists = await fs.access(svgPath)
                .then(() => true)
                .catch(() => false);
            expect(svgExists).to.be.true;


            const svg = await fs.readFile(svgPath, 'utf8');
            expect(svg).to.include('<svg');
            expect(svg).to.include(`Test ${file[4]}`);
        }
    });

    it('should handle empty input paths array', async () => {
        const message = { paths: [] };

        const result = await execAsync(
            `./trans markmap -m '${JSON.stringify(message)}'`
        );


        const files = await fs.readdir(testDir);
        expect(files.filter(f => f.endsWith('.mm.html') || f.endsWith('.mm.svg')))
            .to.have.lengthOf(0);
    });

    it('should handle invalid markdown files gracefully', async () => {

        const invalidPath = path.join(testDir, 'invalid.md');
        await fs.writeFile(invalidPath, '# Title\n## [Invalid markdown');

        const message = {
            paths: [invalidPath]
        };

        try {
            await execAsync(`./trans markmap -m '${JSON.stringify(message)}'`);
        } catch (error) {
            expect(error.message).to.include('Error processing markdown');
        }
    });
});

================
File: tests/integration/restructure_simple.spec.js
================
import footpath from '../../src/utils/footpath.js'
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import fs from 'fs/promises'

describe('restructure simple test', function () {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const rootDir = path.resolve(__dirname, '../../')

    const outputFile = path.join(rootDir, 'src/applications/test_restructure/data/output/output-01.json')
    const requiredFile = path.join(rootDir, 'src/applications/test_restructure/data/output/required-01.json')

    beforeEach(async () => {
        try {
            await fs.unlink(outputFile)
        } catch (error) {
            if (error.code !== 'ENOENT') throw error
        }
    })

    it('should process JSON file correctly', async () => {
        console.log('Running restructure test')

        await import('../../src/applications/test_restructure/simple.js')


        const output = JSON.parse(await fs.readFile(outputFile, 'utf8'))
        const required = JSON.parse(await fs.readFile(requiredFile, 'utf8'))


        expect(output).to.deep.equal(required)
    })
})

================
File: tests/integration/restructure.spec.js
================
import footpath from '../../src/utils/footpath.js'
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import { exec } from 'child_process'
import fs from 'fs/promises'

describe('test_restructure', function () {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const dataDir = path.join(__dirname, '../../src/applications/test_restructure/data')

    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000

    async function clearOutputFiles() {
        console.log('Clearing output files...')
        const outputDir = path.join(dataDir, 'output')
        const files = await fs.readdir(outputDir)
        for (const file of files) {
            if (file.startsWith('output-')) {
                await fs.unlink(path.join(outputDir, file))
                console.log(`Deleted ${file}`)
            }
        }
    }

    async function compareFiles(index) {
        const outputFile = path.join(dataDir, 'output', `output-${index}.json`)
        const requiredFile = path.join(dataDir, 'output', `required-${index}.json`)

        console.log(`Comparing files:`)
        console.log(`Output: ${outputFile}`)
        console.log(`Required: ${requiredFile}`)

        const output = JSON.parse(await fs.readFile(outputFile, 'utf8'))
        const required = JSON.parse(await fs.readFile(requiredFile, 'utf8'))


        return JSON.stringify(output) === JSON.stringify(required)
    }

    beforeEach(async () => {
        await clearOutputFiles()
    })

    it('should process files correctly', (done) => {
        console.log('Running transmission...')
        exec('node src/api/cli/run.js test_restructure', async (error, stdout, stderr) => {
            if (error) {
                console.error('Exec error:', error)
                done(error)
                return
            }

            try {
                console.log('Transmission output:', stdout)
                if (stderr) console.error('Stderr:', stderr)

                const matched = await compareFiles('01')
                expect(matched).to.be.true
                done()
            } catch (err) {
                console.error('Test error:', err)
                done(err)
            }
        })
    })
})

================
File: tests/integration/run-command.spec.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import { exec } from 'child_process'
import fs from 'fs/promises'

describe('run-command test', function () {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const testDir = path.resolve(__dirname, '../../src/applications/test_run-command')

    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000


    beforeAll(async function () {
        try {
            await fs.mkdir(testDir, { recursive: true })

            const configTtl = `@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix t: <http://hyperdata.it/transmissions/> .

t:RunCommandConfig a trm:ConfigSet ;
    trm:settings t:runCommand ;
    trm:command "echo \\"test\\"" .`

            await fs.writeFile(path.join(testDir, 'config.ttl'), configTtl)

            const transmissionsTtl = `@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix : <http://hyperdata.it/transmissions/> .

:test_run_command a trm:Transmission ;
    trm:pipe (:p10 :p20) .

:p10 a :RunCommand ;
    trm:settings :runCommand .

:p20 a :ShowMessage .`

            await fs.writeFile(path.join(testDir, 'transmissions.ttl'), transmissionsTtl)
        } catch (err) {
            console.error('Setup error:', err)
            throw err
        }
    })

    it('should execute command successfully', (done) => {
        exec('node src/api/cli/run.js test_run-command', async (error, stdout, stderr) => {
            if (error) {
                console.error('Exec error:', error)
                done(error)
                return
            }

            try {
                expect(stdout).to.include('test')
                expect(stderr).to.be.empty
                done()
            } catch (err) {
                console.error('Test error:', err)
                done(err)
            }
        })
    })


    afterAll(async function () {
        try {
            await fs.rm(testDir, { recursive: true, force: true })
        } catch (err) {
            console.error('Cleanup error:', err)
        }
    })
})

================
File: tests/integration/string-filter.spec.js
================
import { expect } from 'chai';
import path from 'path';
import fs from 'fs/promises';
import rdf from 'rdf-ext';
import StringFilter from '../../src/processors/text/StringFilter.js';
import ns from '../../src/utils/ns.js';

describe('StringFilter Integration', () => {
    let filter;
    let testDir;

    beforeEach(async () => {
        testDir = path.join(process.cwd(), 'test-data', 'string-filter');
        await fs.mkdir(testDir, { recursive: true });
    });

    afterEach(async () => {
        await fs.rm(testDir, { recursive: true, force: true });
    });

    async function createTestFiles() {
        await Promise.all([
            fs.writeFile(path.join(testDir, 'test.js'), ''),
            fs.writeFile(path.join(testDir, 'test.css'), ''),
            fs.writeFile(path.join(testDir, 'build/test.js'), ''),
            fs.writeFile(path.join(testDir, 'node_modules/test.js'), '')
        ]);
    }

    function createConfigDataset(patterns) {
        const dataset = rdf.dataset();
        const subject = rdf.namedNode('http:

        dataset.add(rdf.quad(
            subject,
            ns.rdf.type,
            ns.trn.ConfigSet
        ));

        if (patterns.commaPattern) {
            dataset.add(rdf.quad(
                subject,
                ns.trn.excludePatterns,
                rdf.literal(patterns.commaPattern)
            ));
        }

        if (patterns.singlePatterns) {
            patterns.singlePatterns.forEach(pattern => {
                dataset.add(rdf.quad(
                    subject,
                    ns.trn.excludePattern,
                    rdf.literal(pattern)
                ));
            });
        }

        return { dataset, subject };
    }

    it('should handle comma-separated patterns', async () => {
        const { dataset, subject } = createConfigDataset({
            commaPattern: 'node_modules/*,build/*'
        });

        filter = new StringFilter({ dataset });
        filter.settingsNode = subject;

        await createTestFiles();

        const messages = await Promise.all([
            filter.process({ filepath: path.join(testDir, 'test.js') }),
            filter.process({ filepath: path.join(testDir, 'build/test.js') }),
            filter.process({ filepath: path.join(testDir, 'node_modules/test.js') })
        ]);

        const passedFiles = messages.filter(Boolean);
        expect(passedFiles).to.have.lengthOf(1);
        expect(passedFiles[0].filepath).to.include('test.js');
        expect(passedFiles[0].filepath).to.not.include('build');
        expect(passedFiles[0].filepath).to.not.include('node_modules');
    });

    it('should handle multiple single patterns', async () => {
        const { dataset, subject } = createConfigDataset({
            singlePatterns: ['node_modules/*', 'build/*']
        });

        filter = new StringFilter({ dataset });
        filter.settingsNode = subject;

        await createTestFiles();

        const messages = await Promise.all([
            filter.process({ filepath: path.join(testDir, 'test.js') }),
            filter.process({ filepath: path.join(testDir, 'build/test.js') }),
            filter.process({ filepath: path.join(testDir, 'node_modules/test.js') })
        ]);

        const passedFiles = messages.filter(Boolean);
        expect(passedFiles).to.have.lengthOf(1);
        expect(passedFiles[0].filepath).to.include('test.js');
        expect(passedFiles[0].filepath).to.not.include('build');
        expect(passedFiles[0].filepath).to.not.include('node_modules');
    });

    it('should handle mixed pattern styles', async () => {
        const { dataset, subject } = createConfigDataset({
            commaPattern: 'node_modules/*',
            singlePatterns: ['build/*']
        });

        filter = new StringFilter({ dataset });
        filter.settingsNode = subject;

        await createTestFiles();

        const messages = await Promise.all([
            filter.process({ filepath: path.join(testDir, 'test.js') }),
            filter.process({ filepath: path.join(testDir, 'build/test.js') }),
            filter.process({ filepath: path.join(testDir, 'node_modules/test.js') })
        ]);

        const passedFiles = messages.filter(Boolean);
        expect(passedFiles).to.have.lengthOf(1);
        expect(passedFiles[0].filepath).to.include('test.js');
        expect(passedFiles[0].filepath).to.not.include('build');
        expect(passedFiles[0].filepath).to.not.include('node_modules');
    });
});

================
File: tests/integration/test_apps.spec.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import { expect } from 'chai'
import { exec } from 'child_process'
import fs from 'fs/promises'
import { glob } from 'glob'
import { existsSync } from 'fs'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const rootDir = path.resolve(__dirname, '../../')

async function runCommand(command, options) {
    return new Promise((resolve) => {
        const startTime = process.hrtime()
        const proc = exec(`./trans ${command}`, { ...options, cwd: rootDir })
        let stdout = '', stderr = ''

        proc.stdout.on('data', (data) => {
            stdout += data
            process.stdout.write(data)
        })

        proc.stderr.on('data', (data) => {
            stderr += data
            process.stderr.write(data)
        })

        proc.on('exit', (code, signal) => {
            const endTime = process.hrtime(startTime)
            const duration = (endTime[0] + endTime[1] / 1e9).toFixed(3)


            const hasError = stdout.includes('TypeError:') ||
                stdout.includes('Error:') ||
                stderr.includes('TypeError:') ||
                stderr.includes('Error:')

            const result = {
                stdout,
                stderr,
                code,
                signal,
                success: code === 0 && !hasError,
                duration
            }
            resolve(result)
        })
    })
}

describe('Application Integration Tests', function () {
    it('should run test applications', async function () {
        const testApps = await glob(path.join(rootDir, 'src/applications/test_*'))
        expect(testApps.length).to.be.greaterThan(0)

        for (const appDir of testApps) {
            const appName = path.basename(appDir)
            console.log(`\nTesting ${appName}`)

            const configPath = path.join(appDir, 'test-config.json')
            const config = existsSync(configPath) ?
                JSON.parse(await fs.readFile(configPath, 'utf8')) :
                { transmissions: [{ name: appName }] }

            for (const tx of config.transmissions) {
                let cmd = tx.name
                if (tx.message) cmd += ` -m '${JSON.stringify(tx.message)}'`

                const result = await runCommand(cmd)

                if (!result.success) {
                    console.error('\n' + '='.repeat(80))
                    console.error(` Test failed for ${cmd}`)
                    console.error('='.repeat(80))
                    console.error('\nExecution Details:')
                    console.error('-'.repeat(40))
                    console.error(`Duration: ${result.duration}s`)
                    console.error('Exit code:', result.code)
                    console.error('Signal:', result.signal)

                    if (result.error) {
                        console.error('\nError Details:')
                        console.error('-'.repeat(40))
                        console.error('Message:', result.error.message)
                        console.error('Stack:', result.error.stack)
                    }

                    if (result.stderr) {
                        console.error('\nStderr Output:')
                        console.error('-'.repeat(40))
                        console.error(result.stderr)
                    }

                    console.error('\nStdout Output:')
                    console.error('-'.repeat(40))
                    console.error(result.stdout || '(no stdout output)')

                    console.error('\nTest Configuration:')
                    console.error('-'.repeat(40))
                    console.error(JSON.stringify(tx, null, 2))
                    console.error('\n' + '='.repeat(80))

                    try {
                        const failuresDir = path.join(rootDir, 'test-failures', appName, new Date().toISOString().replace(/:/g, '-'))
                        await fs.mkdir(failuresDir, { recursive: true })
                        await fs.writeFile(
                            path.join(failuresDir, 'test-output.json'),
                            JSON.stringify({ result, config: tx }, null, 2)
                        )
                        console.error(`Failure details saved to: ${failuresDir}`)
                    } catch (err) {
                        console.error('Failed to save failure details:', err)
                    }
                } else {
                    console.log(` ${cmd} completed successfully (${result.duration}s)`)
                }

                expect(result.success, `Command failed: ${cmd} with exit code ${result.code}`).to.be.true

                if (tx.requiredFiles) {
                    for (const pattern of tx.requiredFiles) {
                        const outputFiles = await glob(path.join(appDir, 'data/output', pattern))
                        for (const outputFile of outputFiles) {
                            const requiredFile = outputFile.replace('output-', 'required-')
                            const [output, required] = await Promise.all([
                                fs.readFile(outputFile, 'utf8'),
                                fs.readFile(requiredFile, 'utf8')
                            ])
                            expect(output.trim()).to.equal(required.trim())
                        }
                    }
                }
            }
        }
    })
})

================
File: tests/integration/test-data-generator_string-filter.js
================
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

class TestDataGenerator {
    constructor(baseDir) {
        this.baseDir = baseDir;
        this.inputDir = path.join(baseDir, 'input');
        this.outputDir = path.join(baseDir, 'output');
        this.fileTypes = new Set(['.txt', '.js', '.log', '.md', '.json']);
    }

    async init() {
        await fs.mkdir(this.inputDir, { recursive: true });
        await fs.mkdir(this.outputDir, { recursive: true });
    }

    async cleanup() {
        await fs.rm(this.baseDir, { recursive: true, force: true });
    }

    async createDirectoryStructure() {
        const structure = {
            'docs': {
                'api': ['config.md', 'overview.md'],
                'examples': ['basic.js', 'advanced.js']
            },
            'src': {
                'lib': ['util.js', 'core.js'],
                'test': ['test.js', 'mock.js']
            },
            'temp': ['temp1.log', 'temp2.log'],
            'data': ['data.json', 'schema.json']
        };

        for (const [dir, contents] of Object.entries(structure)) {
            const dirPath = path.join(this.inputDir, dir);
            await fs.mkdir(dirPath, { recursive: true });

            if (Array.isArray(contents)) {
                for (const file of contents) {
                    await this.createTestFile(path.join(dir, file));
                }
            } else {
                for (const [subdir, files] of Object.entries(contents)) {
                    const subdirPath = path.join(dirPath, subdir);
                    await fs.mkdir(subdirPath, { recursive: true });

                    for (const file of files) {
                        await this.createTestFile(path.join(dir, subdir, file));
                    }
                }
            }
        }
    }

    async createTestFile(relativePath, content = '') {
        const filePath = path.join(this.inputDir, relativePath);
        const ext = path.extname(filePath);

        if (!content) {
            content = this.generateContent(ext);
        }

        await fs.writeFile(filePath, content);
        return filePath;
    }

    generateContent(ext) {
        const timestamp = new Date().toISOString();

        switch (ext) {
            case '.js':
                return `// Test file generated ${timestamp}
export function test() {
    return 'test content';
}`;

            case '.json':
                return JSON.stringify({
                    generated: timestamp,
                    type: 'test',
                    version: '1.0.0'
                }, null, 2);

            case '.md':
                return `# Test File
Generated: ${timestamp}

## Content
Test content for markdown file.`;

            case '.log':
                return `[${timestamp}] INFO Test log content
[${timestamp}] DEBUG Additional details`;

            default:
                return `Test content generated at ${timestamp}`;
        }
    }

    async createPatternTestSet() {
        const testCases = [
            { file: 'include.js', shouldMatch: true },
            { file: 'exclude.txt', shouldMatch: false },
            { file: '.hidden.js', shouldMatch: false },
            { file: 'temp.dat', shouldMatch: false },
            { file: 'test.min.js', shouldMatch: true },
            { file: 'backup.js.bak', shouldMatch: false }
        ];

        const files = await Promise.all(testCases.map(async ({ file }) => {
            const filePath = await this.createTestFile(file);
            return { path: filePath, name: file };
        }));

        return {
            files,
            testCases: testCases.reduce((acc, { file, shouldMatch }) => {
                acc[file] = shouldMatch;
                return acc;
            }, {})
        };
    }

    async createNestedStructure(depth = 3, filesPerLevel = 2) {
        const files = [];

        async function createLevel(currentPath, currentDepth) {
            if (currentDepth > depth) return;

            const dirPath = path.join(this.inputDir, currentPath);
            await fs.mkdir(dirPath, { recursive: true });

            for (let i = 1; i <= filesPerLevel; i++) {
                const filename = `level${currentDepth}-file${i}.js`;
                const filePath = path.join(currentPath, filename);
                await this.createTestFile(filePath);
                files.push(filePath);
            }

            await createLevel.call(
                this,
                path.join(currentPath, `level${currentDepth + 1}`),
                currentDepth + 1
            );
        }

        await createLevel.call(this, 'nested', 1);
        return files;
    }

    async createLargeFileSet(count = 1000) {
        const files = [];
        const types = Array.from(this.fileTypes);

        for (let i = 1; i <= count; i++) {
            const type = types[i % types.size];
            const filename = `file${String(i).padStart(5, '0')}${type}`;
            const filePath = await this.createTestFile(filename);
            files.push(filePath);
        }

        return files;
    }

    getExpectedOutput(inputPath) {
        const filename = path.basename(inputPath);
        if (!filename.includes('.')) return null;

        const [name, ...extensions] = filename.split('.');
        const baseExt = extensions.pop();

        return {
            html: path.join(this.outputDir, `${name}.mm.html`),
            svg: path.join(this.outputDir, `${name}.mm.svg`)
        };
    }
}

export default TestDataGenerator;

================
File: tests/integration/test-settings-integration.js
================
import { expect } from 'chai'
import path from 'path'
import { fileURLToPath } from 'url'
import { exec } from 'child_process'
import fs from 'fs/promises'

describe('TestSettings Integration', function() {
    const __filename = fileURLToPath(import.meta.url)
    const __dirname = path.dirname(__filename)
    const testDir = path.join(__dirname, '../../src/applications/test_config-settings')


    beforeAll(async () => {
        const files = ['config.ttl', 'transmissions.ttl']
        for (const file of files) {
            const exists = await fs.access(path.join(testDir, file))
                .then(() => true)
                .catch(() => false)
            expect(exists, `${file} exists`).to.be.true
        }
    })


    it('should process settings through transmission pipeline', (done) => {
        exec('node src/api/cli/run.js test_config-settings', {
            cwd: path.resolve(__dirname, '../..')
        }, async (error, stdout, stderr) => {
            if (error) {
                done(error)
                return
            }

            try {

                expect(stdout).to.include('settingsSingle')
                expect(stdout).to.include('Alice')


                expect(stdout).to.include('settingsMulti')
                expect(stdout).to.include('Bob')
                expect(stdout).to.include('dirB')


                expect(stdout).to.include('settingsLists')
                expect(stdout).to.include('settingA1')
                expect(stdout).to.include('settingB1')

                done()
            } catch (err) {
                done(err)
            }
        })
    })


    it('should handle missing configuration gracefully', (done) => {
        const badConfigPath = path.join(testDir, 'missing-config.ttl')

        exec(`node src/api/cli/run.js test_config-settings -c ${badConfigPath}`, {
            cwd: path.resolve(__dirname, '../..')
        }, (error, stdout, stderr) => {
            expect(stdout).to.include('fallback value')
            expect(stderr).to.not.include('UnhandledPromiseRejection')
            done()
        })
    })


    it('should handle settings inheritance', (done) => {
        exec('node src/api/cli/run.js test_config-settings inherit', {
            cwd: path.resolve(__dirname, '../..')
        }, async (error, stdout, stderr) => {
            try {
                expect(stdout).to.include('base setting')
                expect(stdout).to.include('inherited setting')
                done()
            } catch (err) {
                done(err)
            }
        })
    })


    it('should reload changed configuration', async () => {
        const configPath = path.join(testDir, 'config.ttl')
        const backupPath = path.join(testDir, 'config.ttl.bak')


        await fs.copyFile(configPath, backupPath)

        try {

            const config = await fs.readFile(configPath, 'utf8')
            const modified = config.replace('Alice', 'Modified')
            await fs.writeFile(configPath, modified)


            await new Promise((resolve, reject) => {
                exec('node src/api/cli/run.js test_config-settings', {
                    cwd: path.resolve(__dirname, '../..')
                }, (error, stdout, stderr) => {
                    try {
                        expect(stdout).to.include('Modified')
                        resolve()
                    } catch (err) {
                        reject(err)
                    }
                })
            })

        } finally {

            await fs.copyFile(backupPath, configPath)
            await fs.unlink(backupPath)
        }
    })


    it('should pass settings between processors', (done) => {
        exec('node src/api/cli/run.js test_config-settings chain', {
            cwd: path.resolve(__dirname, '../..')
        }, (error, stdout, stderr) => {
            try {

                expect(stdout).to.include('first processor setting')
                expect(stdout).to.include('second processor setting')
                expect(stdout).to.include('combined settings')
                done()
            } catch (err) {
                done(err)
            }
        })
    })
})

================
File: tests/support/jasmine-browser.json
================
{
  "srcDir": "src",
  "srcFiles": [
    "**/*.js"
  ],
  "specDir": "spec",
  "specFiles": [
    "**/*[sS]pec.js"
  ],
  "helpers": [
    "helpers/**/*.js"
  ],
  "env": {
    "stopSpecOnExpectationFailure": false,
    "stopOnSpecFailure": false,
    "random": true
  },
  "browser": {
    "name": "firefox"
  }
}

================
File: tests/unit/_old/ProcessorSettings.sp_ec.js
================
import { expect } from 'chai'
import rdf from 'rdf-ext'
import ProcessorSettings from '../../../src/processors/base/ProcessorSettings.js'
import ns from '../../../src/utils/ns.js'

describe('ProcessorSettings', () => {
    let settings
    let config

    beforeEach(() => {
        const dataset = rdf.dataset()
        config = { dataset }
        settings = new ProcessorSettings(config)
    })

    function addTestData(subject, predicates) {
        const subjectTerm = rdf.namedNode(`http://example.org/${subject}`)
        config.dataset.add(rdf.quad(
            subjectTerm,
            ns.rdf.type,
            ns.trn.ConfigSet
        ))

        for (const [pred, values] of Object.entries(predicates)) {
            if (Array.isArray(values)) {
                values.forEach(value => {
                    config.dataset.add(rdf.quad(
                        subjectTerm,
                        ns.trn[pred],
                        rdf.literal(value)
                    ))
                })
            } else {
                config.dataset.add(rdf.quad(
                    subjectTerm,
                    ns.trn[pred],
                    rdf.literal(values)
                ))
            }
        }
        return subjectTerm
    }

    describe('getValues()', () => {
        it('should return array with single value when one exists', () => {
            const subject = addTestData('config', {
                testProp: 'value1'
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.testProp)
            expect(values).to.be.an('array').with.lengthOf(1)
            expect(values[0]).to.equal('value1')
        })

        it('should return array with multiple individual values', () => {
            const subject = addTestData('config', {
                excludePattern: ['value1', 'value2', 'value3']
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.excludePattern)
            expect(values).to.be.an('array').with.lengthOf(3)
            expect(values).to.include('value1')
            expect(values).to.include('value2')
            expect(values).to.include('value3')
        })

        it('should handle comma-separated values', () => {
            const subject = addTestData('config', {
                excludePatterns: 'value1,value2, value3'
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.excludePatterns)
            expect(values).to.be.an('array').with.lengthOf(3)
            expect(values).to.include('value1')
            expect(values).to.include('value2')
            expect(values).to.include('value3')
        })

        it('should handle values from referenced settings', () => {
            const refSubject = addTestData('ref', {
                testProp: ['refValue1', 'refValue2']
            })

            const mainSubject = addTestData('config', {})
            config.dataset.add(rdf.quad(
                mainSubject,
                ns.trn.settings,
                refSubject
            ))

            settings.settingsNode = mainSubject
            const values = settings.getValues(ns.trn.testProp)
            expect(values).to.be.an('array').with.lengthOf(2)
            expect(values).to.include('refValue1')
            expect(values).to.include('refValue2')
        })

        it('should return fallback in array when no values exist', () => {
            const subject = addTestData('config', {})
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.testProp, 'fallback')
            expect(values).to.be.an('array').with.lengthOf(1)
            expect(values[0]).to.equal('fallback')
        })
    })

    describe('getValue()', () => {
        it('should return first value when multiple exist', () => {
            const subject = addTestData('config', {
                testProp: ['value1', 'value2']
            })
            settings.settingsNode = subject

            const value = settings.getValue(ns.trn.testProp)
            expect(value).to.equal('value1')
        })

        it('should return fallback when no values exist', () => {
            const subject = addTestData('config', {})
            settings.settingsNode = subject

            const value = settings.getValue(ns.trn.testProp, 'fallback')
            expect(value).to.equal('fallback')
        })
    })
})

================
File: tests/unit/Application.spec.js
================
import { expect } from 'chai'
import path from 'path'
import Application from '../../src/model/Application.js'

describe('Application', () => {
    let app

    beforeEach(() => {
        app = new Application()
    })

    describe('constructor', () => {
        it('should initialize with default values', () => {
            expect(app.appsDir).to.equal('src/applications')
            expect(app.transmissionFilename).to.equal('transmissions.ttl')
            expect(app.configFilename).to.equal('config.ttl')
            expect(app.appName).to.be.null
            expect(app.dataset).to.be.null
        })

        it('should accept custom options', () => {
            const customApp = new Application({
                appName: 'test-app',
                appPath: '/custom/path',
                subtask: 'custom-task'
            })
            expect(customApp.appName).to.equal('test-app')
            expect(customApp.appPath).to.equal('/custom/path')
            expect(customApp.subtask).to.equal('custom-task')
        })
    })

    describe('resolveApplicationPath', () => {
        it('should handle absolute paths', () => {
            const absolutePath = '/absolute/path/to/app'
            expect(app.resolveApplicationPath(absolutePath)).to.equal(absolutePath)
        })

        it('should handle relative paths', () => {
            const relativePath = '../relative/path'
            const expected = path.resolve(process.cwd(), relativePath)
            expect(app.resolveApplicationPath(relativePath)).to.equal(expected)
        })

        it('should resolve paths under appsDir', () => {
            const appName = 'test-app'
            const expected = path.join(process.cwd(), app.appsDir, appName)
            expect(app.resolveApplicationPath(appName)).to.equal(expected)
        })

        it('should throw error for empty app name', () => {
            expect(() => app.resolveApplicationPath()).to.throw('Application name is required')
        })
    })

    describe('initialize', () => {
        it('should set up application with valid parameters', async () => {
            const appName = 'test-app'
            const appPath = '/test/path'
            const subtask = 'test-task'
            const target = '/test/target'

            await app.initialize(appName, appPath, subtask, target)

            expect(app.appName).to.equal(appName)
            expect(app.appPath).to.equal(appPath)
            expect(app.subtask).to.equal(subtask)
            expect(app.targetPath).to.equal(target)
            expect(app.manifestFilename).to.equal(path.join(target, 'manifest.ttl'))
        })
    })

    describe('toMessage', () => {
        it('should generate correct message object', () => {
            const testApp = new Application({
                appName: 'test-app',
                appPath: '/test/path',
                subtask: 'test-task',
                targetPath: '/test/target'
            })

            const message = testApp.toMessage()

            expect(message).to.have.property('appName', 'test-app')
            expect(message).to.have.property('appPath', '/test/path')
            expect(message).to.have.property('subtask', 'test-task')
            expect(message).to.have.property('targetPath', '/test/target')
            expect(message).to.have.property('dataDir').that.includes('data')
            expect(message).to.have.property('dataset')
        })
    })
})

================
File: tests/unit/file-container-unit-test.js
================
import { expect } from 'chai';
import FileContainer from '../../../src/processors/packer/FileContainer.js';

describe('FileContainer', () => {
    let container;
    const config = { destination: 'test-output.json' };

    beforeEach(() => {
        container = new FileContainer(config);
    });

    it('should store file content and metadata', async () => {
        const message = {
            filepath: '/test/file.js',
            content: 'console.log("test")',
            rootDir: '/test'
        };

        let outputMessage;
        container.on('message', (msg) => {
            outputMessage = msg;
        });

        await container.process(message);

        expect(container.container.files['file.js']).to.exist;
        expect(container.container.files['file.js'].content).to.equal(message.content);
        expect(container.container.files['file.js'].type).to.equal('.js');
    });

    it('should update summary statistics', async () => {
        await container.process({
            filepath: '/test/file1.js',
            content: 'test',
            rootDir: '/test'
        });

        expect(container.container.summary.totalFiles).to.equal(1);
        expect(container.container.summary.fileTypes['.js']).to.equal(1);
    });

    it('should handle done message correctly', async () => {
        await container.process({
            filepath: '/test/file.js',
            content: 'test',
            rootDir: '/test'
        });

        let finalMessage;
        container.on('message', (msg) => {
            finalMessage = msg;
        });

        await container.process({ done: true });

        expect(finalMessage.content).to.be.a('string');
        expect(finalMessage.filepath).to.equal(config.destination);
    });
});

================
File: tests/unit/filename-mapper.spec.js
================
import FilenameMapper from '../../src/processors/fs/FilenameMapper.js';
import { expect } from 'chai';

describe('FilenameMapper', () => {
    let filenameMapper;

    beforeEach(() => {
        filenameMapper = new FilenameMapper({
            extensions: {
                html: '.mm.html',
                svg: '.mm.svg'
            }
        });
    });

    it('should map HTML extension correctly', async () => {
        const message = {
            filepath: '/test/example.md',
            format: 'html'
        };

        let outputMessage;
        filenameMapper.on('message', (msg) => {
            outputMessage = msg;
        });

        await filenameMapper.process(message);
        expect(outputMessage.filepath).to.equal('/test/example.mm.html');
    });

    it('should map SVG extension correctly', async () => {
        const message = {
            filepath: '/test/example.md',
            format: 'svg'
        };

        let outputMessage;
        filenameMapper.on('message', (msg) => {
            outputMessage = msg;
        });

        await filenameMapper.process(message);
        expect(outputMessage.filepath).to.equal('/test/example.mm.svg');
    });

    it('should throw error for missing filepath', async () => {
        const message = {
            format: 'html'
        };

        try {
            await filenameMapper.process(message);
            expect.fail('Should have thrown error');
        } catch (error) {
            expect(error.message).to.equal('No filepath provided in message');
        }
    });

    it('should throw error for unknown format', async () => {
        const message = {
            filepath: '/test/example.md',
            format: 'unknown'
        };

        try {
            await filenameMapper.process(message);
            expect.fail('Should have thrown error');
        } catch (error) {
            expect(error.message).to.equal('Unknown format: unknown');
        }
    });

    it('should preserve directory structure', async () => {
        const message = {
            filepath: '/deep/nested/path/example.md',
            format: 'html'
        };

        let outputMessage;
        filenameMapper.on('message', (msg) => {
            outputMessage = msg;
        });

        await filenameMapper.process(message);
        expect(outputMessage.filepath).to.equal('/deep/nested/path/example.mm.html');
    });
});

================
File: tests/unit/http-server_MetricsService.spec.js
================
import { expect } from 'chai';
import WebSocket from 'ws';
import MetricsService from '../../src/processors/http/services/MetricsService.js';
import http from 'http';

describe('MetricsService', () => {
    let metricsService;
    let server;
    let wsClient;

    beforeEach((done) => {
        server = http.createServer();
        server.listen(0, () => {
            metricsService = new MetricsService(server);
            const port = server.address().port;
            wsClient = new WebSocket(`ws://localhost:${port}`);
            wsClient.on('open', done);
        });
    });

    afterEach((done) => {
        wsClient.close();
        server.close(done);
    });

    it('should send metrics updates', (done) => {
        wsClient.on('message', (data) => {
            const metrics = JSON.parse(data.toString());
            expect(metrics).to.have.property('uptime');
            expect(metrics).to.have.property('requests');
            expect(metrics).to.have.property('connections');
            expect(metrics).to.have.property('memory');
            expect(metrics).to.have.property('cpu');
            done();
        });
    });

    it('should increment requests counter', () => {
        const initialRequests = metricsService.metrics.requests;
        metricsService.incrementRequests();
        expect(metricsService.metrics.requests).to.equal(initialRequests + 1);
    });

    it('should track connections', (done) => {
        const newClient = new WebSocket(`ws://localhost:${server.address().port}`);
        newClient.on('open', () => {
            expect(metricsService.metrics.connections).to.equal(2);
            newClient.close();
            setTimeout(() => {
                expect(metricsService.metrics.connections).to.equal(1);
                done();
            }, 100);
        });
    });
});

================
File: tests/unit/http-server_ShutdownService.spec.js
================
import { expect } from 'chai';
import express from 'express';
import ShutdownService from '../../src/processors/http/services/ShutdownService.js';

describe('ShutdownService', () => {
    let app;
    let shutdownService;
    let shutdownCalled = false;

    beforeEach(() => {
        app = express();
        shutdownService = new ShutdownService();
        shutdownService.setupMiddleware(app);
        shutdownService.setupEndpoints(app, () => { shutdownCalled = true; });
    });

    it('should reject requests without auth', (done) => {
        const mockReq = { headers: {} };
        const mockRes = {
            setHeader: jasmine.createSpy('setHeader'),
            status: function (code) {
                expect(code).toBe(401);
                return { send: function () { } };
            }
        };

        app._router.handle(mockReq, mockRes, () => { });
        expect(mockRes.setHeader).toHaveBeenCalledWith('WWW-Authenticate', 'Basic');
        done();
    });

    it('should accept valid credentials', (done) => {
        const credentials = Buffer.from(`${shutdownService.username}:${shutdownService.password}`).toString('base64');
        const mockReq = {
            headers: {
                authorization: `Basic ${credentials}`
            }
        };
        const mockRes = {
            status: jasmine.createSpy('status'),
            send: jasmine.createSpy('send')
        };
        const nextSpy = jasmine.createSpy('next');

        app._router.handle(mockReq, mockRes, nextSpy);
        expect(nextSpy).toHaveBeenCalled();
        done();
    });
});

================
File: tests/unit/markmap.spec..js
================
import MarkMap from '../../../src/applications/markmap/processors/MarkMap.js';
import { expect } from 'chai';

describe('MarkMap', () => {
    let markMap;

    beforeEach(() => {
        markMap = new MarkMap({});
    });

    it('should transform markdown to HTML and SVG', async () => {
        const message = {
            filepath: '/test/example.md',
            content: '# Test Heading\n## Subheading\n* Item 1\n* Item 2'
        };

        let htmlMessage, svgMessage;

        markMap.on('message', (msg) => {
            if (msg.filepath.endsWith('.mm.html')) {
                htmlMessage = msg;
            } else if (msg.filepath.endsWith('.mm.svg')) {
                svgMessage = msg;
            }
        });

        await markMap.process(message);

        expect(htmlMessage).to.exist;
        expect(htmlMessage.content).to.include('<html');
        expect(htmlMessage.content).to.include('Test Heading');
        expect(htmlMessage.filepath).to.equal('/test/example.mm.html');

        expect(svgMessage).to.exist;
        expect(svgMessage.content).to.include('<svg');
        expect(svgMessage.content).to.include('Test Heading');
        expect(svgMessage.filepath).to.equal('/test/example.mm.svg');
    });

    it('should handle empty content', async () => {
        const message = {
            filepath: '/test/empty.md',
            content: ''
        };

        try {
            await markMap.process(message);
            expect.fail('Should have thrown error');
        } catch (error) {
            expect(error.message).to.equal('No content provided in message');
        }
    });
});

================
File: tests/unit/NOP.spec.js
================
import NOP from '../../src/processors/util/NOP.js'
import { expect } from 'chai'

describe('NOP', function () {
    it('double() should return the input string concatenated with itself', function () {
        const nop = new NOP()
        const input = 'test'
        const expectedOutput = 'testtest'
        const output = nop.double(input)
        expect(output).to.equal(expectedOutput)
    })
})

================
File: tests/unit/PostcraftPrep.spec.js
================
import PostcraftPrep from '../../src/processors/postcraft/PostcraftPrep.js'
import { expect } from 'chai'

describe('PostcraftPrep', function () {
    beforeEach(function () {
        this.context = {
            content: 'only text',
            filename: 'minimal-filename.md'
        }
    })

    it('extractTitle(context) should lift the title from the filename', function () {
        this.context.filename = '2024-05-10_this-thing.md'
        const input = this.context
        const expectedOutput = 'This Thing'
        const pp = new PostcraftPrep()
        const output = pp.extractTitle(input)
        expect(output).to.equal(expectedOutput)
    })

    it('extractSlug(context) should return filename without path and extension', function () {
        this.context.filename = '2024-05-10_hello-postcraft.md'
        const input = this.context
        const expectedOutput = '2024-05-10_hello-postcraft'
        const pp = new PostcraftPrep()
        const output = pp.extractSlug(input)
        expect(output).to.equal(expectedOutput)
    })

    it('extractTargetFilename(context) should return the correct target filename', function () {
        this.context.filename = '2024-05-10_hello-postcraft.md'
        this.context.rootDir = '/root'
        this.context.entryContentMeta = {
            targetDir: 'target'
        }
        const input = this.context
        const expectedOutput = '/root/target/2024-05-10_hello-postcraft.html'
        const pp = new PostcraftPrep()
        const output = pp.extractTargetFilename(input)
        expect(output).to.equal(expectedOutput)
    })

    it('extractDates(context) should return the correct dates', function () {
        this.context.filename = '2024-05-10_hello-postcraft.md'
        const input = this.context
        const expectedOutput = { created: '2024-05-10', updated: (new Date()).toISOString().split('T')[0] }
        const pp = new PostcraftPrep()
        const output = pp.extractDates(input)
        expect(output).to.deep.equal(expectedOutput)
    })
})

================
File: tests/unit/ProcessorSettings.spec.js
================
import { expect } from 'chai'
import rdf from 'rdf-ext'
import ProcessorSettings from '../../src/processors/base/ProcessorSettings.js'
import ns from '../../src/utils/ns.js'

describe('ProcessorSettings', () => {
    let settings
    let config

    beforeEach(() => {
        const dataset = rdf.dataset()
        config = { dataset }
        settings = new ProcessorSettings(config)
    })

    function addTestData(subject, predicates) {
        const subjectTerm = rdf.namedNode(`http://example.org/${subject}`)
        config.dataset.add(rdf.quad(
            subjectTerm,
            ns.rdf.type,
            ns.trn.ConfigSet
        ))

        for (const [pred, values] of Object.entries(predicates)) {
            if (Array.isArray(values)) {
                values.forEach(value => {
                    config.dataset.add(rdf.quad(
                        subjectTerm,
                        ns.trn[pred],
                        rdf.literal(value)
                    ))
                })
            } else {
                config.dataset.add(rdf.quad(
                    subjectTerm,
                    ns.trn[pred],
                    rdf.literal(values)
                ))
            }
        }
        return subjectTerm
    }

    describe('getValues()', () => {
        it('should return array with single value when one exists', () => {
            const subject = addTestData('config', {
                testProp: 'value1'
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.testProp)
            expect(values).to.be.an('array').with.lengthOf(1)
            expect(values[0]).to.equal('value1')
        })

        it('should return array with multiple individual values', () => {
            const subject = addTestData('config', {
                excludePattern: ['value1', 'value2', 'value3']
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.excludePattern)
            expect(values).to.be.an('array').with.lengthOf(3)
            expect(values).to.include('value1')
            expect(values).to.include('value2')
            expect(values).to.include('value3')
        })

        it('should handle comma-separated values', () => {
            const subject = addTestData('config', {
                excludePatterns: 'value1,value2, value3'
            })
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.excludePattern)
            expect(values).to.be.an('array').with.lengthOf(3)
            expect(values).to.include('value1')
            expect(values).to.include('value2')
            expect(values).to.include('value3')
        })

        it('should handle empty or undefined settingsNode', () => {
            settings.settingsNode = null
            const values = settings.getValues(ns.trn.testProp)
            expect(values).to.be.an('array').with.lengthOf(0)
        })

        it('should handle values from referenced settings', () => {
            const refSubject = addTestData('ref', {
                testProp: ['refValue1', 'refValue2']
            })

            const mainSubject = addTestData('config', {})
            config.dataset.add(rdf.quad(
                mainSubject,
                ns.trn.settings,
                refSubject
            ))

            settings.settingsNode = mainSubject
            const values = settings.getValues(ns.trn.testProp)
            expect(values).to.be.an('array').with.lengthOf(2)
            expect(values).to.include('refValue1')
            expect(values).to.include('refValue2')
        })

        it('should return fallback in array when no values exist', () => {
            const subject = addTestData('config', {})
            settings.settingsNode = subject

            const values = settings.getValues(ns.trn.testProp, 'fallback')
            expect(values).to.be.an('array').with.lengthOf(1)
            expect(values[0]).to.equal('fallback')
        })
    })

    describe('getValue()', () => {
        it('should return first value when multiple exist', () => {
            const subject = addTestData('config', {
                testProp: ['value1', 'value2']
            })
            settings.settingsNode = subject

            const value = settings.getValue(ns.trn.testProp)
            expect(value).to.equal('value1')
        })

        it('should return fallback when no values exist', () => {
            const subject = addTestData('config', {})
            settings.settingsNode = subject

            const value = settings.getValue(ns.trn.testProp, 'fallback')
            expect(value).to.equal('fallback')
        })

        it('should handle undefined settingsNode', () => {
            settings.settingsNode = null
            const value = settings.getValue(ns.trn.testProp, 'fallback')
            expect(value).to.equal('fallback')
        })
    })

    describe('Integration', () => {
        it('should handle mixed configurations', () => {
            const subject = addTestData('config', {
                directValue: 'direct',
                commaPattern: 'one,two,three',
                multiValue: ['a', 'b', 'c']
            })
            settings.settingsNode = subject

            expect(settings.getValues(ns.trn.directValue)).to.have.lengthOf(1)
            expect(settings.getValues(ns.trn.multiValue)).to.have.lengthOf(3)
            expect(settings.getValue(ns.trn.commaPattern).split(','))
                .to.have.lengthOf(3)
        })
    })
})

================
File: tests/unit/RunCommand.spec.js
================
import RunCommand from '../../src/processors/unsafe/RunCommand.js';
import { expect } from 'chai';
import fs from 'fs/promises';
import path from 'path';

describe('RunCommand', function () {
    let runCommand;
    const dataDir = 'src/applications/test_runcommand/data';

    beforeEach(function () {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;
        runCommand = new RunCommand({
            simples: true,
            allowedCommands: ['echo', 'ls'],
            blockedPatterns: ['rm', '|', ';'],
            timeout: 50
        });
    });

    it('should validate command output against required file', async function () {
        const requiredPath = path.join(dataDir, 'output', 'required-01.txt');
        const required = await fs.readFile(requiredPath, 'utf8');
        const message = { command: 'echo "Hello from RunCommand!"' };

        const result = await runCommand.process(message);
        expect(result.content.trim()).to.equal(required.trim());
    });

    it('should handle timeouts', async function () {

        const neverEndingCommand = `echo "test" && while true; do :; done`;
        try {
            await runCommand.executeCommand(neverEndingCommand);
            expect.fail('Should have timed out');
        } catch (error) {
            expect(error.message).to.equal('Command timeout');
        }
    });

    it('should block disallowed commands', async function () {
        const message = { command: 'rm -rf /' };
        try {
            await runCommand.process(message);
            expect.fail('Should have blocked dangerous command');
        } catch (error) {
            expect(error.message).to.include('not in allowed list');
        }
    });

    it('should block commands with dangerous patterns', async function () {
        const message = { command: 'echo "test" | grep test' };
        try {
            await runCommand.process(message);
            expect.fail('Should have blocked command with pipe');
        } catch (error) {
            expect(error.message).to.include('blocked pattern');
        }
    });
});

================
File: tests/unit/StringFilter.spec.js
================
import StringFilter from '../../src/processors/text/StringFilter.js';
import { expect } from 'chai';

describe('StringFilter', function () {

    function compose(content, include, exclude) {
        return { content, include, exclude };
    }


    const contentSamples = [
        '/home/user/documents/',
        '/home/user/documents/file.txt',
        '/var/log/',
        '/etc/config.conf',
        '/usr/local/bin/app',
        '/home/user/pictures/vacation/',
        '/home/user/pictures/vacation/photo.jpg',
        '/opt/',
        '/tmp/temp.file',
        '/home/user/.config/',
        '',
        undefined
    ];

    const patternSamples = [
        '*.txt',
        '*.jpg',
        '/home/user/*',
        '/var/*',
        '*/bin/*',
        ['*.txt', '*.jpg'],
        ['/home/user/*', '/var/*'],
        ['*/bin/*', '*.conf'],
        ['*.file', '/tmp/*'],
        ['/opt/*', '/etc/*'],
        '',
        [],
        undefined
    ];

    describe('isAccepted()', function () {
        it('should accept all content when include and exclude are empty', function () {
            const filter = new StringFilter();
            contentSamples.forEach(content => {
                if (content !== undefined) {
                    const message = compose(content, '', '');
                    expect(filter.isAccepted(message.content, message.exclude, message.include)).to.be.true;
                }
            });
        });

        it('should reject undefined content', function () {
            const filter = new StringFilter();
            const message = compose(undefined, '', '');
            expect(filter.isAccepted(message.content, message.exclude, message.include)).to.be.false;
        });

        it('should correctly apply include patterns', function () {
            const filter = new StringFilter();
            const includeTests = [
                { content: '/home/user/documents/file.txt', include: '*.txt', expected: true },
                { content: '/home/user/pictures/vacation/photo.jpg', include: '*.jpg', expected: true },
                { content: '/var/log/', include: '/var/*', expected: true },
                { content: '/home/user/documents/', include: '/home/user/*', expected: true },
                { content: '/usr/local/bin/app', include: '*/bin/*', expected: true },
                { content: '/etc/config.conf', include: ['*.conf', '*.txt'], expected: true },
                { content: '/opt/', include: ['/var/*', '/opt/*'], expected: true },
                { content: '/tmp/temp.file', include: '*.doc', expected: false }
            ];

            includeTests.forEach(test => {
                const message = compose(test.content, test.include, '');
                expect(filter.isAccepted(message.content, message.exclude, message.include)).to.equal(test.expected);
            });
        });

        it('should correctly apply exclude patterns', function () {
            const filter = new StringFilter();
            const excludeTests = [
                { content: '/home/user/documents/file.txt', exclude: '*.txt', expected: false },
                { content: '/home/user/pictures/vacation/photo.jpg', exclude: '*.jpg', expected: false },
                { content: '/var/log/', exclude: '/var/*', expected: false },
                { content: '/home/user/documents/', exclude: '/home/user/*', expected: false },
                { content: '/usr/local/bin/app', exclude: '*/bin/*', expected: false },
                { content: '/etc/config.conf', exclude: ['*.conf', '*.txt'], expected: false },
                { content: '/opt/', exclude: ['/var/*', '/tmp/*'], expected: true },
                { content: '/tmp/temp.file', exclude: '*.doc', expected: true }
            ];

            excludeTests.forEach(test => {
                const message = compose(test.content, '', test.exclude);
                expect(filter.isAccepted(message.content, message.exclude, message.include)).to.equal(test.expected);
            });
        });

        it('should correctly apply both include and exclude patterns', function () {
            const filter = new StringFilter();
            const combinedTests = [
                { content: '/home/user/documents/file.txt', include: '*.txt', exclude: '/var/*', expected: true },
                { content: '/var/log/system.log', include: '*.log', exclude: '/var/*', expected: false },
                { content: '/home/user/pictures/vacation/photo.jpg', include: ['/home/user/*', '*.jpg'], exclude: '*.png', expected: true },
                { content: '/etc/config.conf', include: ['*.conf', '*.txt'], exclude: ['/home/*', '/var/*'], expected: true },
                { content: '/usr/local/bin/app', include: '*/bin/*', exclude: '*/local/*', expected: false }
            ];

            combinedTests.forEach(test => {
                const message = compose(test.content, test.include, test.exclude);
                expect(filter.isAccepted(message.content, message.exclude, message.include)).to.equal(test.expected);
            });
        });
    });
});

================
File: tests/unit/StringReplace.spec.js
================
import StringReplace from '../../src/processors/text/StringReplace.js'
import { expect } from 'chai'




describe('StringReplace', function () {



    it('execute() should replace all occurrences of the match string with the replace string', function () {

        const stringReplace = new StringReplace()
        const message = {
            content: 'Hello world! Hello universe!',
            match: 'Hello',
            replace: 'Hi'
        }


        stringReplace.process(message)


        const expectedOutput = 'Hi world! Hi universe!'
        expect(message.content).to.equal(expectedOutput)
    })




    it('execute() should not modify the content if the match string is not found', function () {

        const stringReplace = new StringReplace()
        const message = {
            content: 'Hello world!',
            match: 'Goodbye',
            replace: 'Hi'
        }


        stringReplace.process(message)


        const expectedOutput = 'Hello world!'
        expect(message.content).to.equal(expectedOutput)
    })




    it('execute() should handle empty content string', function () {

        const stringReplace = new StringReplace()
        const message = {
            content: '',
            match: 'Hello',
            replace: 'Hi'
        }


        stringReplace.process(message)


        const expectedOutput = ''
        expect(message.content).to.equal(expectedOutput)
    })
})

================
File: tests/unit/test.settings.spec.js
================
import { expect } from 'chai'
import rdf from 'rdf-ext'
import TestSettings from '../../src/processors/test/TestSettings.js'
import ns from '../../src/utils/ns.js'

describe('TestSettings', () => {
    let settings
    let config
    let dataset

    beforeEach(() => {
        dataset = rdf.dataset()
        config = { dataset }
        settings = new TestSettings(config)
    })

    function addTestData(subject, predicates) {
        const subjectTerm = rdf.namedNode(`http://example.org/${subject}`)
        config.dataset.add(rdf.quad(
            subjectTerm,
            ns.rdf.type,
            ns.trn.ConfigSet
        ))

        for (const [pred, values] of Object.entries(predicates)) {
            if (Array.isArray(values)) {
                values.forEach(value => {
                    config.dataset.add(rdf.quad(
                        subjectTerm,
                        ns.trn[pred],
                        rdf.literal(value)
                    ))
                })
            } else {
                config.dataset.add(rdf.quad(
                    subjectTerm,
                    ns.trn[pred],
                    rdf.literal(values)
                ))
            }
        }
        return subjectTerm
    }

    describe('process()', () => {
        it('should process message with direct settings', async () => {
            const subject = addTestData('test1', {
                name: 'Test Name',
                value: '42'
            })
            settings.settingsNode = subject

            const message = {}
            const result = await settings.process(message)

            expect(result).to.exist
            const name = settings.getProperty(ns.trn.name)
            expect(name).to.equal('Test Name')
        })

        it('should handle settings with multiple values', async () => {
            const subject = addTestData('test2', {
                setting: ['value1', 'value2', 'value3']
            })
            settings.settingsNode = subject

            const message = {}
            const result = await settings.process(message)

            const values = settings.getValues(ns.trn.setting)
            expect(values).to.have.length(3)
            expect(values).to.include('value1')
        })

        it('should handle message without settings', async () => {
            const message = {}
            const result = await settings.process(message)
            expect(result).to.exist
        })

        it('should preserve message properties', async () => {
            const subject = addTestData('test3', {
                name: 'Test'
            })
            settings.settingsNode = subject

            const message = {
                existingProp: 'value'
            }
            const result = await settings.process(message)

            expect(result.existingProp).to.equal('value')
        })
    })
})

================
File: tests/unit/updated-shutdown-test.js
================
import { expect } from 'chai';
import express from 'express';
import jwt from 'jsonwebtoken';
import ShutdownService from '../../src/processors/http/services/ShutdownService.js';

describe('ShutdownService', () => {
    let app;
    let shutdownService;
    let shutdownCalled = false;

    beforeEach(() => {
        app = express();
        app.use(express.json());
        shutdownService = new ShutdownService();
        shutdownService.setupMiddleware(app);
        shutdownService.setupEndpoints(app, () => { shutdownCalled = true; });
    });

    it('should generate valid JWT tokens', (done) => {
        const token = shutdownService.generateToken();
        const decoded = jwt.verify(token, shutdownService.secret);
        expect(decoded).to.have.property('action', 'shutdown');
        done();
    });

    it('should require valid token for shutdown', (done) => {
        const validToken = shutdownService.generateToken();


        const mockReq = {
            headers: { authorization: `Bearer ${validToken}` }
        };
        const mockRes = {
            status: function(code) {
                return { send: function(msg) {} };
            }
        };
        const nextSpy = jasmine.createSpy('next');

        app._router.handle(mockReq, mockRes, nextSpy);
        expect(nextSpy).toHaveBeenCalled();
        done();
    });

    it('should reject expired tokens', (done) => {
        const expiredToken = jwt.sign(
            { action: 'shutdown' },
            shutdownService.secret,
            { expiresIn: '0s' }
        );

        setTimeout(() => {
            const mockReq = {
                headers: { authorization: `Bearer ${expiredToken}` }
            };
            const mockRes = {
                status: function(code) {
                    expect(code).toBe(403);
                    return {
                        send: function(msg) {
                            expect(msg).toBe('Invalid token');
                        }
                    };
                }
            };

            app._router.handle(mockReq, mockRes, () => {});
            done();
        }, 100);
    });
});

================
File: tests/about.md
================
```sh
cd ~/github-danny/transmissions # my local dir

npm test -- tests/unit/ProcessorSettings.spec.js

npm test -- tests/integration/string-filter.spec.js


npm test -- tests/unit/Application.spec.js

npm test -- tests/integration/application-manager.spec.js


```

================
File: types/grapoi.d.ts
================
import { DatasetCore, Quad, Term } from "@rdfjs/types";


interface Grapoi extends PathList {
    addList(predicates: Term | Term[], items: Term | Term[]): Grapoi;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): Grapoi;
    base(base: Term | Term[]): Grapoi;
}


interface Edge {
    dataset: DatasetCore;
    end: string;
    quad: Quad;
    start: string;
    term: Term;
    graph: Term;
    startTerm: Term;
}


interface Instruction {
    operation?: string;
    quantifier?: string;
    start?: string;
    end?: string;
    subjects?: Term[];
    predicates?: Term[];
    objects?: Term[];
    graphs?: DatasetCore[];
    items?: Term[];
    callback?: (edge: Edge, ptr: Path | PathList) => Path | PathList;
}


interface Path {
    addList(predicates: Term | Term[], items: Term | Term[]): Path;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): Path;
    deleteIn(predicates: Term | Term[], subjects: Term | Term[]): Path;
    deleteList(predicates: Term | Term[]): Path;
    deleteOut(predicates: Term | Term[], objects: Term | Term[]): Path;
    extend(edge: Edge): Path;
    execute(instruction: Instruction): Path;
}


interface PathList {
    addList(predicates: Term | Term[], items: Term | Term[]): PathList;
    addOut(predicates: Term | Term[], objects: Term | Term[], callback?: Function): PathList;
    deleteIn(predicates: Term | Term[], subjects: Term | Term[]): PathList;
    deleteList(predicates: Term | Term[]): PathList;
    deleteOut(predicates: Term | Term[], objects: Term | Term[]): PathList;
    distinct(): PathList;
    in(predicates: Term | Term[], subjects: Term | Term[]): PathList;
    isAny(): boolean;
    isList(): boolean;
    list(): Iterator<Term> | undefined;
    map(callback: Function): PathList[];
    out(predicates: Term | Term[], objects: Term | Term[]): PathList;
    quads(): Iterator<Quad>;
    execute(instruction: Instruction): PathList[];
}

================
File: types/processor.d.ts
================
import { Term, Dataset, NamedNode } from '@rdfjs/types';
import { EventEmitter } from 'events';

export interface ProcessorConfig {
    dataset?: Dataset;
    [key: string]: any;
}

export interface ProcessorMessage {
    content?: any;
    filepath?: string;
    done?: boolean;
    tags?: string;
    [key: string]: any;
}

export interface ProcessorSettings {
    config: ProcessorConfig;
    settingsNode: Term | null;
    getValues(property: Term, fallback?: any): string[];
    getValue(property: Term, fallback?: any): string | undefined;
}

export interface IProcessor {
    config: ProcessorConfig;
    settings: ProcessorSettings;
    messageQueue: { message: ProcessorMessage }[];
    processing: boolean;
    outputs: any[];
    settingsNode?: Term;
    message?: ProcessorMessage;

    getValues(property: Term, fallback?: any): string[];
    getProperty(property: Term, fallback?: any): string | undefined;
    preProcess(message: ProcessorMessage): Promise<void>;
    postProcess(message: ProcessorMessage): Promise<void>;
    process(message: ProcessorMessage): Promise<void>;
    receive(message: ProcessorMessage): Promise<void>;
    enqueue(message: ProcessorMessage): Promise<void>;
    executeQueue(): Promise<void>;
    emit(event: string, message: ProcessorMessage): Promise<ProcessorMessage>;
    getOutputs(): any[];
}

export interface StringFilterConfig extends ProcessorConfig {
    includePatterns?: string[];
    excludePatterns?: string[];
}

export interface IStringFilter extends IProcessor {
    initialized: boolean;
    includePatterns: string[];
    excludePatterns: string[];
    initialize(): Promise<void>;
    matchPattern(filePath: string, pattern: string): boolean;
    isAccepted(filePath: string): boolean;
}

================
File: .babelrc
================
{
  "plugins": ["@babel/syntax-dynamic-import"],
  "presets": [
    [
      "@babel/preset-env",
      {
        "modules": false
      }
    ]
  ]
}

================
File: .gitignore
================
**/src-old
**/*\ copy.js

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: jasmine.json
================
{
    "spec_dir": "tests",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [
        "helpers/reporter.js"
    ],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "allowSyntheticDefaultImports": true,
    "baseUrl": "./",
    "paths": {
      "*": ["node_modules/*", "types/*"]
    }
  },
  "include": [
    "src/**/*",
    "src/api/cli/run.js",
    "../trans-apps/applications/git-apps/github_",
    "src-old/CommandUtils copy.js",
    "../trans-apps/applications/markmap"
  ],
  "exclude": ["node_modules", "**/node_modules/*"],
  "typeAcquisition": {
    "include": ["@rdfjs/types", "grapoi"]
  }
}

================
File: jsdoc.json
================
{
    "source": {
        "include": [
            "src"
        ],
        "exclude": [
            "node_modules"
        ],
        "includePattern": ".+\\.js(doc|x)?$",
        "excludePattern": "(^|\\/|\\\\)_"
    },
    "opts": {
        "verbose": true,
        "recurse": true,
        "destination": "./docs/jsdoc"
    },
    "plugins": [
        "plugins/markdown"
    ]
}

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "type": "module",
  "version": "1.0.0",
  "description": "Transmissions",
  "name": "transmissions",
  "scripts": {
    "test": "jasmine --config=jasmine.json --reporter=tests/helpers/reporter.js",
    "cov": "nyc -a --include=src --reporter=lcov npm run test",
    "docs": "jsdoc -c jsdoc.json",
    "build": "webpack --mode=production --node-env=production",
    "build:dev": "webpack --mode=development",
    "build:prod": "webpack --mode=production --node-env=production",
    "rp": "node --no-warnings $(which repomix) -c repomix.config-small.json . && node --no-warnings $(which repomix) -c repomix.config-large.json . && node --no-warnings $(which repomix) -c repomix.config-docs.json .",
    "watch": "webpack --watch",
    "serve": "webpack serve"
  },
  "nyc": {
    "report-dir": "spec/coverage",
    "exclude": [
      "spec/**/*"
    ]
  },
  "devDependencies": {
    "@babel/core": "^7.23.7",
    "@babel/preset-env": "^7.23.8",
    "autoprefixer": "^10.4.17",
    "babel-loader": "^9.1.3",
    "chai": "^5.0.3",
    "css-loader": "^6.9.1",
    "html-webpack-plugin": "^5.6.0",
    "jasmine": "^5.1.0",
    "jasmine-browser-runner": "^2.3.0",
    "jasmine-core": "^5.1.1",
    "jasmine-spec-reporter": "^7.0.0",
    "jsdoc": "^4.0.2",
    "mini-css-extract-plugin": "^2.7.7",
    "nyc": "^17.1.0",
    "postcss": "^8.4.33",
    "postcss-loader": "^8.0.0",
    "prettier": "^3.2.4",
    "style-loader": "^3.3.4",
    "webpack": "^5.90.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1",
    "workbox-webpack-plugin": "^7.0.0"
  },
  "dependencies": {
    "@dotenvx/dotenvx": "^1.14.2",
    "@rdfjs/formats": "^4.0.0",
    "@rdfjs/parser-n3": "^2.0.2",
    "axios": "^1.6.8",
    "cheerio": "^1.0.0-rc.12",
    "cors": "^2.8.5",
    "d3": "^7.9.0",
    "ignore": "^7.0.0",
    "jsdom": "^25.0.0",
    "lodash": "^4.17.21",
    "loglevel": "^1.9.2",
    "marked": "^12.0.1",
    "marked-code-format": "^1.1.6",
    "marked-custom-heading-id": "^2.0.10",
    "marked-footnote": "^1.2.4",
    "markmap-lib": "^0.17.0",
    "markmap-render": "^0.17.0",
    "markmap-toolbar": "^0.17.0",
    "markmap-view": "^0.17.0",
    "node-mime-types": "^1.1.2",
    "nunjucks": "^3.2.4",
    "queue": "^7.0.0",
    "rdf-ext": "^2.5.2",
    "rdf-utils-fs": "^3.0.0",
    "repomix": "^0.2.12",
    "string-to-stream": "^3.0.1",
    "yargs": "^17.7.2"
  }
}

================
File: postcss.config.js
================
module.exports = {


  plugins: [["autoprefixer"]],
};

================
File: README.md
================
# transmissions

After _No Code_ and _Lo Code_ comes _Marginally Less Code_

**Transmissions** is a micro-framework intended to simplify construction of small pipeliney data processing applications in JavaScript (assuming you are already familiar with JavaScript and RDF).

The code is in active development, ie. **not stable**, subject to arbitrary changes.

A bit like `make` or a `package.json` builder. But much harder work (and fun).

Applications are defined in several places, the bits of interest are eg. Postcraft's [transmissions.ttl](https://github.com/danja/transmissions/blob/main/src/applications/postcraft/transmissions.ttl) and [services.ttl](https://github.com/danja/transmissions/blob/main/src/applications/postcraft/services.ttl).
The former defines the flow, the latter config of the services (under [src/services](https://github.com/danja/transmissions/tree/main/src/services)). The runtime instance of the application is given in the target [manifest.ttl](https://github.com/danja/postcraft/blob/main/danny.ayers.name/manifest.ttl).

### Installation etc.

This is not ready yet. But if you really must...

Make a fresh dir. Clone this repo and [Postcraft](https://github.com/danja/postcraft) into it.

```
cd transmissions
npm i
```

This may or may not work :

```
npm run test
```

Then if you do :

```
./trans postcraft /home/danny/github-danny/postcraft/danny.ayers.name
```

it may build a site (my blog - this is dogfooding to the max) under `public/home`

```
./trans
```

on its own should list the applications available. Most of these won't work, the code has been shapeshifting a lot.

### Status

**2024-09-02** Getting used as a serrrrriously over-engineered, feature-lacking static site builder, proof of concept is [Postcraft](https://github.com/danja/postcraft), as evinced by my [blog](https://danny.ayers.name/) (where, for now at least you will find update on this). But it mostly works as intended. Docs lagging. But now I have a documentation engine...

Documentation will be lagging behind code, be incomplete and out of date.

**2024-03-24** : a couple of simple data processing pipelines working and wired up as Jasmine e2e tests in place; started to develop actually useful pipelines for [foaf-archive](https://github.com/danja/foaf-archive) project

## Motivation

This was prompted by something of a ~~perfect storm~~ serendipitous convergence of ideas, requirements and environment.

- I had the realization that much of the software I want to write in the near future has the same basic high level **architecture** : pipeline-like, ie. a series of steps each of which transform data from one form into another ([Wikipedia](<https://en.wikipedia.org/wiki/Pipeline_(software)>)).
- **Pipelines** are approachable using concepts from Design Patterns like [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection), [Inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) etc. A key benefit of such patterns is that, because the components are loosely coupled, they can largely be developed in isolation as small standalone units before integration into a larger application.
- **Large Language Models** currently struggle with large codebases and complex architectures (mostly due to [context window](https://en.wikipedia.org/wiki/Large_language_model#Prompt_engineering,_attention_mechanism,_and_context_window) limitations). But they are very good at building small, simple, self-contained units of code.

reused in different contexts.

_I'm writing this with GitHub Copilot enabled for markdown, which can be helpful, but sometimes it goes off on one... After the first point above it offered :_

```
This is true of a blog engine, a personal knowledge management system, a chatbot, a mail archive miner, a web scraper, a data visualizer, a data importer/exporter, a data transformer, a data validator, a data filter, a data aggregator, a data splitter, a data joiner, a data normalizer, a data summarizer, a data classifier, a data indexer, a data search engine, a data storage system, a data retrieval system, a data synchronization system, a data backup system, a data migration system, a data versioning system, a data sharing system, a data access control system, a data privacy system, a data security system, a data integrity system, a data quality system, a data governance system, a data provenance system, a data lineage system, a data lifecycle system, a data archiving system, a data retention system, a data deletion system, a data recovery system, a data discovery system, a data exploration system, a data analysis system, a data visualization system, a data reporting system, a data monitoring system, a data alerting system, a data forecasting system, a data prediction system, a data recommendation system, a data personalization system, a data optimization system, a data simulation system, a data modeling system, a data inference system, a data learning system, a data reasoning system, a data decision system, a data planning system, a data execution system, a data monitoring system, a data feedback system, a data control system, a data automation system, a data orchestration system, a data integration system, a data federation system, a data interoperability system, a data exchange system, a data transformation system, a data migration system, a data synchronization system, a data replication system, a data federation system, a data virtualization system, a data streaming system, a data batch system, a data real-time system, a data near-real-time system, a data historical system, a data temporal system, a data spatial system, a data geospatial system, a data network system, a data graph system, a data tree system, a data list system, a data set system, a data table system, a data document system, a data record system, a data entity system, a data attribute system, a data value system, a data type system, a data format system, a data encoding system, a data serialization
```

_... which is a little over the top, but it's a fair list of things that might be helped by a micro-framework like this. Remarkably the first 5 are pretty much my immediate intended uses for this._

**Docs below need updating**

for later :

The [Community Solid Server](https://github.com/CommunitySolidServer/CommunitySolidServer) uses [Components.js](https://componentsjs.readthedocs.io/en/latest/) to specify how modules and components need to be wired together at runtime. Components.js is a dependency injection framework for JavaScript applications.

## What it is

A low-level system for data processing pipelines/networks. Wherever convenient functionality will be defined declaratively with JSON-LD configuration files.

Dependency injection is used internally to allow loose coupling of components.

## What it isn't

There are several sophisticated frameworks for building interfaces between software applications and creating data processing networks. NodeRed, NoFlo etc. This is not one of them. This is much more basic and bare bones, down in the details.

See also [David Booth](https://github.com/dbooth-boston)'s [RDF Pipeline Framework](https://github.com/rdf-pipeline)

_I do eventually want to use this with NodeRed or whatever, but the entities created by transmissions will be at the level of nodes in such networks, not the network itself._

## Motivation

I'm in the process of writing yet another blog engine (Postcraft). I've also started working on a playground for interconnecting intelligent agents in an XMPP multiuser chat environment (Kia). I'm also revising a system for managing a personal knowledge base in the world of LLMs (HKMS). These all share functionality around connectivity to external data/messaging systems and internal data transformation. Might as well write this bit once only, and avoid thinking about software architecture more than I have to.

### Goals

To facilate :

- rapid development of small applications
- reuse of components in a loosely-couple environment
- versatility

### Soft Goals

- performance - low on the list
- scalability - ditto
- security - ditto

================
File: rename-script.sh
================
find src -type f -iname "*packer*" | while read -r file; do
    dir=$(dirname "$file")
    base=$(basename "$file")


    if [[ $base =~ [Pp][Aa][Cc][Kk][Ee][Rr] ]]; then

        packer_part=$(echo "$base" | grep -o '[Pp][Aa][Cc][Kk][Ee][Rr]')


        if [[ $packer_part == [A-Z]* ]]; then
            replacement="Terrapack"
        elif [[ $packer_part == [A-Z]* ]]; then
            replacement="TERRAPACK"
        else
            replacement="terrapack"
        fi


        newname="$dir/$(echo "$base" | sed "s/$packer_part/$replacement/")"

        # Rename file if new name is different
        if [ "$file" != "$newname" ]; then
            mv -i "$file" "$newname"
            echo "Renamed: $file  $newname"
        fi
    fi
done

================
File: terrapack.config.json
================
{
  "output": {
    "filePath": "terrapack-transmissions.json",
    "format": "text/plain",
    "removeComments": true,
    "summary": true
  },
  "filters": {
    "include": [
      "*.js",
      "*.jsx",
      "*.ts",
      "*.tsx",
      "*.md",
      "*.ttl",
      "*.json"
    ],
    "exclude": [
      "node_modules",
      ".git",
      "dist",
      "build",
      "coverage",
      "**/test/*",
      "**/*.test.*",
      "**/*.spec.*",
      "**/*copy*",
      "**/_*"
    ]
  }
}

================
File: trans
================
#!/bin/bash

# use 'chmod +x run' to make this executable

# Execute the Node.js script with Node
node src/api/cli/run.js "$@"

================
File: users.json
================
[{"uuid": "dc67aa7d-f71f-4232-afb3-7f2688ac68f7", "full_name": "Danny Ayers", "email_address": "danny.ayers@gmail.com", "verified_phone_number": null}]

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const WorkboxWebpackPlugin = require('workbox-webpack-plugin');

const isProduction = process.env.NODE_ENV == 'production';


const stylesHandler = MiniCssExtractPlugin.loader;



const config = {
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
    },
    devServer: {
        open: true,
        host: 'localhost',
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: 'index.html',
        }),

        new MiniCssExtractPlugin(),



    ],
    module: {
        rules: [
            {
                test: /\.(js|jsx)$/i,
                loader: 'babel-loader',
            },
            {
                test: /\.css$/i,
                use: [stylesHandler, 'css-loader', 'postcss-loader'],
            },
            {
                test: /\.(eot|svg|ttf|woff|woff2|png|jpg|gif)$/i,
                type: 'asset',
            },



        ],
    },
};

module.exports = () => {
    if (isProduction) {
        config.mode = 'production';


        config.plugins.push(new WorkboxWebpackPlugin.GenerateSW());

    } else {
        config.mode = 'development';
    }
    return config;
};
